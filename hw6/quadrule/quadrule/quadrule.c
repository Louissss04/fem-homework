/* Program for finding quadrature rules for triangles/tetrahedra
 *
 * Author: Lin-bo Zhang (zlb@lsec.cc.ac.cn)
 *
 * Copyright (C) 2005-2016 State Key Laboratory of Scientific and
 * Engineering Computing, Chinese Academy of Sciences.
 *
 * Test cases:
 *	quadrule 1 7 4			# 1D, 4 point Gaussian rule
 *	quadrule 1 7 5 1 2:1		# 1D, 5 point Gauss-Lobatto rule
 *	quadrule 2 11 28 1 5 2		# 2D, 28 point, order 11 rule
 *	quadrule 3 7 35 1 1 1 2 0	# 3D, 35 point, order 7 rule
 *	quadrule 3 8 46 0 4 1 2 0 10000	# 3D, 46 point, order 8 rule
 *					# (trying up to 10000 initial guesses)
 *
 * $Id: quadrule.c,v 1.386 2020/08/04 14:19:29 zlb Exp $ */

#ifndef FT_PHG
/* Note: one of FT_FLOAT, FT_DOUBLE, FT_LONG_DOUBLE, and FT___FLOAT128 */
# define FT_PHG	FT_LONG_DOUBLE
#endif

#ifndef USE_MPI
# define	USE_MPI	0
#endif

#ifndef USE_MPFR
# define	USE_MPFR 0
#endif

#include "quadrule.h"

#ifndef NONLINEAR_SOLVER
# define NONLINEAR_SOLVER MINPACK
#endif

#ifndef MINPACK_SOLVER
# define MINPACK_SOLVER	LMDIF	/* LMDIF, LMDER, HYBRD, HYBRJ */
#endif

#ifndef LINEAR_LS
# define LINEAR_LS	0	/* Type of linear solver when computing weights:
				  !0: least square,
				   0: Gauss elimination (with full pivoting) */
#endif

#ifndef USE_MAPPING
# define USE_MAPPING	1
#endif

/* INDEPENDENT_W != 0 ==> treat weights as independent vars */
#ifndef INDEPENDENT_W
# if USE_MAPPING
#  define INDEPENDENT_W	0
# else
#  define INDEPENDENT_W	0
# endif
#endif

#if (USE_MAPPING && INDEPENDENT_W && NONLINEAR_SOLVER == MINPACK && \
     (MINPACK_SOLVER == LMDIF || MINPACK_SOLVER == LMDER))
# warning using LMDIF/LMDER with mapping and independent weights is bad!
#endif

#ifndef ASYNCHRONOUS
# define ASYNCHRONOUS	1	/* asynchronous mode (use file to communi.) */
#endif

/* WARNING: genetic code not finished and currently broken */
#ifndef GENETIC
# define GENETIC	0	/* != 0 ==> use G.A. to find initial approx. */
#endif

/* WARNING: code with SYMMETRY == 0 is broken */
#ifndef SYMMETRY
# define SYMMETRY	1	/* != 0 ==> enforce symmetry */
#endif

/*---------------------------- global parameters ----------------------------*/

#if FT_PHG == FT_FLOAT
# define REPORT_TOL0	1e-5	/* tolerance for reporting a solution */
# define ACCEPT_TOL0	2e-7	/* tolerance for accepting a solution */
#elif FT_PHG == FT_DOUBLE
# define REPORT_TOL0	1e-9	/* tolerance for reporting a solution */
# define ACCEPT_TOL0	1e-12	/* tolerance for accepting a solution */
#elif FT_PHG == FT_LONG_DOUBLE
# define REPORT_TOL0	1e-12	/* tolerance for reporting a solution */
# define ACCEPT_TOL0	1e-15	/* tolerance for accepting a solution */
#elif FT_PHG == FT___FLOAT128
# define REPORT_TOL0	1e-25	/* tolerance for reporting a solution */
# define ACCEPT_TOL0	1e-28	/* tolerance for accepting a solution */
#endif

#ifndef REPORT_TOL
# define REPORT_TOL	REPORT_TOL0
#endif
#ifndef ACCEPT_TOL
# define ACCEPT_TOL	ACCEPT_TOL0
#endif

#ifndef EPS
# define EPS		1e-18	/* convergence criterion for the NLS solver */
#endif

#ifndef OUTBOUND_TOL
# define OUTBOUND_TOL	1e-6	/* out of bound tolerance */
#endif

#define Random(a)	(rand() * (FLOAT)(a) / RAND_MAX)

/* Note:
 *   1.	The polynomial space is generated by the npolys_max monomials
 *	whose orders are listed in 'porders[npolys_max][dim + 1]'.
 *
 *	The first 'npolys' polynomials must be included as the trial functions
 *	to ensure quadrature order. The others can be optionally used.
 *
 *   2. 'POLY *p' contains the monomials 'porders[0..p->n]':
 *	    if (p->coeff == NULL) then it's the monomial 'porders[p->n]'
 *		with coefficient 'p->coeff0'
 *	    else it's coefficients are given by 'p->coeff[0..p->n]'
 */
typedef struct {
    FLOAT coeff0;	/* coefficient of the monomial when coeff == NULL */
    FLOAT *coeff;	/* coefficients (coeff[0..n]) */
    int *o;		/* list of orders (always points to 'porders') */
    int n;		/* number of terms (the monomials porders[0..n]) */
} POLY;

static int guess_max = 200;	/* maxi. ntries */
static int stop_flag = 1;	/* stop if a good solution is found */
static int nprocs = 1, myrank = 0;

static int print = 0;		/* controls output verbosity */
static int plot = 0;		/* plot (obsolete) */

static char *dump_fname = NULL;	/* filename to dump the moment equations to */
static FILE *dump_file = NULL;	/* file to dump the moment equations to */
static int dump_type = 0;	/* output format */
enum {SageMath, Mathematica, MATLAB, Bertini};
static const char *dump_formats[] =
	{"SageMath", "Mathematica", "MATLAB", "Bertini"};
#define NFORMATS ((int)sizeof(dump_formats) / (int)sizeof(dump_formats[0]))

/* the current orbits */
static int s2, s11, s3, s21, s111, s4, s31, s22, s211, s1111;
/* user specified orbits */
static int s2_user = -1, s11_user = -1;
static int s3_user = -1, s21_user = -1, s111_user = -1;
static int s4_user = -1, s31_user = -1, s22_user = -1, s211_user = -1,
	   s1111_user = -1;

static int degree, dim, npolys, npolys_max, neqns, nabsc, nwgts, ncons;
static int npoints = 0, nsols = 0;
static int *porders = NULL;

/*------------------------------------------------------------------------------
 * The following variables specifies the restricted orbits, i.e., orbits
 * with some zero abscissas, which represent points restricted to vertices,
 * edges, or faces. */
typedef struct CONSTRAINTS_ {
    /* constraints[] marks the constrained unknowns: if constraints != NULL and
     * constraints[i].value >= 0 then the i-th unknown is constrained to the
     * value constraints[i].value, otherwise it's unconstrained.
     *
     * constraints[i].expr stores the symbolic expression for the value,
     * if available. */
    FLOAT	value;		/* FLOAT value */
    char	*expr;		/* symbolic expression */
} CONSTRAINTS;

static CONSTRAINTS *constraints = NULL;

/*--------------------------------- dim == 1 ---------------------------------*/
static int r11	 = 0;	/* orbit (0,1)			-- vertex	      */
/*--------------------------------- dim == 2 ---------------------------------*/
static int r21	 = 0;	/* bit 0: (1,0,0)		-- vertex
			   bit 1: (1/2,1/2,0)		-- edge center	*/
static int r111	 = 0;	/* orbits (a,1-a,0)		-- edge			*/
/*--------------------------------- dim == 3 ---------------------------------*/
static int r31	 = 0;	/* bit 0: (1,0,0,0)		-- vertex
			   bit 1: (1/3,1/3,1/3,0)	-- face center	*/
static int r22	 = 0;	/* bit 0: (1/2,1/2,0,0)		-- edge center	*/
static int r211e = 0;	/* orbits (a,1-a,0,0)		-- edge		*/
static int r211f = 0;	/* orbits (a,a,1-2a,0)		-- face (s21)	*/
static int r1111 = 0;	/* orbits (a,b,1-a-b,0)		-- face (s111)	*/
/*----------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
 * The following variables are for handling predefined (aka fixed or
 * user-provided) orbits */

static int have_predefined_orbits = 0;

/* structure for storing predefined orbits */
typedef struct {
    char *star;		/* permutation star */
    int dim;		/* dimension */
    int nargs;		/* # arguments */
    int inv_arg0;	/* inversed value of the first argument if fixed */
    int cnt;		/* number of all predefined orbits of this type */
    struct ARGS {	/* arguments of all predefined orbits of this type */
	FLOAT	farg;	/* FLOAT value */
	char	*sarg;	/* optional symbolic expression */
    } *args;
} STAR_INFO;

/* Note: uxxx are the index in the stars[] array for the corresponding orbit */
enum {u2 = 0, u11 = 1, u3 = 2, u21 = 3, u111 = 4,
	u4 = 5, u31 = 6, u22 = 7, u211 = 8, u1111 = 9};

static STAR_INFO stars[] = {
    /* star	dim	nargs	inv_arg0	cnt	args */
    /* 1D */
    {"perm2",	1, 	1, 	2,		0,	NULL},
    {"perm11",	1,	1,	0,		0,	NULL},
    /* 2D */
    {"perm3",	2,	1,	3,		0,	NULL},
    {"perm21",	2,	1,	0,		0,	NULL},
    {"perm111",	2,	2,	0,		0,	NULL},
    /* 3D */
    {"perm4",	3,	1,	4,		0,	NULL},
    {"perm31",	3,	1,	0,		0,	NULL},
    {"perm22",	3,	1,	0,		0,	NULL},
    {"perm211",	3,	2,	0,		0,	NULL},
    {"perm1111",3,	3,	0,		0,	NULL}
};
static int nstars = sizeof(stars) / sizeof(stars[0]);

/* user-provided monomials */
static int monos_n = 0, monos_alloc = 0;
static char *monos = NULL;	/* dynamically allocated */

/*----------------------------------------------------------------------------*/

static POLY **pbasis = NULL;		/* basis polynomials */
static int dummy[] = {0,0,0,0};
static POLY one_ = {1.0, NULL, dummy, 0};
#define ONE	(&one_)

# include <setjmp.h>

#if ASYNCHRONOUS
# include <unistd.h>
typedef enum {REMOVE_SYNC_FILE, CREATE_SYNC_FILE, CHECK_SYNC_FILE} sync_mode_t;
static jmp_buf jmp;

#if USE_MPI
static char *sync_fn = NULL;
#endif	/* USE_MPI */

#define printf	myprintf

static FILE *f_out = NULL;	/* stdout file (non root process only) */

static void
clean_up(void)
{
#if USE_MPI
    if (sync_fn != NULL) {
	if (myrank == 0)
	    unlink(sync_fn);
	free(sync_fn);
	sync_fn = NULL;
    }
#endif	/* USE_MPI */

    if (myrank == 0 && dump_file != NULL && dump_file != stdout) {
	fclose(dump_file);
	dump_file = NULL;
    }

    if (f_out != NULL) {
	fclose(f_out);
	f_out = NULL;
    }
}

static int
sync_file(sync_mode_t mode)
{
#if USE_MPI
    static char *sync_fn = NULL;
    FILE *fp;

    if (nprocs <= 1)
	return 0;

    if (sync_fn == NULL) {
	if (mode == REMOVE_SYNC_FILE)
	    return 0;
	sync_fn = malloc(PATH_MAX + 1);
	if (myrank == 0) {
	    char pn[MPI_MAX_PROCESSOR_NAME + 1], *p;
	    int len;
	    MPI_Get_processor_name(pn, &len);
	    pn[len] = '\0';
	    if ((p = strchr(pn, '.')) != NULL)
		*p = '\0';
	    len = strlen(pn);
	    sprintf(sync_fn, "quad_%s_%d.sync", len <= 16 ? pn : pn + len - 16,
			getpid());
	    unlink(sync_fn);
	}
	MPI_Bcast(sync_fn, PATH_MAX + 1, MPI_BYTE, 0, MPI_COMM_WORLD);
    }

    switch (mode) {
	case REMOVE_SYNC_FILE:
	    unlink(sync_fn);
	    return 0;
	case CREATE_SYNC_FILE:
	    if ((fp = fopen(sync_fn, "r")) != NULL) {
		fclose(fp);
		return 0;
	    }
	    fp = fopen(sync_fn, "w+t");
	    fprintf(fp, "done.\n");
	    fclose(fp);
	    return 0;
	case CHECK_SYNC_FILE:
	    if ((fp = fopen(sync_fn, "r")) != NULL)
		fclose(fp);
	    return (fp != NULL);
	default:
	    fprintf(stderr, "sync_file: invalid mode %d!\n", mode);
	    unlink(sync_fn);
	    MPI_Abort(MPI_COMM_WORLD, 1);
	    exit(1);
    }
#endif	/* USE_MPI */

    return 0;
}
#endif	/* ASYNCHRONOUS */

/*--------------- redirect printf of non-root process to a file --------------*/

#include <stdarg.h>

static int
myprintf(const char *fmt, ...)
{
    va_list ap;
    int ret;

    if ((myrank == 0 && nprocs == 1) || stop_flag) {
	va_start(ap, fmt);
	ret = vprintf(fmt, ap);
	va_end(ap);
	fflush(stdout);

	return ret;
    }

    if (f_out == NULL) {
	char s[64];
	sprintf(s, "%d_%d_%d.%d", dim, degree, npoints, myrank);
	f_out = fopen(s, "w+t");
	if (f_out == NULL) {
	    fprintf(stderr, "Process %d can't create stdout file \"%s\".\n",
				myrank, s);
#if USE_MPI
	    MPI_Abort(MPI_COMM_WORLD, 1);
#endif	/* USE_MPI */
	    exit(1);
	}
    }

    va_start(ap, fmt);
    ret = vfprintf(f_out, fmt, ap);
    va_end(ap);
    fflush(f_out);

    return ret;
}

/*----------------------------------------------------------------------------*/

static inline FLOAT
Pow0(FLOAT x, int p)
{
    FLOAT d;

    assert(p >= 0);

    if (p == 0)
	return 1.;

    if (x == 0. || x == 1.)
	return x;

    if (x == -1.)
	return (p & 1) ? -1 : 1;

    while (!(p & 1)) {
	p >>= 1;
	x *= x;
    }
    d = x;
    while ((p >>= 1)) {
	x *= x;
	if (p & 1)
	    d *= x;
    }

    return d;
}

static inline FLOAT
Pow2(FLOAT x, int p, FLOAT y, int q)
{
    if (p == q) 
	return Pow0(x * y, p);
    else if (p > q)
	return (q == 0 ? 1. : Pow0(x * y, q)) * Pow0(x, p - q);
    else
	return (p == 0 ? 1. : Pow0(x * y, p)) * Pow0(y, q - p);
}

static inline FLOAT
Pow3(FLOAT x, int p, FLOAT y, int q, FLOAT z, int r)
{
    if (r <= p && r <= q)
	return (r == 0 ? 1. : Pow0(x * y * z, r)) * Pow2(x, p - r, y, q - r);
    else if (q <= p && q <= r)
	return (q == 0 ? 1. : Pow0(x * y * z, q)) * Pow2(x, p - q, z, r - q);
    else
	return (p == 0 ? 1. : Pow0(x * y * z, p)) * Pow2(y, q - p, z, r - p);
}

static inline FLOAT
Pow4(FLOAT x, int p, FLOAT y, int q, FLOAT z, int r, FLOAT u, int s)
{
    if (s <= p && s <= q && s <= r)
	return (s == 0 ? 1. : Pow0(x * y * z * u, s)) *
		Pow3(x, p - s, y, q - s, z, r - s);
    else if (r <= p && r <= q && r <= s)
	return (r == 0 ? 1. : Pow0(x * y * z * u, r)) *
		Pow3(x, p - r, y, q - r, u, s - r);
    else if (q <= p && q <= r && q <= s)
	return (q == 0 ? 1. : Pow0(x * y * z * u, q)) *
		Pow3(x, p - q, z, r - q, u, s - q);
    else {
	assert(p <= q && p <= r && p <= s);
	return (p == 0 ? 1. : Pow0(x * y * z * u, p)) *
		Pow3(y, q - p, z, r - p, u, s - p);
    }
}

static FLOAT
integral(int p, int q, int r, int s)
/* returns the integral:
 *	$\int_S x^p (1-x)^q if dim == 1, or
 *	$\int_S x^p y^q (1-x-y)^r$ if dim == 2, or
 * 	$\int_S x^p y^q z^r (1-x-y-z)^s$ if dim == 3,
 * where $S$ is the standard simplex.
 *
 * Note: the general formula for integrals over a $(d+1)$-simplex is
 * $$
 * 	\int_S \lambda^\alpha = \alpha! / (d + |\alpha|)!
 * $$
 * where $\lambda = (\lambda_0, \lambda_1, \ldots, \lambda_d)$,
 *	 $\alpha = (\alpha_0, \alpha_1, \ldots, \alpha_d)$,
 *	 $\alpha! = \alpha_0! \alpha_1! \cdots \alpha_d!$,
 * and:  $|\aplha| = \alpha_0 + \alpha_1 + \cdots + \alpha_d$ */
{
    FLOAT a;

#define EXCHG(p, q)	{int i = p; p = q; q = i;}

    if (dim == 1) {
	/* \int x^p (1-x)^q = p! q! / (1 + p + q)! */
	if (p < q) EXCHG(p, q);
	a = 1. / (p + q + 1);
	for (; q > 0; q--)
	    a *= q / (FLOAT)(p + q);
    }
    else if (dim == 2) {
	/* \int x^p y^q (1-x-y)^r = p! q! r! / (2 + p + q + r)! */
	if (p < q) EXCHG(p, q);
	if (p < r) EXCHG(p, r);
#if 0
	if (q < r) EXCHG(q, r);
#endif
	a = 1. / ((p + q + r + 1.) * (p + q + r + 2.)) ;
	for (; q > 0; q--)
	    a *= q / (FLOAT)(p + q + r);
	for (; r > 0; r--)
	    a *= r / (FLOAT)(p + r);
    }
    else {
	/* \int x^p y^q z^r (1-z-y-z)^s = p! q! r! s! / (3 + p + q + r + s)! */
	if (p < q) EXCHG(p, q);
	if (p < r) EXCHG(p, r);
	if (p < s) EXCHG(p, s);
#if 0
	if (q < r) EXCHG(q, r);
	if (q < s) EXCHG(q, s);
	if (r < s) EXCHG(r, s);
#endif
	a = 1. / ((p + q + r + s + 1.) *
		  (p + q + r + s + 2.) *
		  (p + q + r + s + 3.)) ;
	for (; q > 0; q--)
	    a *= q / (FLOAT)(p + q + r + s);
	for (; r > 0; r--)
	    a *= r / (FLOAT)(p + r + s);
	for (; s > 0; s--)
	    a *= s / (FLOAT)(p + s);
    }

    return a;
}

static void
poly_dump0(POLY *p, FILE *f,
	   const char *x, const char *y, const char *z, const char *u)
{
    char *s = NULL;

    if (x == NULL)
	x = "x";
    if (y == NULL)
	y = "y";
    if (z == NULL)
	z = "z";
    if (u == NULL) {
	if (dim == 1)
	    sprintf(s = malloc(strlen(x) + 5), "1-(%s)", x);
	else if (dim == 2)
	    sprintf(s = malloc(strlen(x) + strlen(y) + 8), "1-(%s)-(%s)", x, y);
	else
	    sprintf(s = malloc(strlen(x) + strlen(y) + strlen(z) + 11),
			"1-(%s)-(%s)-(%s)", x, y, z);
	u = s;
    }

    if (p->coeff != NULL) {
	int i, j = -1, *o;
	o = p->o;
	for (i = 0; i <= p->n; i++, o += dim + 1) {
	    if (Fabs(p->coeff[i]) < EPS)
		continue;
	    fprintf(f, "%s%0.20lg", j == -1 ? "" : "+", (double)p->coeff[i]);
	    j = 0;
	    if ((dim == 1 && o[0] + o[1] == 0) ||
		(dim == 2 && o[0] + o[1] + o[2] == 0) ||
		(dim == 3 && o[0] + o[1] + o[2] + o[3] == 0))
		continue;
	    if (o[0] > 0)
		(o[0] == 1 ? fprintf(f, "*(%s)", x) :
			     fprintf(f, "*(%s)^%d", x, o[0]));
	    if (o[1] > 0) {
		const char *v = (dim == 1 ? u : y);
		(o[1] == 1 ? fprintf(f, "*(%s)", v) :
			     fprintf(f, "*(%s)^%d", v, o[1]));
	    }
	    if (dim > 1 && o[2] > 0) {
		const char *v = (dim == 2 ? u : z);
		(o[2] == 1 ? fprintf(f, "*(%s)", v) :
			     fprintf(f, "*(%s)^%d", v, o[2]));
	    }
	    if (dim == 3 && o[3] > 0)
		(o[3] == 1 ? fprintf(f, "*(%s)", u) :
			     fprintf(f, "*(%s)^%d", u, o[3]));
	}
    }
    else {
	int *o = p->o + (dim + 1) * p->n;
	fprintf(f, "%0.20lg",  (double)p->coeff0);
	if (o[0] > 0)
	    (o[0] == 1 ? fprintf(f, "*(%s)", x) :
			 fprintf(f, "*(%s)^%d", x, o[0]));
	if (o[1] > 0) {
	    const char *v = (dim == 1 ? u : y);
	    (o[1] == 1 ? fprintf(f, "*(%s)", v) :
			 fprintf(f, "*(%s)^%d", v, o[1]));
	}
	if (dim > 1 && o[2] > 0) {
	    const char *v = (dim == 2 ? u : z);
	    (o[2] == 1 ? fprintf(f, "*(%s)", v) :
			 fprintf(f, "*(%s)^%d", v, o[2]));
	}
	if (dim == 3 && o[3] > 0)
	    (o[3] == 1 ? fprintf(f, "*(%s)", u) :
			 fprintf(f, "*(%s)^%d", u, o[3]));
    }

    if (s != NULL)
	free(s);
}

#define poly_dump(p, f)	poly_dump0(p, f, NULL, NULL, NULL, NULL)

static FLOAT
poly_eval(POLY *p, FLOAT x, FLOAT y, FLOAT z)
{
    FLOAT va;
    int i;

    if (p->coeff != NULL) {
	/* TODO: number of operations could be largely reduced */
	va = 0.;
	if (dim == 1) {
	    for (i = 0; i <= p->n; i++) {
		if (Fabs(p->coeff[i]) < EPS)
		    continue;
		va += p->coeff[i] * Pow2(x,		p->o[2 * i],
					 1. - x,	p->o[2 * i + 1]);
	    }
	}
	else if (dim == 2) {
	    for (i = 0; i <= p->n; i++) {
		if (Fabs(p->coeff[i]) < EPS)
		    continue;
		va += p->coeff[i] * Pow3(x,		p->o[3 * i],
					 y,		p->o[3 * i + 1],
					 1. - x - y,	p->o[3 * i + 2]);
	    }
	}
	else {
	    for (i = 0; i <= p->n; i++) {
		if (Fabs(p->coeff[i]) < EPS)
		    continue;
		va += p->coeff[i] * Pow4(x, 		p->o[4 * i],
					 y, 		p->o[4 * i + 1],
					 z, 		p->o[4 * i + 2],
					 1. - x - y - z,p->o[4 * i + 3]);
	    }
	}
    }
    else {
	if (dim == 1) {
	    va = p->coeff0 * Pow2(x,			p->o[2 * p->n],
				  1. - x,		p->o[2 * p->n + 1]);
	}
	else if (dim == 2) {
	    va = p->coeff0 * Pow3(x,			p->o[3 * p->n],
				  y,			p->o[3 * p->n + 1],
				  1. - x - y,		p->o[3 * p->n + 2]);
	}
	else {
	    va = p->coeff0 * Pow4(x,			p->o[4 * p->n],
				  y,			p->o[4 * p->n + 1],
				  z,			p->o[4 * p->n + 2],
				  1. - x - y - z,	p->o[4 * p->n + 3]);
	}
    }

    return va;
}

static FLOAT
poly_eval_d(POLY *p, int which, FLOAT x, FLOAT y, FLOAT z)
/* evaluates derivative of 'p' with respect to 'which' (of x, y or z) */
{
    FLOAT va, v0;
    int i;
    int a = 0, b = 0, c = 0;

    switch (which) {
	case 0: a = 1; break;
	case 1: b = 1; break;
	case 2: c = 1; break;
    }

    if (p->coeff != NULL) {
	/* TODO: number of operations could be largely reduced */
	va = 0.;
	if (dim == 1) {
	    for (i = 0; i <= p->n; i++) {
		if (Fabs(p->coeff[i]) < EPS ||
		    (p->o[2 * i + which] == 0 && p->o[2 * i + 1] == 0))
		    continue;
 		if (p->o[2 * i + which] != 0)
		    v0 = p->o[2 * i + which] *
				Pow2(x,		p->o[2 * i + 0] - a,
				     1. - x,	p->o[2 * i + 1]);
		else
		    v0 = 0.;
 		if (p->o[2 * i + 1] != 0)
		    v0 -= p->o[2 * i + 1] *
				Pow2(x,		p->o[2 * i + 0],
				     1.- x,	p->o[2 * i + 1] - 1);
		va += v0 * p->coeff[i];
	    }
	}
	else if (dim == 2) {
	    for (i = 0; i <= p->n; i++) {
		if (Fabs(p->coeff[i]) < EPS ||
		    (p->o[3 * i + which] == 0 && p->o[3 * i + 2] == 0))
		    continue;
 		if (p->o[3 * i + which] != 0)
		    v0 = p->o[3 * i + which] *
				Pow3(x,		p->o[3 * i + 0] - a,
				     y,		p->o[3 * i + 1] - b,
				     1.- x- y,	p->o[3 * i + 2]);
		else
		    v0 = 0.;
 		if (p->o[3 * i + 2] != 0)
		    v0 -= p->o[3 * i + 2] *
				Pow3(x,		p->o[3 * i + 0],
				     y,		p->o[3 * i + 1],
				     1.- x- y,	p->o[3 * i + 2] - 1);
		va += v0 * p->coeff[i];
	    }
	}
	else {
	    for (i = 0; i <= p->n; i++) {
		if (Fabs(p->coeff[i]) < EPS ||
		    (p->o[4 * i + which] == 0 && p->o[4 * i + 3] == 0))
		    continue;
 		if (p->o[4 * i + which] != 0)
		    v0 = p->o[4 * i + which] *
				Pow4(x,			p->o[4 * i + 0] - a,
				     y,			p->o[4 * i + 1] - b,
				     z,			p->o[4 * i + 2] - c,
				     1. - x - y - z,	p->o[4 * i + 3]);
		else
		    v0 = 0.;
 		if (p->o[4 * i + 3] != 0)
		    v0 -= p->o[4 * i + 3] *
				Pow4(x,			p->o[4 * i + 0],
				     y,			p->o[4 * i + 1],
				     z,			p->o[4 * i + 2],
				     1. - x - y - z,	p->o[4 * i + 3] - 1);
		va += v0 * p->coeff[i];
	    }
	}
	return va;
    }
    else {
	if (dim == 1) {
	    if (Fabs(p->coeff0) < EPS ||
		(p->o[2 * p->n + which] == 0 && p->o[2 * p->n + 1] == 0))
		return 0.;
 	    if (p->o[2 * p->n + which] != 0)
		v0 = p->o[2 * p->n + which] *
			Pow2(x,		p->o[2 * p->n + 0] - a,
			     1. - x,	p->o[2 * p->n + 1]);
	    else
		v0 = 0.;
 	    if (p->o[2 * p->n + 1] != 0)
		v0 -= p->o[2 * p->n + 1] *
			Pow2(x,		p->o[2 * p->n + 0],
			     1. - x,	p->o[2 * p->n + 1] - 1);
	    return v0 * p->coeff0;
	}
	else if (dim == 2) {
	    if (Fabs(p->coeff0) < EPS ||
		(p->o[3 * p->n + which] == 0 && p->o[3 * p->n + 2] == 0))
		return 0.;
 	    if (p->o[3 * p->n + which] != 0)
		v0 = p->o[3 * p->n + which] *
			Pow3(x,		 p->o[3 * p->n + 0] - a,
			     y,		 p->o[3 * p->n + 1] - b,
			     1. - x - y, p->o[3 * p->n + 2]);
	    else
		v0 = 0.;
 	    if (p->o[3 * p->n + 2] != 0)
		v0 -= p->o[3 * p->n + 2] *
			Pow3(x,		 p->o[3 * p->n + 0],
			     y,		 p->o[3 * p->n + 1],
			     1. - x - y, p->o[3 * p->n + 2] - 1);
	    return v0 * p->coeff0;
	}
	else {
	    if (Fabs(p->coeff0) < EPS ||
		(p->o[4 * p->n + which] == 0 && p->o[4 * p->n + 3] == 0))
		return 0.;
 	    if (p->o[4 * p->n + which] != 0)
		v0 = p->o[4 * p->n + which] *
			Pow4(x,		     p->o[4 * p->n + 0] - a,
			     y,		     p->o[4 * p->n + 1] - b,
			     z,		     p->o[4 * p->n + 2] - c,
			     1. - x - y - z, p->o[4 * p->n + 3]);
	    else
		v0 = 0.;
 	    if (p->o[4 * p->n + 3] != 0)
		v0 -= p->o[4 * p->n + 3] *
			Pow4(x,		     p->o[4 * p->n + 0],
			     y,		     p->o[4 * p->n + 1],
			     z,		     p->o[4 * p->n + 2],
			     1. - x - y - z, p->o[4 * p->n + 3] - 1);
	    return v0 * p->coeff0;
	}
    }
}

static void
poly_scalar(POLY *p, FLOAT s)
{
    int i;

    if (p->coeff != NULL) {
	for (i = 0; i <= p->n; i++)
	    p->coeff[i] *= s;
    }
    else {
	p->coeff0 *= s;
    }
}

static void
poly_axpy(POLY *p, POLY *q, FLOAT s)
{
    int i;

    (void)poly_axpy;	/* to avoid 'unused ...' warning */

    assert(p->n >= q->n && p->o == q->o);

    if (p->coeff == NULL) {
	if ((i = p->n) == q->n) {
	    p->coeff0 += s * (q->coeff == NULL ? q->coeff0 : q->coeff[i]);
	    return;
	}
	p->coeff = calloc(i + 1, sizeof(*p->coeff));
	p->coeff[i] = p->coeff0;
    }

    if (q->coeff != NULL) {
	for (i = 0; i <= q->n; i++)
	    p->coeff[i] += s * q->coeff[i];
    }
    else {
	p->coeff[q->n] += s * q->coeff0;
    }
}

static POLY *
poly_new(int n, FLOAT a, int *orders)
/* generates a polynomial and initializes it to the 'n'-th monomial in the
 * list of monomials pointed by 'orders'. */
{
    POLY *p = malloc(sizeof(POLY));

    p->n = n;
    p->coeff = NULL;
    p->o = orders;
    p->coeff0 = a;

    return p;
}

static POLY *
poly_dup(POLY *poly)
{
    POLY *p = malloc(sizeof(POLY));

    (void)poly_dup;

    memcpy(p, poly, sizeof(*p));
    if (p->coeff != NULL) {
	free(p->coeff);
	p->coeff = malloc((p->n + 1) * sizeof(*p->coeff));
	memcpy(p->coeff, poly->coeff, (p->n + 1) * sizeof(*p->coeff));
    }

    return p;
}

static void
poly_free(POLY *p)
{
    if (p->coeff != NULL)
	free(p->coeff);
    free(p);
}

static FLOAT
poly_dot(POLY *p, POLY *q)
{
    FLOAT res;
    int i, j, i0, j0, n, m, k = 0, l = 0;
    FLOAT d, a, b;

    assert(q->n == 0 || q->o == p->o);

    i0 = (p->coeff == NULL ? p->n : 0);
    j0 = (q->coeff == NULL ? q->n : 0);

    res = 0.;
    for (i = i0; i <= p->n; i++) {
	if (Fabs(a = (p->coeff == NULL ? p->coeff0 : p->coeff[i])) < EPS)
	    continue;
	n = p->o[(dim + 1) * i + 0];
	m = p->o[(dim + 1) * i + 1];
	if (dim > 1)
	    k = p->o[(dim + 1) * i + 2];
	if (dim == 3)
	   l = p->o[(dim + 1) * i + 3];
	d = 0.;
	for (j = j0; j <= q->n; j++) {
	    if (Fabs(b = (q->coeff == NULL ? q->coeff0 : q->coeff[j])) < EPS)
		continue;
	    d += integral(n + q->o[(dim + 1) * j + 0],
			  m + q->o[(dim + 1) * j + 1],
			  dim < 2 ? 0 : k + q->o[(dim + 1) * j + 2],
			  dim < 3 ? 0 : l + q->o[(dim + 1) * j + 3]) * b;
	}
	res += d * a;
    }

    return res;
}

static int
abscissas_1D(const FLOAT D[], FLOAT x[][dim], int wmap[])
/* computes the x[] array (and wmap[]) for a given set of free abscissas */
{
#if SYMMETRY
    FLOAT a, b;
    int i, j, k, l;

    j = k = l = 0;
    if (s2 == 1) {
	x[j][0] = 0.5;
	wmap[j++] = l++;
    }
    for (i = 0; i < s11; i++) {
	a = D[k++];
	b = 1. - a;
	x[j][0] = a;
	wmap[j++] = l;
	x[j][0] = b;
	wmap[j++] = l++;
    }
#else	/* SYMMETRY */
    int k, j;

    k = 0;
    for (j = 0; j < nwgts; j++) {
	x[j][0] = D[k++];
	wmap[j] = j;
    }
#endif	/* SYMMETRY */

    return 0;
}

static int
abscissas_2D(const FLOAT D[], FLOAT x[][dim], int wmap[])
/* computes the x[][2] array (and wmap[]) for a given set of free abscissas */
{
#if SYMMETRY
    FLOAT a, c, b;
    int i, j, k, l;

    j = k = l = 0;
    if (s3 == 1) {
	x[j][0] = x[j][1] = 1. / (dim + _F(1.));
	wmap[j++] = l++;
    }
    for (i = 0; i < s21; i++) {
	a = D[k++];
	b = 1. - a - a;
	x[j][0] = a; x[j][1] = a;
	wmap[j++] = l;
	x[j][0] = a; x[j][1] = b;
	wmap[j++] = l;
	x[j][0] = b; x[j][1] = a;
	wmap[j++] = l++;
    }
    for (i = 0; i < s111; i++) {
	a = D[k++];
	b = D[k++];
	c = 1. - a - b;
	x[j][0] = a; x[j][1] = b;
	wmap[j++] = l;
	x[j][0] = b; x[j][1] = a;
	wmap[j++] = l;
	x[j][0] = a; x[j][1] = c;
	wmap[j++] = l;
	x[j][0] = c; x[j][1] = a;
	wmap[j++] = l;
	x[j][0] = b; x[j][1] = c;
	wmap[j++] = l;
	x[j][0] = c; x[j][1] = b;
	wmap[j++] = l++;
    }
#else	/* SYMMETRY */
    int k, j;

    k = 0;
    for (j = 0; j < nwgts; j++) {
	x[j][0] = D[k++];
	x[j][1] = D[k++];
	wmap[j] = j;
    }
#endif	/* SYMMETRY */

    return 0;
}

static int
abscissas_3D(const FLOAT D[], FLOAT x[][dim], int wmap[])
/* computes the abscissas x[][3] (and wmap[]) for given set of free abscissas */
{
#if SYMMETRY
    FLOAT a, b, c, d;
    int i, j, k, l;

#define Perm21(a,b)				\
	x[j][0] = a; x[j][1] = a; x[j][2] = b;	\
        wmap[j++] = l;				\
        x[j][0] = a; x[j][1] = b; x[j][2] = a;	\
        wmap[j++] = l;				\
        x[j][0] = b; x[j][1] = a; x[j][2] = a;	\
        wmap[j++] = l;

#define Perm111(a,b,c)				\
	x[j][0] = a; x[j][1] = b; x[j][2] = c;	\
	wmap[j++] = l;				\
	x[j][0] = a; x[j][1] = c; x[j][2] = b;	\
	wmap[j++] = l;				\
	x[j][0] = b; x[j][1] = c; x[j][2] = a;	\
	wmap[j++] = l;				\
	x[j][0] = b; x[j][1] = a; x[j][2] = c;	\
	wmap[j++] = l;				\
	x[j][0] = c; x[j][1] = a; x[j][2] = b;	\
	wmap[j++] = l;				\
	x[j][0] = c; x[j][1] = b; x[j][2] = a;	\
	wmap[j++] = l;

    j = k = l = 0;
    if (s4 == 1) {
	x[j][0] = x[j][1] = x[j][2] = 1. / (dim + _F(1.));
	wmap[j++] = l++;
    }
    for (i = 0; i < s31; i++) {
	a = D[k++];
	b = 1. - a - a - a;
	x[j][0] = a; x[j][1] = a; x[j][2] = a;
	wmap[j++] = l;
	Perm21(a, b)
	l++;
    }
    for (i = 0; i < s22; i++) {
	a = D[k++];
	b = .5 - a;
	Perm21(a,b)
	Perm21(b,a)
	l++;
    }
    for (i = 0; i < s211; i++) {
	a = D[k++];
	b = D[k++];
	c = 1. - b - a - a;
	Perm21(a,b)
	Perm21(a,c)
	Perm111(a,b,c)
	l++;
    }
    for (i = 0; i < s1111; i++) {
	a = D[k++];
	b = D[k++];
	c = D[k++];
	d = 1. - a - b - c;
	Perm111(a,b,c)
	Perm111(a,b,d)
	Perm111(a,c,d)
	Perm111(b,c,d)
	l++;
    }
#undef Perm21
#undef Perm111
#else	/* SYMMETRY */
    int k, j;

    k = 0;
    for (j = 0; j < nwgts; j++) {
	x[j][0] = D[k++];
	x[j][1] = D[k++];
	x[j][2] = D[k++];
	wmap[j] = j;
    }
#endif	/* SYMMETRY */

    return 0;
}

int
comp_int(const void *p0, const void *p1)
/* compares two 'int's (IN REVERSE ORDER) */
{
    return *((int *)p1) - *((int *)p0);
}

static int
monos_comp(const void *p, const void *q)
{
    int i, j;

    for (i = 0; i <= dim; i++)
	if ((j = ((const int *)p)[i] - ((const int *)q)[i]) != 0)
	    return j;
    return 0;
}

static int
monos_expand(const int m[], int **expanded)
/* returns size of the symmetry orbit for m[dim+1] (sorted, decreasing orders),
 * and optionally the expanded list of monomials in *expanded */
{
    static int buffer[24 * 4];
    int i, j, k, n, star, counts[dim + 1], values[dim + 1];

    n = 0;
    for (i = 0; i <= dim; i++) {
	if (i > 0 && m[i] == m[i - 1]) {
	    counts[n - 1]++;
	    continue;
	}
	counts[n] = 1;
	values[n] = m[i];
	n++;
    }
    /* sort (counts[] descending, values[] ascending) */
    star = 0;
    for (i = 0; i < n; i++) {
	for (j = i + 1; j < n; j++) {
	    if (counts[i] > counts[j] ||
		(counts[i] == counts[j] && values[i] <= values[j]))
		continue;
	    k = counts[i];
	    counts[i] = counts[j];
	    counts[j] = k;
	    k = values[i];
	    values[i] = values[j];
	    values[j] = k;
	}
	star = 10 * star + counts[i];
    }
#if 0
printf("m = [%d", m[0]);
for (i = 1; i <= dim; i++) printf(",%d", m[i]);
printf("], star = %d, values =", star);
for (i = 0; i < n; i++) printf(" %d", values[i]);
printf("\n");
#endif

#define MONO1(a,b) \
    if (expanded != NULL) { \
	buffer[2 * n + 0] = a; \
	buffer[2 * n + 1] = b; \
    } \
    n++

#define MONO2(a,b,c) \
    if (expanded != NULL) { \
	buffer[3 * n + 0] = a; \
	buffer[3 * n + 1] = b; \
	buffer[3 * n + 2] = c; \
    } \
    n++

#define MONO3(a,b,c,d) \
    if (expanded != NULL) { \
	buffer[4 * n + 0] = a; \
	buffer[4 * n + 1] = b; \
	buffer[4 * n + 2] = c; \
	buffer[4 * n + 3] = d; \
    } \
    n++
#define MONO321(d,a,b) \
    MONO3(d,a,a,b); \
    MONO3(d,a,b,a); \
    MONO3(d,b,a,a)
#define MONO3111(d,a,b,c) \
    MONO3(d,a,b,c); \
    MONO3(d,a,c,b); \
    MONO3(d,b,c,a); \
    MONO3(d,b,a,c); \
    MONO3(d,c,a,b); \
    MONO3(d,c,b,a)

    n = 0;
    switch (star) {
	/* 1D stars */
	case 2:
	    MONO1(values[0], values[0]);
	    break;
	case 11:
	    MONO1(values[0], values[1]);
	    MONO1(values[1], values[0]);
	    break;
	/* 2D stars */
	case 3:
	    MONO2(values[0], values[0], values[0]);
	    break;
	case 21:
	    MONO2(values[0], values[0], values[1]);
	    MONO2(values[0], values[1], values[0]);
	    MONO2(values[1], values[0], values[0]);
	    break;
	case 111:
	    MONO2(values[0], values[1], values[2]);
	    MONO2(values[0], values[2], values[1]);
	    MONO2(values[1], values[2], values[0]);
	    MONO2(values[1], values[0], values[2]);
	    MONO2(values[2], values[0], values[1]);
	    MONO2(values[2], values[1], values[0]);
	    break;
	/* 3D stars */
	case 4:
	    MONO3(values[0], values[0], values[0], values[0]);
	    break;
	case 31:
	    MONO3(values[0], values[0], values[0], values[1]);
	    MONO3(values[0], values[0], values[1], values[0]);
	    MONO3(values[0], values[1], values[0], values[0]);
	    MONO3(values[1], values[0], values[0], values[0]);
	    break;
	case 22:
	    MONO3(values[0], values[0], values[1], values[1]);
	    MONO3(values[0], values[1], values[0], values[1]);
	    MONO3(values[0], values[1], values[1], values[0]);
	    MONO3(values[1], values[1], values[0], values[0]);
	    MONO3(values[1], values[0], values[1], values[0]);
	    MONO3(values[1], values[0], values[0], values[1]);
	    break;
	case 211:
	    MONO3111(values[0], values[0], values[1], values[2]);
	    MONO321 (values[1], values[0], values[2]);
	    MONO321 (values[2], values[0], values[1]);
	    break;
	case 1111:
	    MONO3111(values[0], values[1], values[2], values[3]);
	    MONO3111(values[1], values[0], values[2], values[3]);
	    MONO3111(values[2], values[1], values[0], values[3]);
	    MONO3111(values[3], values[1], values[2], values[0]);
	    break;
    }

    if (expanded != NULL)
	*expanded = buffer;
    return n;
}

static int
monos_rank(int npolys, const int *porders, int *N)
/* returns rank of the set of monomials given by porders[] with symmetry orbits
 * expanded, and optionally the number of expanded monomials in *N */
{
    int i, j, k, rank, n, n_work = 0, *work = NULL, *orbit;
    FLOAT *A, a, d;

    /* construct expanded monomials in work[] */
    n = 0;
    for (i = 0; i < npolys; i++) {
	j = monos_expand(porders + i * (dim + 1), &orbit);
	if (n + j > n_work)
	    work = realloc(work, (n_work += 96) * (dim + 3) * sizeof(int));
	for (k = 0; k < j; k++, orbit += dim + 1) {
	    memcpy(work  + n * (dim + 3), orbit, (dim + 1) * sizeof(int));
	    work[(n++) * (dim + 3) + dim + 1] = i;
	}
    }

    if (N != NULL)
	*N = n;

    /* compute the mass-matrix */
    A = malloc(n * n * sizeof(*A));
    for (i = 0; i < n; i++)
	for (j = i; j < n; j++) {
	    A[i * n + j] = A[j * n + i] =
		integral(work[i * (dim + 3) + 0] + work[j * (dim + 3) + 0],
			 work[i * (dim + 3) + 1] + work[j * (dim + 3) + 1],
			 work[i * (dim + 3) + 2] + work[j * (dim + 3) + 2],
			 work[i * (dim + 3) + 3] + work[j * (dim + 3) + 3]);
	}

    /* normalize A */
    for (i = 0; i < n; i++) {
        d = 1.0 / Sqrt(A[i * n + i]);
        for (j = 0; j < n; j++)
            A[i * n + j] = (A[j * n + i] *= d);
        A[i * n + i] = 1.0;
    }

    /* compute rank of A */
    rank = n;
    for (i = 0; i < n; i++) {
	d = Fabs(A[i * n + i]);
	k = i;
	for (j = i + 1; j < n; j++)
	    if ((a = Fabs(A[j * n + i])) > d) {
		d = a;
		k = j;
	    }
	if (k != i) {
	    for (j = i; j < n; j++) {
		a = A[i * n + j];
		A[i * n + j] = A[k * n + j];
		A[k * n + j] = a;
	    }
	}
	if (d < 1e-10) {
	    rank--;
	    continue;
	}
	for (k = i + 1; k < n; k++) {
	    d = A[k * n + i] / A[i * n + i];
	    A[k * n + i] = 0.0;
	    for (j = i; j < n; j++)
		A[k * n + j] -= d * A[i * n + j];
	}
    }

    if (A != NULL)
	free(A);

    if (work != NULL)
	free(work);

    return rank;
}

static void
poly_gen(void)
/* generates bases pbasis[] for polynomials of degrees <='degree' */
{
    POLY *p;
    int *o;
    int i, j, k, n, m, l;
    FLOAT a;

    o = porders = calloc(npolys_max, (dim + 1) * sizeof(*porders));

    /* generate list of monomials (orders) for the polynomial space */

#if SYMMETRY
    npolys = 0;
    /* Symmetric case: generate only one basis for each symmetry group.
     * 
     * Note:
     *	The bases are the monomials of the form \lambda^\alpha where
     *		\lambda=(\lambda_0,\lambda_1,\ldots,\lambda_d)
     *	is the barycentric coordinates (d = space dimention), and
     *		\alpha=(\alpha_0,\alpha_1,\ldots,\alpha_d)
     *	which satisfies
     *		\alpha_0 \ge \alpha_1 \ge \ldots \ge \alpha_d
     *		\sum_{i=0}^d \alpha_i = degree
     *
     * Note: for the 2d case, the formulae for the number of bases is:
     *		degree^2/12+degree/2+47/72+(-1)^degree/8+2/9*cos(2*degree*PI/3)
     *	(Cohen et al., Higher Order Triangular Finite Elements with Mass Lumping
     *	for the Wave Equation, SINUM 38(6) 2001, pp. 2047-2078)
     */
    if (monos_n == 0 && dim == 1) {
	for (i = 0; i <= degree / 2; i++) {
	    *(o++) = i;
	    *(o++) = degree - i;
	    npolys++;
	}
    }
    else if (monos_n == 0 && dim == 2) {
	for (i = 0; i <= degree; i++) {
	    j = (degree - i + 1) / 2;
	    for (; j <= i && (k = degree - i -j) >= 0; j++) {
		/*fprintf(stderr, "\t%d %d %d\n", i, j, k);*/
		assert(i>=j && j>=k && k>=0 && i+j+k==degree);
		*(o++) = i;
		*(o++) = j;
		*(o++) = k;
		npolys++;
	    }
	}
    }
    else if (monos_n == 0) {
	for (i = 0; i <= degree; i++) {
	    j = (degree - i > i ? i : degree - i);
	    for (j = 0; j <= i && degree - i - j >= 0; j++) {
		k = (degree - i - j + 1) / 2;
		for (; k <= j && (n = degree - i - j - k) >= 0; k++) {
		    /*fprintf(stderr, "\t%d %d %d %d\n", i, j, k, n);*/
		    assert(i>=j && j>=k && k>=n && n>=0 && i+j+k+n==degree);
		    *(o++) = i;
		    *(o++) = j;
		    *(o++) = k;
		    *(o++) = n;
		    npolys++;
		}
	    }
	}
    }
    /* the other bases are also appended below, they may be used as fill-in
     * equations for some solvers when # DOF > npolys */
#else	/* SYMMETRY */
    npolys = npolys_max;
#endif	/* SYMMETRY */

    if (dim == 1) {
	int p[2];
	char (*pm)[2] = (void *)monos;
	for (i = degree; i >= 0; i--) {
	    j = degree - i;
#if SYMMETRY
	    if (monos_n == 0 && i >= j)
		continue;
#endif	/* SYMMETRY */
	    if (monos_n == 0) {
		*(o++) = i;
		*(o++) = j;
		continue;
	    }
	    /* compute (i,j) + \{ monos[] \} */
	    for (l = 0; l < monos_n; l++) {
		p[0] = i + pm[l][0];
		p[1] = j + pm[l][1];
		qsort(p, 2, sizeof(p[0]), comp_int);
		/* check duplicate entries */
		for (m = 0; m < npolys; m++)
		    if (!memcmp(p, porders + m * 2, sizeof(p)))
			break;
		if (m < npolys)
		    continue;
		memcpy(o, p, sizeof(p));
		o += 2;
		npolys++;
	    }
	}
    }
    else if (dim == 2) {
	int p[3];
	char (*pm)[3] = (void *)monos;
	for (i = degree; i >= 0; i--) {
	    for (j = degree - i; j >= 0; j--) {
		k = degree - i - j;
#if SYMMETRY
		if (monos_n == 0 && i >= j && j >= k)
		    continue;
#endif	/* SYMMETRY */
		if (monos_n == 0) {
		    *(o++) = i;
		    *(o++) = j;
		    *(o++) = k;
		    continue;
		}
		/* compute (i,j,k) + \{ monos[] \} */
		for (l = 0; l < monos_n; l++) {
		    p[0] = i + pm[l][0];
		    p[1] = j + pm[l][1];
		    p[2] = k + pm[l][2];
		    qsort(p, 3, sizeof(p[0]), comp_int);
		    /* check duplicate entries */
		    for (m = 0; m < npolys; m++)
			if (!memcmp(p, porders + m * 3, sizeof(p)))
			    break;
		    if (m < npolys)
			continue;
		    memcpy(o, p, sizeof(p));
		    o += 3;
		    npolys++;
		}
	    }
	}
    }
    else {
	int p[4];
	char (*pm)[4] = (void *)monos;
	for (i = degree; i >= 0; i--) {
	    for (j = degree - i; j >= 0; j--) {
		for (k = degree - i - j; k >= 0; k--) {
		    n = degree - i - j - k;
#if SYMMETRY
		    if (monos_n == 0 && i >= j && j >= k && k >= n)
			continue;
#endif	/* SYMMETRY */
		    if (monos_n == 0) {
			*(o++) = i;
			*(o++) = j;
			*(o++) = k;
			*(o++) = n;
			continue;
		    }
		    /* compute (i,j,k,n) + \{ monos[] \} */
		    for (l = 0; l < monos_n; l++) {
			p[0] = i + pm[l][0];
			p[1] = j + pm[l][1];
			p[2] = k + pm[l][2];
			p[3] = n + pm[l][3];
			qsort(p, 4, sizeof(p[0]), comp_int);
			/* check duplicate entries */
			for (m = 0; m < npolys; m++)
			    if (!memcmp(p, porders + m * 4, sizeof(p)))
				break;
			if (m < npolys)
			    continue;
			memcpy(o, p, sizeof(p));
			o += 4;
			npolys++;
		    }
		}
	    }
	}
    }

    assert(monos_n != 0 || npolys_max == (o - porders) / (dim + 1));

    if (0 && monos_n != 0) {	/* optional */
	/* remove linearly dependent orbits from porders[]
	 * FIXME: wrong result for the following test case:
	 * 	quadrule 3 1 32 0 2:1 0 2:1:1 0 <<END
			mono31(0,3)
			mono211(0,1,2)
			mono211(1,0,2)
			mono31(1,2)
END
	 * (test space reduced from 9=>6 instead of 9=>7)
	 */
	int *work = NULL, N, M;
	qsort(porders, npolys, sizeof(int) * (dim + 1), monos_comp);
	n = monos_rank(npolys, porders, &N);
	if (n < N) {
	    printf("Removing linearly dependent test functions: %d", npolys);
	    i = 0;
	    while (i < npolys) {
		int *o = porders + i * (dim + 1);
		if (monos_expand(o, NULL) > N - n) {
		    i++;
		    continue;
		}
		if (work == NULL)
		    work = malloc((dim + 1) * npolys * sizeof(*work));
		if (i > 0)
		    memcpy(work, porders, i * (dim + 1) * sizeof(*work));
		if (i < npolys - 1)
		    memcpy(work + i * (dim + 1), porders + (i + 1) * (dim + 1),
				(npolys - i - 1) * (dim + 1) * sizeof(*work));
		m = monos_rank(npolys - 1, work, &M);
		if (m < n) {
		    i++;
		    continue;
		}
		o = porders;
		porders = work;
		work = o;
		N = M;
		npolys--;
	    }
	    printf(" => %d (rank(A)/dim(A): %d/%d)\n", npolys, n, N);
	}
	if (work != NULL)
	    free(work);
    }

    /* Now generate the bases and optionally make them orthonormal by a
     * Gram-Schmidt procedure (TODO) */

    pbasis = malloc(npolys_max * sizeof(*pbasis));
    p = pbasis[0] = poly_new(0, (FLOAT)1.0, porders);
    a = 1.0 / poly_dot(p, ONE);
    if (p->coeff == NULL && a < ULLONG_MAX)
	/* a is an integer coefficient if monomial */
	a = (FLOAT)((unsigned long long)(a + 0.5));
    poly_scalar(p, a);
    for (i = 1; i < npolys_max; i++) {
	p = pbasis[i] = poly_new(i, (FLOAT)1.0, porders);
	/* normalize the integral to 1 */
	a = 1.0 / poly_dot(p, ONE);
	if (p->coeff == NULL && a < ULLONG_MAX)
	    /* a is an integer coefficient if monomial */
	    a = (FLOAT)((unsigned long long)(a + 0.5));
	poly_scalar(p, a);
    }

    return;
}

#ifndef USE_EXTREMAL_MEASURE
# define USE_EXTREMAL_MEASURE	0
#endif

#ifndef USE_INTERVALS
# if (NONLINEAR_SOLVER == GSLSIMAN)
#  define USE_INTERVALS		0
# else
#  define USE_INTERVALS		1
# endif	/* (NONLINEAR_SOLVER == GSLSIMAN) */
#endif

#define EXTREMAL_TRUNC		1e8

#if USE_INTERVALS

/* den[] stores the cumulative density function D(a), where D(a) is the
 * integral of the extremal measure on the concentric:
 * 	- 2D: triangle of size 3a, 0 <= a <= 1/3
 * 	- 3D: tetrahedron of size 4a, 0 <= a <= 1/4 */
static int den_n;
static FLOAT *den = NULL;

/*------------------------------ 1D density --------------------------*/

static void
density_1D(void)
/* Computes the cumulative density: den[j] = extremal_1D((1/2) * j / den_n) */
{
    int j;
    FLOAT a;

    if (den != NULL)
	return;
    den_n = 500;
    den = malloc((den_n + 1) * sizeof(*den));

    for (j = 0; j <= den_n; j++) {
	a = j / (_F(2.) * den_n);
	den[j] = Asin(a);	/* Note: \int 1/sqrt(x*(1-x)) = arcsin(x) */
    }
}

/*------------------------------ 2D density --------------------------*/

#define Perm3(a)        {a,a,a}
#define Dup3(w)         w
#define Perm21(a)       {a,a,1.-(a)-(a)}, {a,1.-(a)-(a),a}, {1.-(a)-(a),a,a}
#define Dup21(w)        w,w,w
#define Perm111(a,b)    {a,b,1.-(a)-(b)}, {a,1.-(a)-(b),b}, \
                        {b,a,1.-(a)-(b)}, {b,1.-(a)-(b),a}, \
                        {1.-(a)-(b),a,b}, {1.-(a)-(b),b,a}
#define Dup111(w)       w, w, w, w, w, w

/* 2D order 21 quadrature */
static FLOAT q_wts_2d[] = {
    Dup3(.02756225695287648096690704482451431),
    Dup21(.02206021541348850119135073403311636),
    Dup21(.02346001593867148849301344495230002),
    Dup21(.00032688959504719054621455750154654),
    Dup21(.00326531946293996823433530409586668),
    Dup21(.01175646291541279770430796921338205),
    Dup21(.01178076841991151684555757909867614),
    Dup111(.00226881081880114080533570433430431),
    Dup111(.00259601096443632006067378366548822),
    Dup111(.00463452978587186021234789056159687),
    Dup111(.00479433605454885793485744871991192),
    Dup111(.00571247883672361156725063834296336),
    Dup111(.00586582760432212163695579870000227),
    Dup111(.00941376305909158758981826852034708),
    Dup111(.01341494379665642491002202661089309),
    Dup111(.01571691809208324594350000113784617),
    Dup111(.01686368301443690459165096388619991),
    Dup111(.02139002708532009837783229808035898),
    Dup111(.02307679218949268136788087552189154)
};
static FLOAT q_pts_2d[][3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.20093527706508527987296185156416367),
    Perm21(.43765916596192717973183384418805413),
    Perm21(.00343395649059617685095991220960492),
    Perm21(.04664348477530675349517624043214192),
    Perm21(.38642225176307149094035202416772642),
    Perm21(.09543547110853091010857168104147605),
    Perm111(.95551380335045636050131472514677118,
	    .03571862787316335823804160897543867),
    Perm111(.88663881342886822612490057469143760,
	    .10814322491564621152738861104631270),
    Perm111(.78426284588043415429664399039819537,
	    .20746444959987645682438042951572740),
    Perm111(.88292395505020003271134898731688967,
	    .08568470872031694000000000000001000),
    Perm111(.66899196444107724049132248320989459,
	    .32149400301428881688168321268348603),
    Perm111(.55207212103556096415716096525277878,
	    .43794221879334138355236807696291701),
    Perm111(.79759296559656856762931422329572582,
	    .16191645306357785675100677020385905),
    Perm111(.67751471511977148463499116634413256,
	    .27450476740199490385900297290733317),
    Perm111(.54299741558909160533113611683919342,
	    .40533599807500692794989089537632556),
    Perm111(.70545990556996856165885634154060172,
	    .18773768065643534277281674394512005),
    Perm111(.57480057306650846221598245054985001,
	    .30569683476605516651279255664984316),
    Perm111(.47177880850461481660397704013492420,
	    .31214446687089088167080460581557645)
};

static FLOAT
area(FLOAT x0, FLOAT y0, FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2)
/* returns the area of the given triangle */
{
    x1 -= x0; y1 -= y0;
    x2 -= x0; y2 -= y0;

    return Fabs(x1 * y2 - x2 * y1) * 0.5;
}

static FLOAT
quad_2D0(FLOAT x0, FLOAT y0, FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2)
/* Computes integral of 1/sqrt(xy(1-x-y)) on a triangle using a 2D rule */
{
    int i;
    FLOAT q, x, y;

    q = 0.;
    for (i = 0; i < sizeof(q_wts_2d) / sizeof(*q_wts_2d); i++) {
	x = x0 * q_pts_2d[i][0] + x1 * q_pts_2d[i][1] + x2 * q_pts_2d[i][2];
	y = y0 * q_pts_2d[i][0] + y1 * q_pts_2d[i][1] + y2 * q_pts_2d[i][2];
	q += 1. / Sqrt(x * y * (1. - x - y)) * q_wts_2d[i];
    }

    return q * area(x0, y0, x1, y1, x2, y2);
}

static int depth_max = 0;

static FLOAT
quad_2D(FLOAT old, FLOAT x0, FLOAT y0, FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2)
/* Computes recursively integral of 1/sqrt(xy(1-x-y)) on a triangle */
{
    static int depth = 0;
    FLOAT q, q0, q1, q2, q3;
    FLOAT x01 = (x0 + x1) * 0.5, y01 = (y0 + y1) * 0.5,
	  x02 = (x0 + x2) * 0.5, y02 = (y0 + y2) * 0.5,
	  x12 = (x1 + x2) * 0.5, y12 = (y1 + y2) * 0.5;

    depth++;
    if (depth_max < depth)
	depth_max = depth;

    q0 = quad_2D0(x0, y0, x01, y01, x02, y02);
    q1 = quad_2D0(x1, y1, x01, y01, x12, y12);
    q2 = quad_2D0(x2, y2, x02, y02, x12, y12);
    q3 = quad_2D0(x01, y01, x02, y02, x12, y12);
 
    q = q0 + q1 + q2 + q3;
    if (Fabs(q - old) <= 1e-3 * q)
	return q;

    q = quad_2D(q0, x0, y0, x01, y01, x02, y02) +
	quad_2D(q1, x1, y1, x01, y01, x12, y12) +
	quad_2D(q2, x2, y2, x02, y02, x12, y12) +
	quad_2D(q3, x01, y01, x02, y02, x12, y12);

    depth--;

    return q;
}

static FLOAT
extremal_2D(FLOAT a)
/* Computes:
 *	\int_{1/3-a}^{1/3+2a} \int_{1/3-a}^{2/3+a-x} 1/sqrt{xy(1-x-y)} dy dx
 *
 * Note: let x0=y0=1/3-a, d=3a, then the triangle is given by:
 * 	(x0,y0), (x0,y0+d), (x0+d,y0)
 * and the upper bound for y is determined by:
 * 	x-x0 + y-y0 = d
 * thus we have:
 * 	y = x0 + y0 + d - x = 2/3 + a - x
 */
{
    FLOAT x0, y0, dx, dy;

    x0 = y0 = 1. / _F(3.) - a;
    dx = dy = 3. * a;

    return quad_2D(-1.0, x0, y0, x0 + dx, y0, x0, y0 + dy);
}

static void
density_2D(void)
/* Computes the cumulative density: den[j] = extremal_2D((1/3) * j / den_n) */
{
    int j;
    FLOAT a;

    if (den != NULL)
	return;
    den_n = 500;
    den = malloc((den_n + 1) * sizeof(*den));

    for (j = 0; j <= den_n; j++) {
	a = j / (_F(3.) * den_n);
	if (j == 0)
	    den[j] = 0.;
	else if (j == den_n)
	    den[j] = 2. * PI;
	else
	    den[j] = extremal_2D(a);
    }
}

/*------------------------------ 2D density --------------------------*/

#define Perm4(a)	{a,a,a,a}
#define Dup4(w)		w
#define Perm31(a)	{a,a,a,1.-3.*(a)}, {a,a,1.-3.*(a),a}, \
			{a,1.-3.*(a),a,a}, {1.-3.*(a),a,a,a}
#define Dup31(w)	w,w,w,w
#define Perm22(a)	{a,a,.5-(a),.5-(a)}, {a,.5-(a),a,.5-(a)}, \
			{a,.5-(a),.5-(a),a}, {.5-(a),a,.5-(a),a}, \
			{.5-(a),a,a,.5-(a)}, {.5-(a),.5-(a),a,a}
#define Dup22(w)	w,w,w,w,w,w
#define Perm211(a,b)	{a,a,b,1.-(a)-(a)-(b)}, {a,a,1.-(a)-(a)-(b),b}, \
			{a,b,a,1.-(a)-(a)-(b)}, {a,b,1.-(a)-(a)-(b),a}, \
			{a,1.-(a)-(a)-(b),a,b}, {a,1.-(a)-(a)-(b),b,a}, \
			{b,a,a,1.-(a)-(a)-(b)}, {b,a,1.-(a)-(a)-(b),a}, \
			{b,1.-(a)-(a)-(b),a,a}, {1.-(a)-(a)-(b),a,a,b}, \
			{1.-(a)-(a)-(b),a,b,a}, {1.-(a)-(a)-(b),b,a,a}
#define Dup211(w)	w,w,w,w,w,w,w,w,w,w,w,w
#define Perm0111(p,a,b,c)	{p,a,b,c}, {p,a,c,b}, {p,b,a,c}, \
				{p,b,c,a}, {p,c,a,b}, {p,c,b,a}
#define Perm1111(a,b,c) Perm0111(a,b,c,1.-(a)-(b)-(c)), \
			Perm0111(b,a,c,1.-(a)-(b)-(c)), \
			Perm0111(c,a,b,1.-(a)-(b)-(c)), \
			Perm0111(1.-(a)-(b)-(c),a,b,c)
#define Dup1111(w)	Dup111(w), Dup111(w), Dup111(w), Dup111(w)

/* 3D order 13 quadrature */
static FLOAT q_wts_3d[] = {
    Dup4(.01501368777308314675062970631615983),
    Dup31(.01822520928017342532379068941490097),
    Dup31(.00700610921774146424038518693926311),
    Dup22(.01642354974394954829540573107905531),
    Dup22(.00512061009636059707262596949702171),
    Dup22(.01119669865290491634382032086351956),
    Dup211(.01561914973337995400953811302431969),
    Dup211(.00248442301331647441904056776338473),
    Dup211(.00163859853481823893844525309440751),
    Dup211(.00590303044012492197171914655535865),
    Dup211(.01102208245821805240445097989201525),
    Dup211(.00040645183996417822585155512755848),
    Dup1111(.00268796997296854209745781926651729),
    Dup1111(.00197950480552671190531894675510740),
    Dup1111(.00544631918142579120943187040108667)
};
static FLOAT q_pts_3d[][4] = {
    Perm4(.25),
    Perm31(.15521609351908950314115784335704739),
    Perm31(.33012266333967360024433192595196779),
    Perm22(.16680640389386249928937782601144234),
    Perm22(.02492378854777361779701400374860089),
    Perm22(.09719762991575100143072243716240818),
    Perm211(.24785929015736256692746910620827934,
	    .43365324235685144718726061434767377),
    Perm211(.02223159608186700290879521860892929,
	    .83690032040373400514509486595698594),
    Perm211(.10727869331305341049150459639584801,
	    .77498030597500180756587877274179289),
    Perm211(.19817684388398981142331840582142759,
	    .58756930578220530259172017903595920),
    Perm211(.06917924347737931647732534347465502,
	    .60420006666006644707935264871115302),
    Perm211(.02311471947193316000000000000001000,
	    .93087579279244424864920228882888307),
    Perm1111(.11788928751019608922290117470644250,
	     .11651536422540720000000000000001000,
	     .04202400112551542095676634303719997),
    Perm1111(.67703279860228426355032221326746594,
	     .04616537602461971083458041122176081,
	     .00084434031890503975729899692135905),
    Perm1111(.48489008867363312201080094154790828,
	     .35888294295520201572423646909421086,
	     .13818283491762872996955080907912355)
};

static FLOAT
volume(FLOAT x0, FLOAT y0, FLOAT z0, FLOAT x1, FLOAT y1, FLOAT z1,
       FLOAT x2, FLOAT y2, FLOAT z2, FLOAT x3, FLOAT y3, FLOAT z3)
/* returns the volume of the given tetrahedron */
{
    x1 -= x0; y1 -= y0; z1 -= z0;
    x2 -= x0; y2 -= y0; z2 -= z0;
    x3 -= x0; y3 -= y0; z3 -= z0;

    return Fabs(x1*y2*z3 + x2*y3*z1 + y1*z2*x3 -
		z1*y2*x3 - y1*x2*z3 - z2*y3*x1) * (1./6.);
}

static FLOAT
quad_3D0(FLOAT x0, FLOAT y0, FLOAT z0, FLOAT x1, FLOAT y1, FLOAT z1,
	 FLOAT x2, FLOAT y2, FLOAT z2, FLOAT x3, FLOAT y3, FLOAT z3)
/* Computes integral of 1/sqrt(xyz(1-x-y-z)) on a triangle using a 3D rule */
{
    int i;
    FLOAT q, x, y, z;

    q = 0.;
    for (i = 0; i < sizeof(q_wts_3d) / sizeof(*q_wts_3d); i++) {
	x = x0 * q_pts_3d[i][0] + x1 * q_pts_3d[i][1] + x2 * q_pts_3d[i][2] +
	    x3 * q_pts_3d[i][3];
	y = y0 * q_pts_3d[i][0] + y1 * q_pts_3d[i][1] + y2 * q_pts_3d[i][2] +
	    y3 * q_pts_3d[i][3];
	z = z0 * q_pts_3d[i][0] + z1 * q_pts_3d[i][1] + z2 * q_pts_3d[i][2] +
	    z3 * q_pts_3d[i][3];
	q += 1. / Sqrt(x * y * z * (1. - x - y - z)) * q_wts_3d[i];
    }

    return q * volume(x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3);
}

static FLOAT
quad_3D(FLOAT old, FLOAT x0, FLOAT y0, FLOAT z0, FLOAT x1, FLOAT y1, FLOAT z1,
		   FLOAT x2, FLOAT y2, FLOAT z2, FLOAT x3, FLOAT y3, FLOAT z3)
/* Computes recursively integral of 1/sqrt(xyz(1-x-y-z)) on a tetrahedron */
{
    static int depth = 0;
    FLOAT q, q0, q1, q2, q3, q4, q5, q6, q7;
    FLOAT x01 = (x0 + x1) * 0.5, y01 = (y0 + y1) * 0.5, z01 = (z0 + z1) * 0.5,
	  x02 = (x0 + x2) * 0.5, y02 = (y0 + y2) * 0.5, z02 = (z0 + z2) * 0.5,
	  x03 = (x0 + x3) * 0.5, y03 = (y0 + y3) * 0.5, z03 = (z0 + z3) * 0.5,
	  x12 = (x1 + x2) * 0.5, y12 = (y1 + y2) * 0.5, z12 = (z1 + z2) * 0.5,
	  x13 = (x1 + x3) * 0.5, y13 = (y1 + y3) * 0.5, z13 = (z1 + z3) * 0.5,
	  x23 = (x2 + x3) * 0.5, y23 = (y2 + y3) * 0.5, z23 = (z2 + z3) * 0.5;

    depth++;
    if (depth_max < depth)
	depth_max = depth;

    q0 = quad_3D0(x0, y0, z0,  x01,y01,z01, x02,y02,z02, x03,y03,z03);
    q1 = quad_3D0(x1, y1, z1,  x01,y01,z01, x12,y12,z12, x13,y13,z13);
    q2 = quad_3D0(x2, y2, z2,  x02,y02,z02, x12,y12,z12, x23,y23,z23);
    q3 = quad_3D0(x3, y3, z3,  x03,y03,z03, x13,y13,z13, x23,y23,z23);

    /* Note: for dividing the inner octahedron we need to choose a
     * diagonal among 01-23, 02-13 and 03-12 (here we choose 02-13),
     * see ../papers/tetrahedon-subdivision.pdf */
    q4 = quad_3D0(x01,y01,z01, x13,y13,z13, x03,y03,z03, x02,y02,z02);
    q5 = quad_3D0(x01,y01,z01, x12,y12,z12, x13,y13,z13, x02,y02,z02);
    q6 = quad_3D0(x23,y23,z23, x02,y02,z02, x12,y12,z12, x13,y13,z13);
    q7 = quad_3D0(x23,y23,z23, x03,y03,z03, x02,y02,z02, x13,y13,z13);

 
    q = q0 + q1 + q2 + q3 + q4 + q5 + q6 + q7;
    if (Fabs(q - old) <= 1e-3 * q)
	return q;

    q = quad_3D(q0, x0, y0, z0,  x01,y01,z01, x02,y02,z02, x03,y03,z03) +
	quad_3D(q1, x1, y1, z1,  x01,y01,z01, x12,y12,z12, x13,y13,z13) +
    	quad_3D(q2, x2, y2, z2,  x02,y02,z02, x12,y12,z12, x23,y23,z23) +
    	quad_3D(q3, x3, y3, z3,  x03,y03,z03, x13,y13,z13, x23,y23,z23) +
	quad_3D(q4, x01,y01,z01, x13,y13,z13, x03,y03,z03, x02,y02,z02) +
	quad_3D(q5, x01,y01,z01, x12,y12,z12, x13,y13,z13, x02,y02,z02) +
	quad_3D(q6, x23,y23,z23, x02,y02,z02, x12,y12,z12, x13,y13,z13) +
	quad_3D(q7, x23,y23,z23, x03,y03,z03, x02,y02,z02, x13,y13,z13);

    depth--;

    return q;
}

static FLOAT
extremal_3D(FLOAT a)
/* Computes:
 *	\int_{1/4-a}^{1/4+3a} \int_{1/4-a}^{1/2+2a-x} \int_{1/4-a}^{3/4+a-x-y}
 *		1/sqrt{x y z (1 - x - y - z)} dz dx dy
 *
 * Note: let x0=y0=z0=1/4-a, d=4a, then the tetrahedron is given by:
 * 	(x0,y0,z0), (x0+d,y0,z0), (x0,y0+d,z0), (x0,y0,z0+d)
 * and the upper bounds for y and z are determined by:
 * 	x-x0 + y-y0 = d
 * thus we have:
 * 	y = x0 + y0 + d - x = 1/2 + 2*a - x
 * 	z = x0 + y0 + z0 + d - x - y = 3/4 + a - x - y
 */
{
    FLOAT x0, y0, z0, dx, dy, dz;

    x0 = y0 = z0 = 1. / _F(4.) - a;
    dx = dy = dz = 4. * a;

    return quad_3D(-1.0, x0, y0, z0,
			 x0 + dx, y0, z0,
			 x0, y0 + dy, z0,
			 x0, y0, z0 + dz);
}

static void
density_3D(void)
/* Computes the cumulative density: den[j] = extremal_3D((1/4) * j / den_n) */
{
    int j;
    FLOAT a;

    if (den != NULL)
	return;
    den_n = 250;
    den = malloc((den_n + 1) * sizeof(*den));

    for (j = 0; j <= den_n; j++) {
	a = j / (_F(4.) * den_n);
	if (j == 0)
	    den[j] = 0.;
	else if (j == den_n)
	    den[j] = PI * PI;
	else
	    den[j] = extremal_3D(a);
    }
}

#undef Perm3
#undef Dup3
#undef Perm21
#undef Dup21
#undef Perm111
#undef Dup111

#undef Perm4
#undef Dup4
#undef Perm31
#undef Dup31
#undef Perm22
#undef Dup22
#undef Perm211
#undef Dup211
#undef Perm0111
#undef Perm1111
#undef Dup1111

static void
distribute_points(int n, FLOAT x[], int ix, FLOAT a, FLOAT b, FLOAT d[], int m)
/* Generates randomly n points such that:
 *	1) the points are in the interval (a,b).
 *	2) the cumulative distribution density is given by d[0..m] */
{
    FLOAT c;
    int j0, j1, i;

    j1 = j0 = 0;
    for (i = 0; i < n; i++, x += ix) {
	c = (i + 1) * d[m] / n;
	if (c > d[j1]) {
	    j0 = j1;
	    while (j1 < m && c > d[j1])
		j1++;
	}
#if 0
	/* uniform distribution (only for testing) */
	*x = a + Random(1.0) * (b - a);
#else
	*x = a + (j0 + Random(j1-j0)) * (b - a) / m;
#endif
    }
}

#endif	/* USE_INTERVALS */

static void
seed11(int n, FLOAT *x)
{
#if USE_INTERVALS
    distribute_points(n, x, 1, 0., 1./2., den, den_n);
#elif USE_EXTREMAL_MEASURE
    fprintf(stderr, "%s:%d: unimplemented case.\n", __FILE__, __LINE__);
#if USE_MPI
    MPI_Abort(MPI_COMM_WORLD, 1);
#endif
    exit(1);
#else	/* USE_EXTREMAL_MEASURE */
    int i;
    for (i = 0; i < n; i++, x++) {
	/* uniform distribution */
	x[0] = Random(0.5);
    }
#endif	/* USE_EXTREMAL_MEASURE */
}

static void
seed21(int n, FLOAT *x)
{
    int i;
#if USE_INTERVALS
    /* Note: the points are distributed along a centerline with a in the 
     * range (0,1/2). We apply den[] on the two intervals [1/3,0] and
     * [1/3,1/2] respectively:
     *
     * 	     vertex		   center     edge center
     *		0....................1/3..........1/2
     *	    den[den_n]		    den[0]	den[den_n]
     */
#if 0
    static FLOAT *t = NULL;
    if (t == NULL) {
	/* Compute cumulative density of the points on the centerline. */
	t = malloc((2 * den_n + 1) * sizeof(*t));
	t[0] = 0.;
	for (i = 1; i <= den_n; i++)
	    t[i] = t[i - 1] + den[den_n - i + 1] - den[den_n - i];
	for (; i <= 2 * den_n; i++)
	    t[i] = t[i - 1] + den[i - den_n] - den[i - 1 - den_n];
    }
    distribute_points(n, x, 1, 0.0, 0.5, t, 2 * den_n);
#else
    /* Put n/2 points in each interval. */
    i = (int)(n * 0.5 + Random(1.0));
    distribute_points(i, x, 1, 1./3., 0., den, den_n);
    distribute_points(n - i, x + i, 1, 1./3., .5, den, den_n);
#endif
#elif USE_EXTREMAL_MEASURE
    for (i = 0; i < n; i++, x++) {
	FLOAT a, f;
	while (1) {
	    a = Random(1.0);
	    f = Random(EXTREMAL_TRUNC);
	    if (a > .5)
		continue;
	    if (a == 0. || a == 0.5)
		break;
	    if (f < 1. / (a * Sqrt(1. - a - a)));
		break;
	}
	x[0] = a;
    }
#else	/* USE_EXTREMAL_MEASURE */
    for (i = 0; i < n; i++, x++) {
	/* uniform distribution */
	x[0] = Random(0.5);
    }
#endif	/* USE_EXTREMAL_MEASURE */
}

static void
seed111(int n, FLOAT *x)
{
    int i;

#if USE_INTERVALS
    FLOAT x0, y0, x1;
    if (n == 0)
	return;
    /* We treat the concentric triangles as the isolines of the density.
     * The description below uses the standard triangle.
     *
     * 1. Distribute n points on the segment (1/3,1/3)-(0,0):
     * 		(x[i],y[i]) = (1-t[i]) * (1/3,1/3) + t[i] * (0,0)
     *	  using den[] as the cumulative density.
     *
     * 2. For each i choose a point on the segment:
     *		(x[i],y[i]) --- ((1-y[i])/2, y[i])
     *	  (note: the right end of the segment is the intersection of the
     *	  line y=y[i] with the line (0,1)---(1/2,0)) */
    distribute_points(n, x, 2, 0., 1., den, den_n);
    for (i = 0; i < n; i++) {
	y0 = x0 = (1. - *x) / 3. + (*x) * 0.;
	x1 = (1. - y0) * .5;
	*(x++) = x0 + (x1 - x0) * Random(1.);
	*(x++) = y0;
    }
#elif USE_EXTREMAL_MEASURE
    for (i = 0; i < n; i++, x += 2) {
	FLOAT a, b, f;
	while (1) {
	    a = Random(1.0);
	    b = Random(1.0);
	    f = Random(EXTREMAL_TRUNC);
	    if (b >= a || b <= .5 * (1. - a) || a + b > 1)
		continue;
	    if (a == 1. || b == 0. || a + b == 1.)
		break;
	    if (f < 1. / Sqrt(a * b * (1. - a - b)));
		break;
	}
	x[0] = a;
	x[1] = b;
    }
#else	/* USE_EXTREMAL_MEASURE */
    for (i = 0; i < n; i++, x += 2) {
	x[0] = Random(1. / 3.);
	x[1] = x[0] + Random(.5 - x[0]);
    }
#endif	/* USE_INTERVALS */
}

static void
seed31(int n, FLOAT *x)
{
    int i;

#if USE_INTERVALS
    /* Note: the points are distributed along a centerline with a in the 
     * range (0,1/3). We apply den[] on the two intervals [1/4,0] and
     * [1/4,1/3] respectively:
     *
     * 	     vertex			     center     edge center
     *		0..............................1/4..........1/3
     *	    den[den_n]			     den[0]	den[den_n]
     */
    i = (int)(n * 0.5 + Random(.99999));
    distribute_points(i, x, 1, 1./4., 0., den, den_n);
    distribute_points(n - i, x + i, 1, 1./4., 1./3., den, den_n);
#elif USE_EXTREMAL_MEASURE
    for (i = 0; i < n; i++, x++) {
	FLOAT a, f;
	while (1) {
	    a = Random(1.0);
	    f = Random(EXTREMAL_TRUNC);
	    if (a > 1. / _F(3.))
		continue;
	    if (a == 0. || Fabs(a - (FLOAT)(1. / _F(3.))) < 1e10)
		break;
	    if (f < 1. / Sqrt(a * a * a * (1. - 3. * a)));
		break;
	}
	x[0] = a;
    }
#else	/* USE_EXTREMAL_MEASURE */
    for (i = 0; i < n; i++, x++) {
	x[0] = Random(1. / _F(3.));
    }
#endif	/* USE_EXTREMAL_MEASURE */
}

static void
seed22(int n, FLOAT *x)
{
#if 0*USE_INTERVALS
    /* Note: the points are on the segment linking the centers of two
     * opposing edges with a in the range (0,1/2). By symmetry we only need
     * to take a in the interval (1/4,0) with den[] as cumulative density.
     */
    distribute_points(n, x, 1, 1./4., 0., den, den_n);
#elif USE_EXTREMAL_MEASURE
    int i;
    for (i = 0; i < n; i++, x++) {
	FLOAT a, f;
	while (1) {
	    a = Random(1.0);
	    f = Random(EXTREMAL_TRUNC);
	    if (a >= 0.25)
		continue;
	    if (a == 0.)
		break;
	    if (f < 1. / Sqrt(a * a * (.5 - a) * (.5 - a)))
		break;
	}
	x[0] = a;
    }
#else	/* USE_EXTREMAL_MEASURE */
    int i;
    for (i = 0; i < n; i++, x++) {
	x[0] = Random(1. / _F(4.));
    }
#endif	/* USE_EXTREMAL_MEASURE */
}

static void
seed211(int n, FLOAT *x)
{
    int i;

#if 0*USE_INTERVALS
    /* The points (a,a,b,1-2a-b) are on the triangle (p2,p3,(p0+p1)/2).
     * We first call seed111() to generate 2D points with den[], then map them
     * to the triangle, with the 2D point (a,b,1-a-b) mapped to:
     * 		(a,b,1-a-b) -->
     * 		a * p2 + b * p3 + (1-a-b)*(p0+p1)/2) = 
     * 		(1-a-b)/2 p0 + (1-a-b)/2 p1 + a p2 + b p3 -->
     * 		((1-a-b)/2, (1-a-b)/2, a, b)
     * Thus we have a:=(1-a-b)/2, b:=a */
    FLOAT a, b;
    seed111(n, x);
    for (i = 0; i < n; i++, x += 2) {
	a = x[0];
	b = x[1];
	x[0] = (1. - a - b) * 0.5;
	x[1] = a;
    }
#elif USE_EXTREMAL_MEASURE
    for (i = 0; i < n; i++, x += 2) {
	FLOAT a, b, f;
	while (1) {
	    a = Random(1.0);
	    b = Random(1.0);
	    f = Random(EXTREMAL_TRUNC);
	    if (b == a || a >= .5 || a + a + b > 1. || b <= .5 * (1. - a - a))
		continue;
	    if (a == 0. || a == .5 || b == 0. || b == 1. || a + a + b == 1.)
		break;
	    if (f < 1. / Sqrt(a * a * b * (1. - a - a - b)))
		break;
	}
	x[0] = a;
	x[1] = b;
    }
#else	/* USE_EXTREMAL_MEASURE */
    for (i = 0; i < n; i++, x += 2) {
	x[0] = Random(.5);
	x[1] = Random(1. - 2. * x[0]);
    }
#endif	/* USE_EXTREMAL_MEASURE */
}

static void
seed1111(int n, FLOAT *x)
{
    int i;

#if 0*USE_INTERVALS
    /* We treat the concentric tetrahedra as the isosurfaces of the density.
     * The description below uses the standard triangle.
     *
     * 1. Distribute n points on the segment (1/4,1/4,1/4)-(0,0,0):
     * 		(x[i],y[i],z[i]) = (1-t[i]) * (1/4,1/4,1/4) + t[i] * (0,0,0)
     *	  using den[] as the cumulative density.
     *
     * 2. For each i choose a point on the surface of the tetrahedron:
     *		(x[i],y[i],z[i]) + T * t[i]
     *	  where 'T' denotes the standard tetrahedron.
     */
    FLOAT x0, y0, a;
    distribute_points(n, x, 3, 0., 1., den, den_n);
    for (i = 0; i < n; i++) {
	/* Generate a point on the standard triangle */
	a = *x;
	x0 = Random(1.0);
	y0 = Random(1.0 - x0);
	*(x++) =  (1.0 - a) + x0 * a;
	*(x++) =  (1.0 - a) + y0 * a;
	*(x++) =  (1.0 - a);
    }
#else	/* USE_INTERVALS */
    for (i = 0; i < n; i++, x += 3) {
# if USE_EXTREMAL_MEASURE
	FLOAT a, b, c, f;
	/* Note: the loop below is very time consuming! */
	while (1) {
	    a = Random(1.0);
	    b = Random(1.0);
	    c = Random(1.0);
	    f = Random(EXTREMAL_TRUNC);
	    if (a == 1. || b >= a || c >= b || a + b + c > 1.)
		continue;
	    if (c == 0. || a + b + c == 1.) 
		break;
	    if (f < 1. / Sqrt(a * b * c * (1. - a - b - c)))
		break;
	}
	x[0] = a;
	x[1] = b;
	x[2] = c;
# endif	/* USE_EXTREMAL_MEASURE */
	x[0] = Random(1.);
	x[1] = Random(1. - x[0]);
	x[2] = Random(1. - x[0] - x[1]);
    }
#endif	/* USE_INTERVALS */
}

static void
abscissas_seed(FLOAT D[])
/* this function generates an initial guess on the abscissas */
{
#if SYMMETRY
    int j;

    if (dim == 1) {
	seed11(s11, D);
	j = s11;
    }
    else if (dim == 2) {
#if 0
/* Testing with given initial data */
#define	Perm21(a)	a
#define	Cons21(a)	a
#define	Perm111(a,b)	a,b
#define	Cons111(a,b)	a,b
/*--------------------------------*/
	static FLOAT D0[] = {
	};
	assert(s3 == 0 && s21 == 9 && s111 == 24);
	Unused(seed21);
	Unused(seed111);
	memcpy(D, D0, sizeof(D0));
	j = sizeof(D0) / sizeof(D0[0]);
/*--------------------------------*/
#undef	Perm21
#undef	Cons21
#undef	Perm111
#undef	Cons111
#else
	seed21(s21, D);
	j = s21;
	seed111(s111, D + j);
	j += 2 * s111;
#endif
    }
    else {
#if 0
/* Testing with given initial data */
#define	Perm31(a)	a
#define	Cons31(a)	a
#define	Perm22(a)	a
#define	Cons22(a)	a
#define	Perm211(a,b)	a,b
#define	Cons211(a,b)	a,b
#define	Perm1111(a,b,c)	a,b,c
#define	Cons1111(a,b,c)	a,b,c
/*--------------------------------*/
# if 1
/* Test data for 'quadrule 3 6 21 1 5 0 0 0' */
	static FLOAT D0[] = {
	    Perm31(0.3303056835048566),
	    Perm31(1e-06),
	    Perm31(1e-06),
	    Perm31(1e-06),
	    Perm31(1e-06)
	};
	assert(s4 == 1 && s31 == 5 && s22 == 0 && s211 == 0 && s1111 == 0);
# else
/* Test data for 'quadrule 3 7 50 0 2:1 1 3:1:2 0' (quadrule-ml 3 3 5 6) */
	static FLOAT D0[] = {
	    Cons31(0.),
	    Perm31(0.09503775858394107),
	    Perm22(0.1252462362578136),
	    Cons211(0,0.2928294047674109),
	    Cons211(0.1972862280257976,0),
	    Cons211(0.4256461243139345,0)
	};
	assert(s4 == 0 && s31 == 2 && s22 == 1 && s211 == 3);
# endif
	Unused(seed31);
	Unused(seed22);
	Unused(seed211);
	Unused(seed1111);
	memcpy(D, D0, sizeof(D0));
	j = sizeof(D0) / sizeof(D0[0]);
/*--------------------------------*/
#undef	Perm31
#undef	Cons31
#undef	Perm22
#undef	Cons22
#undef	Perm211
#undef	Cons211
#undef	Perm1111
#undef	Cons1111
#else	/* 0 */
	seed31(s31, D);
	j = s31;
	seed22(s22, D + j);
	j += s22;
	seed211(s211, D + j);
	j += 2 * s211;
	seed1111(s1111, D + j);
	j += 3 * s1111;
#endif	/* 0 */
    }
    assert(j == nabsc);
#else	/* SYMMETRY */
    for (i = 0; i < npoints; i += dim) {
	D[i] = Random(1.0);
	if (dim > 1)
	    D[i + 1] = Random(1.0 - D[i]);
	if (dim > 2)
	    D[i + 2] = Random(1.0 - D[i] - D[i + 1]);
    }
#endif
}

static int
ls_factor(int m, int n, int trans, int lda, FLOAT A[], int **pivot_ptr)
/* LU factorization of the matrix trans(A)[m][lda] with full pivoting.
 *
 * m and n are the number of rows and columns of trans(A), lda >= n
 *
 * 'pivot_ptr' is the pointer to the integer array of size 2*n, either provided
 * by the calling function or allocated in this function (if *pivot_ptr==NULL),
 * which stores the positions of pivots: the row and column number for the i-th
 * pivot are stored as:
 * 	(*pivot_ptr)[2*i] and (*pivot_ptr)[2*i+1]
 */
{
    int i, j, k, p, q, nfree = 0, *pivot;
    FLOAT d, t;
#define a(i,j) A[trans ? (j) * lda + (i) : (i) * lda + (j)]

    assert(pivot_ptr != NULL);

    if (*pivot_ptr == NULL)
	*pivot_ptr = pivot = malloc(2 * n * sizeof(*pivot));
    else
	pivot = *pivot_ptr;

    for (j = 0; j < n && j < m; j++) {
	/* find pivot */
	d = Fabs(a(j,j));
	p = q = j;
	for (i = j; i < m; i++) {
	    for (k = j; k < n; k++) {
		if (d < (t = Fabs(a(i,k)))) {
		    d = t;
		    p = i;
		    q = k;
		}
	    }
	}
#if 0
#if FT_PHG == FT___FLOAT128
	if (d < EPS * 1e-20)
#elif FT_PHG == FT_LONG_DOUBLE
	if (d < EPS * 1e-12)
#elif FT_PHG == FT_DOUBLE
	if (d < EPS * 1e-08)
#else
	if (d < EPS * 1e-02)
#endif	/* FT_PHG != FT_DOUBLE */
#else
	if (d == 0.0)
#endif
	{
	    nfree = n - j;
	    for (i = j; i < n; i++) {
		pivot[2 * i + 1] = i;
		if (i < m)
		    a(i,i) = 0.;
	    }
	    /*fprintf(stderr, "ls_factor(): singular system!\n");*/
	    break;
	}
	pivot[2 * j] = p;
	pivot[2 * j + 1] = q;
	if (p != j) {
	    /* swap rows j and k */
	    for (i = j; i < n; i++) {
		t = a(j,i);
		a(j,i) = a(p,i);
		a(p,i) = t;
	    }
	}
	if (q != j) {
	    /* swap columns q and j */
	    for (k = 0; k < m; k++) {
		t = a(k, j);
		a(k, j) = a(k, q);
		a(k, q) = t;
	    }
	}
	a(j,j) = d = 1.0 / a(j,j);
	for (i = j + 1; i < n; i++)
	    a(j,i) *= d;
	for (i = j + 1; i < m; i++) {
	    d = a(i,j);
	    for (k = j + 1; k < n; k++)
		a(i,k) -= d * a(j,k);
	}
    }

    for (; j < n; j++)
	pivot[2 * j + 1] = j;

#if 0
	for (i = 0; i < m; i++) {
	    for (k = 0; k < n; k++)
		fprintf(stderr, " %lg", (double)a(i,k));
	    fprintf(stderr, "\n");
	}
	/* check consistency of the equations */
	for (i = j; i < m; i++) {
	    if (Fabs(a(i, n)) >= EPS)
		return -1;
	}
#endif

#undef a
    return nfree;
}

static void
ls_solve(int m, int n, int trans, int lda, const FLOAT *A, const int pivot[],
	 FLOAT B[], FLOAT X[])
/* solves trans(A)*X = B, A has been factorized by ls_factor(),
 *
 * m and n are the number of rows and columns of trans(A), lda >= n
 *
 * X and B may overlap if m >= n */
{
    int i, j, p;
    FLOAT t;
#define a(i,j) A[trans ? (j) * lda + (i) : (i) * lda + (j)]
#define b(i) (B[i])
#define x(i) (X[i])

    for (j = 0; j < n && j < m; j++) {
	if (a(j,j) == 0.)
	    break;
	p = pivot[2 * j];
	if (p != j) {
	    /* swap rows j and k */
	    t = b(j);
	    b(j) = b(p);
	    b(p) = t;
	}
	b(j) *= a(j,j);
	for (i = j + 1; i < m; i++)
	    b(i) -= a(i,j) * b(j);
    }

    for (; j < n && j < m; j++)
	b(j) = 0.;

    for (j = n - 1; j >= 0; j--) {
	x(j) = (j < m ? b(j) : 0.);
	if (j >= m || a(j,j) == 0.)
	    continue;
	for (i = j + 1; i < n; i++)
	    x(j) -= a(j,i) * x(i);
    }

    /* reorder the solution */
    for (j = n - 1; j >= 0; j--) {
	assert(pivot[2 * j + 1] >= j);
	if ((i = pivot[2 * j + 1]) == j)
	    continue;
	t = x(j);
	x(j) = x(i);
	x(i) = t;
    }

#undef a
#undef b
#undef x

    return;
}

static void
computeA(FLOAT x[][dim], const int wmap[], FLOAT **A_ptr, FLOAT **DA_ptr)
/* Computes the matrix A[neqns][nwgts] defined by:
 *	a_{i,j} = sum_{k in group j} f_i(x_k), i=1,...,neqns, j=1,...,nwgts
 *
 * and DA[nabsc][neqns][nwgts] which is the derivatives of A w.r.t. abscissas.
 *
 * Note: DA is sparse in the nabsc dimension, i.e., DA[i][j][k]is nonzero only
 * when the 'i'-th abscissa and the 'k'-th weight belong to a same symmetry
 * group, and for each given equation and weight there are at most 'dim'
 * nonzeros. Thus we only allocate 'dim'+1 entries for the third dimension of
 * DA, and store the integer 'start_no * (nabsc+1) + end_no' in DA[dim][j][k],
 * where 'start_no' and 'end_no' are the start and end abscissa numbers for the
 * 'j'-th equation and 'k-th' weight (in fact 'start_no' and 'end_no' are
 * independent of 'j').
 */
{
    FLOAT *A = NULL, *DA = NULL;

    assert(neqns >= npolys && neqns <= npolys_max);

    if (A_ptr != NULL)
	*A_ptr = A = calloc(neqns * nwgts, sizeof(*A));

    if (DA_ptr != NULL)
	*DA_ptr = DA = calloc((dim + 1) * neqns * nwgts, sizeof(*DA));

    if (A != NULL) {
	int i, j;
#define a(i,j)	(A[(i) * nwgts + (j)])
	for (i = 0; i < neqns; i++) {
	    for (j = 0; j < npoints; j++) {
		a(i, wmap[j]) += poly_eval(pbasis[i], x[j][0],
					dim < 2 ? (FLOAT)0. : x[j][1],
					dim < 3 ? (FLOAT)0. : x[j][2]);
	    }
	}
#undef a
    }

    if (DA != NULL) {
	/* compute derivatives of A with respect to the abscissas */
#define da(i,j,k)	(DA[((i) * neqns + (j)) * nwgts + (k)])
	int i, j, k, l0, l1, l;
        FLOAT d, e, f, xjac[npoints][dim];

	for (i = 0; i < neqns; i++) {
	    /* First, compute the derivatives of the current function w.r.t.
	     * points and store them in xjac[npoints][dim] */
	    for (j = 0; j < npoints; j++) {
		if (dim == 1) {
		    xjac[j][0] = poly_eval_d(pbasis[i], 0,
					     x[j][0], (FLOAT)0., (FLOAT)0.);
		}
		else if (dim == 2) {
		    xjac[j][0] = poly_eval_d(pbasis[i], 0,
					     x[j][0], x[j][1], (FLOAT)0.);
		    xjac[j][1] = poly_eval_d(pbasis[i], 1,
					     x[j][0], x[j][1], (FLOAT)0.);
		}
		else {
		    xjac[j][0] = poly_eval_d(pbasis[i], 0,
					     x[j][0], x[j][1], x[j][2]);
		    xjac[j][1] = poly_eval_d(pbasis[i], 1,
					     x[j][0], x[j][1], x[j][2]);
		    xjac[j][2] = poly_eval_d(pbasis[i], 2,
					     x[j][0], x[j][1], x[j][2]);
		}
	    }
	    /* Next, combine xjac[][] into derivatives w.r.t. the abscissas by
	     * multiplying them with the transformation matrix between
	     * points and abscissas.
	     *
	     * For example, an abscissa 'a' of the s21 group is mapped to
	     * 3 points (a,a,1-2a), (a,1-2a,a), and (1-2a,a,a), i.e.:
	     * 		point 1: x1 = a,    y1 = a
	     * 		point 2: x2 = a,    y2 = 1-2a
	     * 		point 2: x3 = 1-2a, y3 = a
	     * Thus:
	     * 		Df/Da = (Df/Dx1,Df/Dy1,Df/Dx2,Df/Dy2,Df/Dx3,Df/Dy3) * 
	     * 			(Dx1/Da,Dy1/Da,Dx2/Da,Dy2/Da,Dx3/Da,Dy3/Da)^T
	     * 		      = (Df/Dx1,Df/Dy1,Df/Dx2,Df/Dy2,Df/Dx3,Df/Dy3) *
	     * 			(1, 1, 1, -2, -2, 1)^T
	     * 		      = +  Df/Dx1 +  Df/Dy1
	     * 			+  Df/Dx2 -2 Df/Dy2
	     * 			-2 Df/Dx3 +  Df/Dy3
	     */
	    /* Note: code here should match the order in abscissas_{1D,2D,3D} */
	    if (dim == 1) {
		/* k steps over weights, j over points, l0 over abscissas */
		k = j = s2;
		l0 = 0;
		for (l1 = 0; l1 < s11; l1++, k++) {
		    /* Note:	a, 1-a */
		    l = 0;
		    da(l++,i,k) = xjac[j+0][0] - xjac[j+1][0];
		    j += 2;
		    /* da(dim,i,k) = start/end numbers of the abscissas */
		    da(dim,i,k) = l0 * (nabsc + 1) + (l0 + l);
		    l0 += l;
		}
		assert(j == npoints && l0 == nabsc && k == nwgts);
	    }
	    else if (dim == 2) {
		/* k steps over weights, j over points, l0 over abscissas */
		k = j = s3;
		l0 = 0;
		for (l1 = 0; l1 < s21; l1++, k++) {
		    /* Note:	(a,	a),
		     * 		(a,	1-2a),
		     * 		(1-2a,	a) */
		    l = 0;
		    da(l++,i,k) = +	xjac[j+0][0] +    xjac[j+0][1]
				  +	xjac[j+1][0] - 2.*xjac[j+1][1]
				  -  2.*xjac[j+2][0] +    xjac[j+2][1];
		    j += 3;
		    /* da(dim,i,k) = start/end numbers of the abscissas */
		    da(dim,i,k) = l0 * (nabsc + 1) + (l0 + l);
		    l0 += l;
		}
		for (l1 = 0; l1 < s111; l1++, k++) {
		    /* Note:	(a, b),
		     * 		(b, a),
		     * 		(a, c)
		     * 		(c, a)
		     * 		(b, c)
		     * 		(c, b) */
		    l = 0;
		    /* D/Da */
		    da(l++,i,k) = + xjac[j+0][0] + xjac[j+1][1]
				  + xjac[j+2][0] - xjac[j+2][1]
				  - xjac[j+3][0] + xjac[j+3][1]
				  - xjac[j+5][0] - xjac[j+4][1];
		    /* D/Db */
		    da(l++,i,k) = + xjac[j+1][0] + xjac[j+0][1]
				  - xjac[j+3][0] - xjac[j+2][1]
				  + xjac[j+4][0] - xjac[j+4][1]
				  - xjac[j+5][0] + xjac[j+5][1];
		    j += 6;
		    /* da(dim,i,k) = start/end numbers of the abscissas */
		    da(dim,i,k) = l0 * (nabsc + 1) + (l0 + l);
		    l0 += l;
		}
		assert(j == npoints && l0 == nabsc && k == nwgts);
	    }
	    else {	/* dim == 3 */
/* Note: The macros Permxxx must match those in abscissas_3D() */
#define Perm21(A, B)						\
	A xjac[j + 0][0] A xjac[j + 0][1] B xjac[j + 0][2]	\
	A xjac[j + 1][0] B xjac[j + 1][1] A xjac[j + 1][2]	\
	B xjac[j + 2][0] A xjac[j + 2][1] A xjac[j + 2][2]
#define Perm111(A, B, C)					\
	A xjac[j + 0][0] B xjac[j + 0][1] C xjac[j + 0][2]	\
	A xjac[j + 1][0] C xjac[j + 1][1] B xjac[j + 1][2]	\
	B xjac[j + 2][0] C xjac[j + 2][1] A xjac[j + 2][2]	\
	B xjac[j + 3][0] A xjac[j + 3][1] C xjac[j + 3][2]	\
	C xjac[j + 4][0] A xjac[j + 4][1] B xjac[j + 4][2]	\
	C xjac[j + 5][0] B xjac[j + 5][1] A xjac[j + 5][2]
		/* k steps over weights, j over points, l0 over abscissas */
		k = j = s4;
		l0 = 0;
		for (l1 = 0; l1 < s31; l1++, k++) {
		    l = 0;
		    d = xjac[j][0] + xjac[j][1] + xjac[j][2];
		    j += 1;
		    /* (a,a,1-3a) */
		    da(l++,i,k) = d Perm21(+, -3.*);
		    j += 3;
		    /* da(dim,i,k) = start/end numbers of the abscissas */
		    da(dim,i,k) = l0 * (nabsc + 1) + (l0 + l);
		    l0 += l;
		}
		for (l1 = 0; l1 < s22; l1++, k++) {
		    l = 0;
		    /* (a,a,0.5-a) */
		    d = Perm21(+, -);
		    j += 3;
		    /* (0.5-a,0.5-a,a) */
		    da(l++,i,k) = d Perm21(-, +);
		    j += 3;
		    /* da(dim,i,k) = start/end numbers of the abscissas */
		    da(dim,i,k) = l0 * (nabsc + 1) + (l0 + l);
		    l0 += l;
		}
		for (l1 = 0; l1 < s211; l1++, k++) {
		    l = 0;
		    /* (a,a,b) */
		    d = Perm21(+, +0.*);			/* D/Da */
		    e = Perm21(+0.*, +);			/* D/Db */
		    j += 3;
		    /* (a,a,1-2a-b) */
		    d += Perm21(+, -2.*);			/* D/Da */
		    e += Perm21(+0.*, -);			/* D/Db */
		    j += 3;
		    /* (a,b,1-2a-b) */
		    da(l++,i,k) = d Perm111(+, +0.*, -2.*);	/* D/Da */
		    da(l++,i,k) = e Perm111(+0.*, +, -);	/* D/Db */
		    j += 6;
		    /* da(dim,i,k) = start/end numbers of the abscissas */
		    da(dim,i,k) = l0 * (nabsc + 1) + (l0 + l);
		    l0 += l;
		}
		for (l1 = 0; l1 < s1111; l1++, k++) {
		    l = 0;
		    /* (a,b,c) */
		    d = Perm111(+, +0.*, +0.*);			/* D/Da */
		    e = Perm111(+0.*, +, +0.*);			/* D/Db */
		    f = Perm111(+0.*, +0.*, +);			/* D/Dc */
		    j += 6;
		    /* (a,b,1-a-b-c) */
		    d += Perm111(+, +0.*, -);			/* D/Da */
		    e += Perm111(+0.*, +, -);			/* D/Db */
		    f += Perm111(+0.*, +0.*, -);		/* D/Dc */
		    j += 6;
		    /* (a,c,1-a-b-c) */
		    d += Perm111(+, +0.*, -);			/* D/Da */
		    e += Perm111(+0.*, +0.*, -);		/* D/Db */
		    f += Perm111(+0.*, +, -);			/* D/Dc */
		    j += 6;
		    /* (b,c,1-a-b-c) */
		    da(l++,i,k) = d Perm111(+0.*, +0.*, -);	/* D/Da */
		    da(l++,i,k) = e Perm111(+, +0.*, -);	/* D/Db */
		    da(l++,i,k) = f Perm111(+0.*, +, -);	/* D/Dc */
		    j += 6;
		    /* da(dim,i,k) = start/end numbers of the abscissas */
		    da(dim,i,k) = l0 * (nabsc + 1) + (l0 + l);
		    l0 += l;
		}
		assert(j == npoints && l0 == nabsc && k == nwgts);
#undef Perm21
#undef Perm111
	    }
	}
#undef da
    }
}

static void
factorA(const FLOAT A[], FLOAT w[], FLOAT **LU_ptr, int **pivot_ptr)
/* Computes the LU factors of either A or (A^t A), and optionally w[] */
{
    FLOAT *LU, *b = NULL;
    int m, n, i, j, k, *pivot = NULL;

    m = neqns;
    n = nwgts;

#define A_(i,j)	A[(i) * n + (j)]
#define B_(i,j)	LU[(i) * n + (j)]

#if LINEAR_LS
    b = w;
    LU = calloc(n * n, sizeof(LU[0]));
    if (b != NULL)
	bzero(b, n * sizeof(*b));
    /* compute least square solution */
    for (i = 0; i < n; i++) {
	for (k = 0; k < m; k++) {
	    for (j = 0; j < n; j++)
		B_(i,j) += A_(k,i) * A_(k,j);
	    if (b != NULL)
		b[i] += A_(k,i);
	}
    }
#if 0
    {
	/* for debugging only */
	extern int phgSolverDenseSolver(int n, int m, FLOAT *a0, FLOAT *b0);
	Unused(ls_factor);
	Unused(ls_solve);
	phgSolverDenseSolver(n, 1, (void *)LU, b);
	k = 0;
    }
#else
    k = ls_factor(n, n, 0, n, LU, &pivot);
    if (w != NULL)
	ls_solve(n, n, 0, n, LU, pivot, b, w);
#endif
#else	/* LINEAR_LS */
    if (w != NULL)
	b = malloc(m * sizeof(b[0]));
    LU = malloc(m * n * sizeof(LU[0]));
    for (i = 0; i < m; i++) {
	for (j = 0; j < n; j++)
	    B_(i,j) = A_(i,j);
	if (b != NULL)
	    b[i] = 1.0;
    }
    k = ls_factor(m, n, 0, n, LU, &pivot);
    if (b != NULL) {
	ls_solve(m, n, 0, n, LU, pivot, b, w);
	free(b);
    }
#endif	/* LINEAR_LS */

    if (k != 0) {
	assert(k > 0);
	if (print)
	    fprintf(stderr, "WARNING: underdetermined lin. sys. (-%d).\n", k);
    }

    if (pivot_ptr != NULL)
	*pivot_ptr = pivot;
    else
	free(pivot);

    if (LU_ptr != NULL)
	*LU_ptr = LU;
    else
	free(LU);

#undef A_
#undef B_

    return;
}

static FLOAT
compute_weights(FLOAT x[][dim], FLOAT w[], const int wmap[])
/* computes the weights for the given abscissas, wmap[] is initialized to
 * contain the pointers to the abscissas map.
 *
 * returns the L2 error with the integrals of all basis functions */
{
    /* Let the nonlinear function be given by:
     *		F_i = \sum_{j=0,nwgts} a_{i,j} w_j
     * Then A = (a_{i,j}), B is used to store LU of A or A^t*A */ 
    FLOAT *A, a, error;
    int i, j, m, n;

    m = npolys;
    n = nwgts;

    computeA(x, wmap, &A, NULL);
    factorA(A, w, NULL, NULL);

    if (print) {
	for (j = 0; j < npoints; j++) {
	    if (w[wmap[j]] == 0.0)
		continue;
	    if (dim == 2)
		printf(" %13.6le %13.6le %13.6le, %13.6le\n", (double)x[j][0],
			(double)x[j][1], (double)(1. - x[j][0] - x[j][1]),
			(double)w[wmap[j]]);
	    else
		printf(" %13.6le %13.6le %13.6le %13.6le, %13.6le\n",
			(double)x[j][0], (double)x[j][1], (double)x[j][2],
			(double)(1. - x[j][0] - x[j][1] - x[j][2]),
			(double)w[wmap[j]]);
	}
    }

    /* compute errors */
    error = 0.0;
    for (i = 0; i < m; i++) {
	a = 1.0;
	for (j = 0; j < n; j++)
	    a -= A[i * n + j] * w[j];
	error += a * a;
    }

    free(A);

    return Sqrt(error);
}

#define OUTPUT_VTK	1	/* == 0 ==> output gnuplot format */

#if OUTPUT_VTK
#define VTK_OUT(value, var)						\
	var = value;							\
	fwrite(swap_endian(&var, sizeof(var)), sizeof(var), 1, f);

static void *
swap_endian(const void *p0, size_t size)
{
    static unsigned char s[16];
    const unsigned char *p;
    unsigned char *q;

    p = p0;
    q = s + size;

    assert(sizeof(s) >= size);
    while (q > s) *(--q) = *(p++);

    return s;
}
#endif

static void
plot_gen(int n, int n0, FLOAT D0, FLOAT D[])
{
    static int no = 0;
    static char fn[PATH_MAX + 1];
    FILE *f;
    int i, j, k, N, L;
    FLOAT err, min, max, d;
    int *wmap;
    FLOAT (*x)[dim], *w;
#if OUTPUT_VTK
    float fv;
    int   iv;
#endif

    if (n <= 0 || n > 3) {
	fprintf(stderr, "plot_gen: dimension != {1,2,3}, case skipped!\n");
	return;
    }

    x = malloc(npoints * sizeof(x[0]));
    wmap = malloc(npoints * sizeof(*wmap));
    w = malloc(nwgts * sizeof(*w));
    if (dim == 1)
	abscissas_1D(D, x, wmap);
    else if (dim == 2)
	abscissas_2D(D, x, wmap);
    else
	abscissas_3D(D, x, wmap);

    sprintf(fn, "quad%d.%s", no++, OUTPUT_VTK && n > 1 ? "vtk" : "dat");
    f = fopen(fn, "w+t");

    if (n == 1) {
	N = 1000;
	d = D0 / N;
	min = 1e10;
	max = 0.;
	for (i = 0; i <= N; i++) {
	    D[n0] = i * d;
	    err = compute_weights(x, w, wmap);
	    if (min > err)
		min = err;
	    if (max < err)
		max = err;
	    /* err = (err > 1.0) ? 1.0 : err */
	    fprintf(f, "%lg %lg\n", (double)D[n0], (double)err);
	    fprintf(stderr, "i=%-4d\r", i);
	    fflush(stdout);
	    fflush(stderr);
	}
	fprintf(stderr, "min: %lg, max: %lg\n", (double)min, (double)max);
	fprintf(stderr, "echo 'plot \"%s\"; pause 1000' | gnuplot\n", fn);
    }
    else if (n == 2) {
	N = 100;
	d = D0 / N;
	min = 1e10;
	max = 0.;
#if OUTPUT_VTK
	fprintf(f, "# vtk DataFile Version 2.0\n\n"
		   "BINARY\nDATASET UNSTRUCTURED_GRID\n"
		   "POINTS %d float\n", (N + 1) * (N + 1));
	for (i = 0; i <= N; i++) {
	    for (j = 0; j <= N; j++) {
		VTK_OUT(i * d, fv); VTK_OUT(j * d, fv); VTK_OUT((FLOAT)0., fv);
	    }
	}
	fprintf(f, "CELLS %d %d\n", N * N * 2, N * N * 2 * 4);
	L = 0;
	for (i = 0; i < N; i++) {
	    for (j = 0; j < N; j++, L++) {
		VTK_OUT(3, iv);
		VTK_OUT(L, iv);
		VTK_OUT(L + 1, iv);
		VTK_OUT(L + N+1, iv);
		VTK_OUT(3, iv);
		VTK_OUT(L + 1 + N+1, iv);
		VTK_OUT(L + 1, iv);
		VTK_OUT(L + N+1, iv);
	    }
	    L++;
	}
	fprintf(f, "CELL_TYPES %d\n", N * N * 2);
	for (i = 0; i < N; i++) {
	    for (j = 0; j < N; j++) {
		VTK_OUT(5, iv); VTK_OUT(5, iv);
	    }
	}
	fprintf(f, "POINT_DATA %d\n"
		   "SCALARS error float 1\n"
		   "LOOKUP_TABLE default\n", (N + 1) * (N + 1));
#endif
	for (i = 0; i <= N; i++) {
	    D[n0] = i * d;
	    for (j = 0; j <= N; j++) {
		D[n0 + 1] = j * d;
		err = compute_weights(x, w, wmap);
		if (min > err)
		    min = err;
		if (max < err)
		    max = err;
		/* err = (err > 1.0) ? 1.0 : err */
#if OUTPUT_VTK
		VTK_OUT(err, fv);
#else
		fprintf(f, "%lg %lg %lg\n", (double)D[n0], (double)D[n0 + 1],
				(double)err);
#endif
		fprintf(stderr, "i=%-4d j=%-4d\r", i, j);
		fflush(stderr);
	    }
#if !OUTPUT_VTK
	    fprintf(f, "\n");
#endif
	}
	fprintf(stderr, "min: %lg, max: %lg\n", (double)min, (double)max);
#if OUTPUT_VTK
	fprintf(stderr, "\"%s\" created.\n", fn);
#else
	fprintf(stderr, "echo 'set pm3d; set mouse; splot \"%s\" with "
			"pm3d; pause mouse' | gnuplot\n", fn);
#endif
    }
    else {
	N = 20;
	d = D0 / N;
	min = 1e10;
	max = 0.;
#if OUTPUT_VTK
	fprintf(f, "# vtk DataFile Version 2.0\n\n"
		   "BINARY\nDATASET UNSTRUCTURED_GRID\n"
		   "POINTS %d float\n", (N + 1) * (N + 1) * (N + 1));
	for (i = 0; i <= N; i++) {
	    for (j = 0; j <= N; j++) {
		for (k = 0; k <= N; k++) {
		    VTK_OUT(i * d, fv);
		    VTK_OUT(j * d, fv);
		    VTK_OUT(k * d, fv);
		}
	    }
	}
	fprintf(f, "CELLS %d %d\n", N * N * N * 5, N * N * N * 5 * 5);
	L = 0;
	for (i = 0; i < N; i++) {
	    for (j = 0; j < N; j++) {
		for (k = 0; k < N; k++, L++) {
#ifdef I
# undef I
#endif
#define I(a,b,c)	L + (N + 1) * ((N + 1) * (a) + (b)) + (c)
		    VTK_OUT(4, iv);
		    VTK_OUT(I(0,0,0), iv); VTK_OUT(I(1,0,0), iv);
		    VTK_OUT(I(0,1,0), iv); VTK_OUT(I(0,0,1), iv);
		    VTK_OUT(4, iv);
		    VTK_OUT(I(1,0,0), iv); VTK_OUT(I(0,1,0), iv);
		    VTK_OUT(I(0,0,1), iv); VTK_OUT(I(1,1,1), iv);
		    VTK_OUT(4, iv);
		    VTK_OUT(I(1,0,0), iv); VTK_OUT(I(0,1,0), iv);
		    VTK_OUT(I(1,1,0), iv); VTK_OUT(I(1,1,1), iv);
		    VTK_OUT(4, iv);
		    VTK_OUT(I(1,0,0), iv); VTK_OUT(I(0,0,1), iv);
		    VTK_OUT(I(1,0,1), iv); VTK_OUT(I(1,1,1), iv);
		    VTK_OUT(4, iv);
		    VTK_OUT(I(0,1,0), iv); VTK_OUT(I(0,0,1), iv);
		    VTK_OUT(I(0,1,1), iv); VTK_OUT(I(1,1,1), iv);
#undef I
	        }
		L++;
	    }
	    L += N + 1;
	}
	fprintf(f, "CELL_TYPES %d\n", N * N * N * 5);
	for (i = 0; i < N; i++) {
	    for (j = 0; j < N; j++) {
		for (k = 0; k < N; k++) {
		    VTK_OUT(10, iv); VTK_OUT(10, iv); VTK_OUT(10, iv);
		    VTK_OUT(10, iv); VTK_OUT(10, iv);
		}
	    }
	}
	fprintf(f, "POINT_DATA %d\n"
		   "SCALARS error float 1\n"
		   "LOOKUP_TABLE default\n", (N + 1) * (N + 1) * (N + 1));
#endif
	for (i = 0; i <= N; i++) {
	    D[n0] = i * d;
	    for (j = 0; j <= N; j++) {
		D[n0 + 1] = j * d;
		for (k = 0; k <= N; k++) {
		    D[n0 + 2] = 0.2 /*k / 100.0*/;
		    err = compute_weights(x, w, wmap);
		    if (min > err)
			min = err;
		    if (max < err)
			max = err;
		    /* err = (err > 1.0) ? 1.0 : err */
#if OUTPUT_VTK
		    VTK_OUT(err, fv);
#else
		    fprintf(f, "%lg %lg %lg\n", (double)D[n0],
					(double)D[n0 + 1], (double)err);
#endif
		    fprintf(stderr, "i=%-4d j=%-4d\r", i, j);
		    fflush(stderr);
		}
	    }
#if !OUTPUT_VTK
	    fprintf(f, "\n");
#endif
	}
	fprintf(stderr, "min: %lg, max: %lg\n", (double)min, (double)max);
#if OUTPUT_VTK
	fprintf(stderr, "\"%s\" created.\n", fn);
#else
	fprintf(stderr, "echo 'set pm3d; set mouse; splot \"%s\" with "
			"pm3d; pause mouse' | gnuplot\n", fn);
#endif
    }
    fclose(f);

    free(x);
    free(wmap);
    free(w);

    return;
}

/*===========================================================================*/
#if USE_MAPPING
/* Use a mapping x=x(y) to transform to an unconstrained problem:
 * 	\min_{y\in \mathbb{R}} F(x(y)) */

#define DELTA	1e-6	/* minimum distance to boundary */

#if 0	/*-------------------- 1/(1+t^2) ------------------------------------*/
# define map_f(x)	(Sqrt(1./(x) - 1.))			/* forward */
# define map_i(y)	(1./(1.+(y)*(y)))			/* inverse */
# define map_d(y)	(-1./Pow(1.+(y)*(y),2)*2.*(y))		/* d/dy */
#elif 1	/*-------------------- 1/(1+e^(-t)) ---------------------------------*/
# define map_f(x)	(-Log(1./(x) - 1.))			/* forward */
# define map_i(y)	(1./(1.+Exp(-(y))))			/* inverse */
# define map_d(y)	(1./Pow(1.+Exp(-(y)),2)*Exp(-(y)))	/* d/dy */
#else	/*-------------------- linear map to (0,1) --------------------------*/
# define map_f(x)	(x)					/* forward */
# define map_i(y)	(y)					/* inverse */
# define map_d(y)	1.0					/* d/dy */
#endif	/*-------------------------------------------------------------------*/

static void 
mapping_x2y(int n, FLOAT x[], FLOAT y[])
/* maps x[]-->y[] (with constrained entries inserted). x and y may overlap. */
{
    int i, k;
    FLOAT t, t0;
    static int initialized = 0;

    if (!initialized) {
	/* check correctness of the functions map_f(), map_i() and map_d() */
	FLOAT a = 1. / (FLOAT)3.;
	initialized = 1;
	t0 = 1. / (FLOAT)4.;
	t = map_f(t0 / a);
	/* Check t0 == map_i(map_f(t0)) */
	if (Fabs(map_i(t) * a - t0) > ACCEPT_TOL) {
	    fprintf(stderr, "error: checking map_i(map_f)==I failed.\n");
	    fprintf(stderr, "(t0=%g, map_i(map_f(t0))=%g, diff=%e)\n",
			(double)t0, (double)(map_i(t) * a),
			(double)(t0 - map_i(t) * a));
#if USE_MPI
	    MPI_Abort(MPI_COMM_WORLD, 1);
#endif	/* USE_MPI */
	    exit(1);
	}
	/* Compare map_d() with finite difference result. */
	t0 = Sqrt((FLOAT)ACCEPT_TOL);
	t0 = (map_i(t + t0) * a - map_i(t - t0) * a) / (t0 + t0);
	if (Fabs(t0 - map_d(t) * a) > Sqrt(ACCEPT_TOL)) {
	    fprintf(stderr, "error: checking map_d() failed.\n");
	    fprintf(stderr, "(FD=%g, map_d=%g, diff=%e)\n",
			(double)t0, (double)(map_d(t) * a),
			(double)(t0 - map_d(t) * a));
#if USE_MPI
	    MPI_Abort(MPI_COMM_WORLD, 1);
#endif	/* USE_MPI */
	    exit(1);
	}
    }

    if (n <= 0)
	return;

#define MAP(a)							\
	if (constraints != NULL && constraints[k].value >= 0.)	\
	    t = x[k] = y[k] = constraints[k].value;			\
	else {							\
	    if (x[k] > (a) - dim*DELTA)				\
		x[k] = (a) - dim*DELTA;				\
	    if (x[k] < DELTA)				\
		x[k] = DELTA;					\
	    t = x[k];						\
	    y[k] = map_f(t / (a));				\
	}							\
	k++;

    k = 0;

    /* transform abscissas */
    if (dim == 1) {
	for (i = 0; i < s11; i++) {
	    MAP(1./(FLOAT)2.)
	}
    }
    else if (dim == 2) {
	for (i = 0; i < s21; i++) {
	    MAP(1./(FLOAT)2.)
	}
	for (i = 0; i < s111; i++) {
	    MAP(1.)
	    t0 = t;
	    MAP(1. - t0)
	}
    }
    else {
	for (i = 0; i < s31; i++) {
	    MAP(1./(FLOAT)3.)
	}
	for (i = 0; i < s22; i++) {
	    MAP(1./(FLOAT)2.)
	}
	for (i = 0; i < s211; i++) {
	    MAP(1./(FLOAT)2.)
	    t0 = t;
	    MAP(1. - 2 * t0)
	}
	for (i = 0; i < s1111; i++) {
	    MAP(1.)
	    t0 = t;
	    MAP(1. - t0)
	    t0 += t;
	    MAP(1. - t0)
	}
    }

    assert(k == n || k == n - nwgts);

    /* transform weights */
    t = 1. / (FLOAT)(dim == 2 ? 2. : 6.);
    for (; k < n; k++) {
	if (x[k] > t - DELTA)
	    x[k] = t - DELTA;
	if (x[k] < DELTA)
	    x[k] = DELTA;
	y[k] = map_f(x[k] / t);
    }

#undef MAP
}

static void 
mapping_y2x(int n, FLOAT y[], FLOAT x[])
/* maps y[]->x[] (with constrained entries inserted). x and y may overlap. */
{
    int i, k;
    FLOAT t;

    if (n <= 0)
	return;

#define MAP(a)							\
	if (constraints != NULL && constraints[k].value >= 0.)	\
	    x[k] = constraints[k].value;				\
	else {							\
	    x[k] = map_i(y[k]) * (a);				\
	    if (x[k] > (a) - dim*DELTA) {			\
		x[k] = (a) - dim*DELTA;				\
		if (x != y)					\
		    y[k] = map_f(x[k] / (a));			\
	    }							\
	    if (x[k] < DELTA) {					\
		x[k] = DELTA;					\
		if (x != y)					\
		    y[k] = map_f(x[k] / (a));			\
	    }							\
	}							\
	k++;

    k = 0;

    /* transform abscissas */
    if (dim == 1) {
	for (i = 0; i < s11; i++) {
	    MAP(1./(FLOAT)2.)
	}
    }
    else if (dim == 2) {
	for (i = 0; i < s21; i++) {
	    MAP(1./(FLOAT)2.)
	}
	for (i = 0; i < s111; i++) {
	    MAP(1.)
	    MAP(1. - x[k - 1])
	}
    }
    else {
	for (i = 0; i < s31; i++) {
	    MAP(1./(FLOAT)3.)
	}
	for (i = 0; i < s22; i++) {
	    MAP(1./(FLOAT)2.)
	}
	for (i = 0; i < s211; i++) {
	    MAP(1./(FLOAT)2.)
	    MAP(1. - 2. * x[k - 1])
	}
	for (i = 0; i < s1111; i++) {
	    MAP(1.)
	    MAP(1. - x[k - 1])
	    MAP(1. - x[k - 1] - x[k - 2])
	}
    }

    assert(k == n || k == n - nwgts);

    /* transform weights */
    t = 1. / (FLOAT)(dim == 2 ? 2. : 6.);
    for (; k < n; k++) {
	y[k] = map_i(x[k]) * t;
	if (y[k] > t - DELTA)
	    y[k] = t - DELTA;
	if (y[k] < DELTA)
	    y[k] = DELTA;
	if (x != y)
	    x[k] = map_f(y[k] / t);
    }

#undef MAP
}

static void
mapping_jac(int n, int m, FLOAT y[/*n*/], FLOAT jac[/*n*/]/*[ld]*/, int ld)
/* updates Jacobian: DF/Dy = DF/Dx * Dx/Dy */
{
    int i, j, k;
    FLOAT a, d11, d21, d22, d31, d32, d33;

    k = 0;

    /* compute Dabsc/Dy */
    if (dim == 1) {
	/*------------------------------ 1D ------------------------------*/
	for (i = 0; i < s11; i++) {
	    if (constraints == NULL || constraints[k].value < 0.) {
		d11 = map_d(y[k]) * (1./(FLOAT)2.);
		for (j = 0; j < m; j++)
		    jac[k * ld + j] *= d11;
	    }
	    k++;
	}
	/*----------------------------------------------------------------*/
    }
    else if (dim == 2) {
	/*------------------------------ 2D ------------------------------*/
	for (i = 0; i < s21; i++) {
	    if (constraints == NULL || constraints[k].value < 0.) {
		d11 = map_d(y[k]) * (1./(FLOAT)2.);
		for (j = 0; j < m; j++)
		    jac[k * ld + j] *= d11;
	    }
	    k++;
	}
	for (i = 0; i < s111; i++) {
	    if (constraints == NULL || constraints[k].value < 0.) {
		a = 1. - map_i(y[k]);
		d11 = map_d(y[k]);
	    }
	    else {
		a = 1. - constraints[k].value;
		d11 = 1.0;
	    }
	    d21 = map_i(y[k + 1]) * (-d11);
	    d22 = map_d(y[k + 1]) * a;
	    for (j = 0; j < m; j++) {
		FLOAT J1 = jac[(k + 0) * ld + j];
		FLOAT J2 = jac[(k + 1) * ld + j];
		jac[(k + 0) * ld + j] = J1 * d11 + J2 * d21;
		jac[(k + 1) * ld + j] = J2 * d22;
	    }
	    k += 2;
	}
	/*----------------------------------------------------------------*/
    }
    else {
	/*------------------------------ 3D ------------------------------*/
	for (i = 0; i < s31; i++) {
	    if (constraints == NULL || constraints[k].value < 0.) {
		d11 = map_d(y[k]) * (1./(FLOAT)3.);
		for (j = 0; j < m; j++)
		    jac[k * ld + j] *= d11;
	    }
	    k++;
	}
	for (i = 0; i < s22; i++) {
	    if (constraints == NULL || constraints[k].value < 0.) {
		d11 = map_d(y[k]) * (1./(FLOAT)2.);
		for (j = 0; j < m; j++)
		    jac[k * ld + j] *= d11;
	    }
	    k++;
	}
	for (i = 0; i < s211; i++) {
	    if (constraints == NULL || constraints[k].value < 0.) {
		a = 1. - 2. * map_i(y[k]) * (1./(FLOAT)2.);
		d11 = map_d(y[k]) * (1./(FLOAT)2.);
	    }
	    else {
		a = 1. - 2. * constraints[k].value;
		d11 = 1.0;
	    }
	    d21 = map_i(y[k + 1]) * (-2. * d11);
	    d22 = map_d(y[k + 1]) * a;
	    for (j = 0; j < m; j++) {
		FLOAT J1 = jac[(k + 0) * ld + j];
		FLOAT J2 = jac[(k + 1) * ld + j];
		jac[(k + 0) * ld + j] = J1 * d11 + J2 * d21;
		jac[(k + 1) * ld + j] = J2 * d22;
	    }
	    k += 2;
	}
	for (i = 0; i < s1111; i++) {
	    if (constraints == NULL || constraints[k].value < 0.) {
		a = 1. - map_i(y[k]);
		d11 = map_d(y[k]);
	    }
	    else {
		a = 1. - constraints[k].value;
		d11 = 1.0;
	    }
	    if (constraints == NULL || constraints[k].value < 0.) {
		d21 = map_i(y[k + 1]) * (-d11);
		d22 = map_d(y[k + 1]) * a;
		a -=  map_i(y[k + 1]) * a;
	    }
	    else {
		d21 = 0.0;
		d22 = 1.0;
		a -= constraints[k + 1].value;
	    }
	    d31 = map_i(y[k + 2]) * (-d11-d21);
	    d32 = map_i(y[k + 2]) * (-d22);
	    d33 = map_d(y[k + 2]) * a;
	    for (j = 0; j < m; j++) {
		FLOAT J1 = jac[(k + 0) * ld + j];
		FLOAT J2 = jac[(k + 1) * ld + j];
		FLOAT J3 = jac[(k + 2) * ld + j];
		jac[(k + 0) * ld + j] = J1 * d11 + J2 * d21 + J3 * d31;
		jac[(k + 1) * ld + j] = J2 * d22 + J3 * d32;
		jac[(k + 2) * ld + j] = J3 * d33;
	    }
	    k += 3;
	}
	/*----------------------------------------------------------------*/
    }

    assert(k == n || k == n - nwgts);

    /* compute DW/Dy */
    a = 1. / (FLOAT)(dim == 2 ? 2. : 6.);
    for (; k < n; k++) {
	d11 = map_d(y[k]) * a;
	for (j = 0; j < m; j++)
	    jac[k * ld + j] *= d11;
    }
}

#endif	/* USE_MAPPING */
/*===========================================================================*/

static int eval_count = 0;

static void
func_eval0(int M, int N, FLOAT X[/*N*/], FLOAT FVEC[/*M*/],
	   FLOAT FJAC[/*N*/]/*[LDFJAC]*/, int LDFJAC)
/* evaluates the function (integration errors) and (optionally) the Jacobian */
{
    /* Note:
     * 	wmap[j] maps the point j to the abscissa wmap[j],
     * 	x[][dim] contains the points,
     * 	xjac[][][dim] stores derivatives with respect to (x,y,z)
     */
    int i, j, k, start, end, *wmap, *pivot = NULL;
    FLOAT (*x)[dim], *w, *A, *DA = NULL, *LU = NULL, d;

#if ASYNCHRONOUS
    static time_t tcurr, tlast = 0;

    if ((tcurr = time(NULL)) - tlast >= 3) {
	tlast = tcurr;
	if (sync_file(CHECK_SYNC_FILE)) {
	    /*printf("Process %d: sync file found, stop.\n", myrank);*/
	    longjmp(jmp, 1);
	}
    }
#endif	/* ASYNCHRONOUS */

#if !USE_MAPPING
    if (Fabs(X[0] - 1.) <= 1e-5 || Fabs(X[0] + 1.) <= 1e-5) {
	FLOAT d = (Fabs(X[0] - 1.) <= 1e-5 ? 1.0 : -1.0);
	/* PETSc's '-snes_type test' uses constant values 1 and -1, which are
	 * invalid abscissas, they are mapped to the interval 0.1*[1,PI] */
	j = 1;
	for (i = 0; i < nabsc; i++) {
	    if (Fabs(X[i] - d) > 1e-5) {
		j = 0;
		break;
	    }
	}
	if (j) {
	    /* d==-1: a=1/10, b=PI/10; d==1: a=PI/10, b=1/10 */
	    FLOAT a = (1. + (PI - 1) * (1.0 + d) * 0.5) * 0.1,
		  b = (1. + (PI - 1) * (1.0 - d) * 0.5) * 0.1;
	    for (i = 0; i < nabsc; i++) {
		X[i] -= d - (a + (b - a) * i / (nabsc < 2 ? 1. : nabsc - 1.));
		/*fprintf(stderr, "X[%d] = %0.16g\n", i, (double)X[i]);*/
	    }
	}
    }
#endif	/* !USE_MAPPING */

    eval_count++;

    assert(M == neqns && M <= npolys_max);
    assert(N == nabsc + nwgts || N == nabsc);

    x = malloc(npoints * sizeof(x[0]));
    wmap = malloc(npoints * sizeof(*wmap));
    (dim == 1 ? abscissas_1D : (dim == 2 ? abscissas_2D : abscissas_3D))
								(X, x, wmap);

    w = (N > nabsc ? X + nabsc : malloc(nwgts * sizeof(*w)));

    /* Evaluate the matrix A and its derivatives DA w.r.t. the abscissas.
     * A[neqns][nwgts] is defined such that FVEC := A*w - 1 */
    computeA(x, wmap, &A, FJAC == NULL ? NULL : &DA);

    /* Factorize A (or A^tA) and compute w[] if needed */
    factorA(A, N > nabsc ? NULL : w, &LU, &pivot);

    free(x);
    free(wmap);

    for (i = 0; i < M; i++) {	/* loop on functions */
	/* Compute function */
	if (FVEC != NULL) {
	    d = -1.0;
	    for (j = 0; j < nwgts; j++)
		d += A[i * nwgts + j] * w[j];
	    FVEC[i] = d;
	}

	if (FJAC == NULL)
	    continue;

	/* Compute Jacobian.
	 * Note the Jacobian may be tested with (NONLINEAR_SOLVER == PETSC):
	 *	quadrule 2 11 28 1 5 2 -- -snes_type test
	 *	quadrule 3 9 83 1 1 1 2 2 -- -snes_type test
	 * (which covers all symmetry orbits).
	 */

	/* Df/Dabsc = DA/Dabsc w */
	for (j = 0; j < nabsc; j++)
	    FJAC[j * LDFJAC + i] = 0.;
	for (k = 0; k < nwgts; k++) {
	    /* DA[dim][i][k] contains start and end numbers of abscissas */
	    j = (int)(DA[(dim*neqns+i)*nwgts+k] + 0.5);
	    start = j / (nabsc + 1);
	    end = j % (nabsc + 1);
	    for (j = 0; start < end; start++, j++)
		FJAC[start * LDFJAC + i] += DA[(j*neqns+i)*nwgts+k] * w[k];
	}

	if (N > nabsc) {
	    /* Weights as independent variables: compute Df/Dw */
	    /* Df/Dw */
	    for (j = 0; j < nwgts; j++)
		FJAC[(nabsc + j) * LDFJAC + i] = A[i * nwgts + j];
	}
    }

    if (FJAC != NULL && N == nabsc) {
	/* Weights as dependent variables: compute Df/Dabsc += A Dw/Dabsc */
	int LD = (neqns >= nwgts ? neqns : nwgts);
	FLOAT *b = malloc(2 * nabsc * LD * sizeof(*b)), *c;
	c = b + nabsc * LD;

	/* A 3D case for debugging the Jacobian: quadrule 3 2 6 0 0 1 0 0:
	 	one s22 orbit, one absc, one weight,
	 	two trial functions:
	 		x^2/60	--> F1(x) = 60*(6*a^2-3*a+3/4)
	 		x y/120	--> F1(x) = 120*(-2*a^2+a+1/4)
	 	(a is the abscissa)
	   If LINEAR_LS != 0, using the BC commands below:
	 	f1=60*(6*a^2-3*a+3/4) 
	 	f2=120*(-2*a^2+a+1/4)
	 	f1p=60*(12*a-3)
	 	f2p=120*(-4*a+1)
	 	w=(f1+f2)/(f1^2+f2^2)
	 	wp=(f1p+f2p-(2*f1*f1p-2*f2*f2p)*w)/(f1^2+f2^2)
	 	fp=2*(f1*w-1)*(f1p*w+wp*f1)+2*(f2*w-1)*(f2p*w+wp*f2)
	   then we should have A=(f1,f2), Dw=wp, DA=(f1p,f2p), FJAC=(fp), etc.
 fprintf(stderr, "a = %0.16g, w = %0.16g\n", (double)X[0], (double)w[0]);
 fprintf(stderr, "A = %0.16g %0.16g\n", (double)A[0], (double)A[1]);
 fprintf(stderr, "DA = %0.16g %0.16g\n", (double)DA[0], (double)DA[1]);
	 --------------------------------------------------------------------*/

	/* First compute Dw/Dabsc */
#if LINEAR_LS
	/* Dw/Dabsc = (A^t A)^(-1) (DA^t rhs - (DA^t A + A^t DA) w
	 * 	    = (A^t A)^(-1) (DA^t (rhs - Aw) - A^t DA w)
	 * 	    = (A^t A)^(-1) (-DA^t f - A^t DA w) */
	/* Step 1: c[neqns] = rhs - Aw (equals to -FVEC[] if FVEC != NULL) */
	for (i = 0; i < neqns; i++) {
	    d = 1.0;
	    for (j = 0; j < nwgts; j++)
		d -= A[i * nwgts + j] * w[j];
	    c[i] = d;
	}
	/* Step 2: b[nwgts] = DA^t c[neqns] */
	bzero(b, nabsc * LD * sizeof(*b));
	for (i = 0; i < neqns; i++) {
	    for (j = 0; j < nwgts; j++) {
		k = (int)(DA[(dim*neqns+i)*nwgts+j] + 0.5);
		start = k / (nabsc + 1);
		end = k % (nabsc + 1);
		for (k = 0; start < end; start++, k++)
		    b[start * LD + j] += DA[(k*neqns+i)*nwgts+j] * c[i];
	    }
	}
	/* Step 3: c[neqns] = DA w[nwgts] */
	bzero(c, nabsc * LD * sizeof(*c));
	for (i = 0; i < neqns; i++) {
	    for (j = 0; j < nwgts; j++) {
		k = (int)(DA[(dim*neqns+i)*nwgts+j] + 0.5);
		start = k / (nabsc + 1);
		end = k % (nabsc + 1);
		for (k = 0; start < end; start++, k++)
		    c[start * LD + i] += DA[(k*neqns+i)*nwgts+j] * w[j];
	    }
	}
	/* Step 4: b[nwgts] -= A^t c[neqns] */
	for (i = 0; i < neqns; i++)
	    for (j = 0; j < nwgts; j++)
		for (k = 0; k < nabsc; k++)
		    b[k * LD + j] -= A[i * nwgts + j] * c[k * LD + i];
	/* Step 5: solve (A^t A) b = b */
	for (k = 0; k < nabsc; k++)
	    ls_solve(nwgts, nwgts, 0, nwgts, LU, pivot, b + k * LD, b + k * LD);
#else	/* LINEAR_LS */
	/* Dw/Dabsc = -A^(-1) DA w */
	/* Step 1: b = -DA w */
	bzero(b, nabsc * LD * sizeof(*c));
	for (i = 0; i < neqns; i++) {
	    for (j = 0; j < nwgts; j++) {
		k = (int)(DA[(dim*neqns+i)*nwgts+j] + 0.5);
		start = k / (nabsc + 1);
		end = k % (nabsc + 1);
		for (k = 0; start < end; start++, k++)
		    b[start * LD + i] -= DA[(k*neqns+i)*nwgts+j] * w[j];
	    }
	}
	/* Step 2: solve A b = b */
	for (k = 0; k < nabsc; k++)
	    ls_solve(neqns, nwgts, 0, nwgts, LU, pivot, b + k * LD, b + k * LD);
#endif

	/* Then compute Df/Dabsc += A Dw/Dabsc */
	for (k = 0; k < nabsc; k++)
	    for (i = 0; i < neqns; i++)
		for (j = 0; j < nwgts; j++)
		    FJAC[k * LDFJAC + i] += A[i * nwgts + j] * b[k * LD + j];

	free(b);
    }

    free(A);
    free(DA);
    free(LU);
    free(pivot);
    if (N == nabsc)
	free(w);
}

static void
func_eval(int M, int N, FLOAT X0[/*N*/], FLOAT FVEC[/*M*/],
	  FLOAT FJAC0[/*N*/]/*[LDFJAC]*/, int LDFJAC)
/* This is a wrapper function for func_eval0(), it expands X[] to its original
 * length by adding back zero abscissas. */
{
    int i, j, k, n;
    FLOAT *X, *FJAC;

#if INDEPENDENT_W
    n = nabsc + nwgts;
#else	/* INDEPENDENT_W */
    n = nabsc;
#endif	/* INDEPENDENT_W */

    if (n == N) {
	/* no constrained variables */
#if USE_MAPPING
	mapping_y2x(n, X0, X0);
	func_eval0(M, n, X0, FVEC, FJAC0, LDFJAC);
	mapping_x2y(n, X0, X0);
	if (FJAC0 != NULL)
	    mapping_jac(n, M, X0, FJAC0, LDFJAC);
#else	/* USE_MAPPING */
	func_eval0(M, n, X0, FVEC, FJAC0, LDFJAC);
#endif	/* USE_MAPPING */
	return;
    }

    assert(constraints != NULL);

    X = malloc(n * sizeof(*X));
    if (FJAC0 != NULL)
	FJAC = malloc(n * M * sizeof(*X));
    else
	FJAC = NULL;

    for (i = j = 0; i < n; i++) {
	if (constraints[i].value < 0.)
	    X[i] = X0[j++];
	else
	    X[i] = constraints[i].value;
    }

#if USE_MAPPING
    mapping_y2x(n, X, X);
    func_eval0(M, n, X, FVEC, FJAC, M);
    mapping_x2y(n, X, X);
    if (FJAC != NULL)
	mapping_jac(n, M, X, FJAC, M);
#else	/* USE_MAPPING */
    func_eval0(M, n, X, FVEC, FJAC, M);
#endif	/* USE_MAPPING */

    free(X);

    if (FJAC0 == NULL)
	return;

    for (i = j = 0; i < n; i++) {
	if (constraints[i].value >= 0.)
	    continue;		/* skip constrained unknowns */
	for (k = 0; k < M; k++)
	    FJAC0[j * LDFJAC + k] = FJAC[i * M + k];
	j++;
    }

    free(FJAC);
}

static void
cb_func0(int *M, int *N, const double *X0/*[N]*/, double FVEC0[/*M*/],
	 double FJAC0[/*N*/]/*[LDFJAC]*/, int *LDFJAC, int *IFLAG)
/* Computes the function values and Jacobian for nonlinear solvers.
 * This function is in the MINPACK's callback function format for lmder1().
 * It is also indirectly called by other solvers (such as PETSc) */
{
#if FT_PHG != FT_DOUBLE
    FLOAT *X, *FVEC = NULL, *FJAC = NULL;
    int i, j;

    X = malloc((*N) * sizeof(*X));
    for (i = 0; i < *N; i++)
	X[i] = X0[i];

    if (FVEC0 != NULL)
	FVEC = malloc((*M) * sizeof(*FVEC));
    if (FJAC0 != NULL)
	FJAC = malloc((*M) * (*N) * sizeof(*FJAC));

    func_eval(*M, *N, X, FVEC, FJAC, *M);

    free(X);
    if (FVEC0 != NULL) {
	for (j = 0; j < *M; j++)
	    FVEC0[j] = FVEC[j];
	free(FVEC);
    }
    if (FJAC0 != NULL) {
	for (i = 0; i < *N; i++)
	    for (j = 0; j < *M; j++)
		FJAC0[i * (*LDFJAC) + j] = FJAC[i * (*M) + j];
	free(FJAC);
    }
#else	/* FT_PHG != FT_DOUBLE */
    func_eval(*M, *N, X0, FVEC0, FJAC0, LDFJAC == NULL ? 0 : *LDFJAC);
#endif	/* FT_PHG != FT_DOUBLE */

    Unused(IFLAG);
}

static void
cb_func(int *M, int *N, const double *X/*[N]*/, double FVEC[/*M*/], int *IFLAG)
/* Computes the function values (but no Jacobian) for nonlinear solvers.
 * This function is in the MINPACK's callback function format for lmder1().
 * It is also indirectly called by other solvers (such as PETSc) */
{
    int zero = 0;

    cb_func0(M, N, X, FVEC, NULL, &zero, IFLAG);
}

static void
cb_func0_n(int *N, const double *X/*[N]*/, double FVEC0[/*N*/],
	   double FJAC0[/*N*/]/*[LDFJAC]*/, int *LDFJAC, int *IFLAG)
/* Computes the function values and Jacobian for nonlinear solvers.
 * This function is in the MINPACK's callback function format for hybrj1().
 * It is also indirectly called by other solvers (such as PETSc).
 *
 * Note: this function is different from cb_func0() in that it requires
 * the number of equations equals to the number of unknowns. */
{
    int M = neqns;
    double *FVEC = NULL, *FJAC = NULL;
    int i, j, k, tmp, size, size0;
    FLOAT d;

    assert(M >= *N);

    if (M == *N) {
	cb_func0(&M, N, X, FVEC0, FJAC0, LDFJAC, IFLAG);
	return;
    }

    /* The case # eqns > # knowns: use sums of subsets of squared equations */

    if (FVEC0 != NULL || FJAC0 != NULL)
	FVEC = malloc(M * sizeof(*FVEC));

    if (FJAC0 != NULL)
	FJAC = malloc(*N * M * sizeof(*FJAC));

    cb_func0(&M, N, X, FVEC, FJAC, &M, IFLAG);

    assert(M > *N);
    size0 = M / *N;
    assert(size0 > 0);

    if (FVEC0 != NULL) {
	for (k = i = 0; i < *N; i++) {
	    d = 0.;
	    size = size0 + (i < (M % *N) ? 1 : 0);
	    for (tmp = k; k < tmp + size; k++)
		d += FVEC[k] * FVEC[k];
	    FVEC0[i] = d;
	}
	assert(k == M);
    }

    if (FJAC != NULL) {
	for (i = 0; i < *N; i++) {
	    for (k = j = 0; j < *N; j++) {
		d = 0.;
		size = size0 + (j < (M % *N) ? 1 : 0);
		for (tmp = k; k < tmp + size; k++)
		    d += 2. * FVEC[k] * FJAC[i * M + k];
		FJAC0[i * (*LDFJAC) + j] = d;
	    }
	}
    }

    if (FVEC != NULL)
	free(FVEC);

    if (FJAC != NULL)
	free(FJAC);
}

static void
cb_func_n(int *N, double X[/*N*/], double FVEC[/*N*/], int *IFLAG)
/* Computes the function values (but no Jacobian) for nonlinear solvers.
 * This function is in the MINPACK's callback function format for hybrd1().
 * It is also indirectly called by other solvers (such as PETSc) */
{
    int zero = 0;

    cb_func0_n(N, X, FVEC, NULL, &zero, IFLAG);
}

/*========================== Genetic Algorithm =========================*/

#if GENETIC

#error This part of the code is unfinished.

/* use GAUL (http://gaul.sourceforge.net/) to improve initial data */

#include "gaul.h"

static boolean
ga_score(population *pop, entity *entity)
{
    int i, m = neqns, n = nabsc;
    double *FVEC, *X = (double *)entity->chromosome[0], error, d;

    for (i = 0; i < n; i++) {
	if (X[i] < 0. || X[i] > 1.) {
	    entity->fitness = -100000.0;
	    return TRUE;
	}
    }

    FVEC = malloc(m * sizeof(*FVEC));
    cb_func(&m, &n, X, FVEC, &i);    

    error = 0.;
    for (i = 0; i < m; i++) {
	if (error < (d = Fabs(FVEC[i])))
	    error = d;
    }

    entity->fitness = - error;
    free(FVEC);

    return TRUE;
}

static boolean
ga_callback(int generation, population *pop)
{
    double error = - /*pop->entity_iarray[0]->fitness*/
		     ga_get_entity_from_rank(pop,0)->fitness;

    printf("%d: fitness = %lg\n", generation, (double)error);

    return error < REPORT_TOL ? FALSE : TRUE;
}

static boolean
ga_seed(population *pop, entity *adam)
{
    if (!pop)
	die("Null pointer to population structure passed.");
    if (!adam)
	die("Null pointer to entity structure passed.");

    /* Seeding */
    abscissas_seed((double *)adam->chromosome[0]);

    return TRUE;
}

static void
genetic(double D[])
{
    static int seeded = 0;
    population *pop;
    int nevol;

    if (nabsc == 0)
	return;

    if (!seeded) {
	seeded = 1;
	random_seed(getpid());
    }

    pop = ga_genesis_double(
	1000,				/* const int population_size */
       	1,				/* const int num_chromo */
       	nabsc,				/* const int len_chromo */
       	ga_callback,			/* GAgeneration_hook generation_hook */
       	NULL,				/* GAiteration_hook iteration_hook */
       	NULL,				/* GAdata_destructor data_destructor */
       	NULL,				/* GAdata_ref_incrementor
						data_ref_incrementor*/
       	ga_score,			/* GAevaluate evaluate */
       	ga_seed,			/* GAseed seed */
       	NULL,				/* GAadapt adapt */
       	ga_select_one_bestof2,		/* GAselect_one select_one */
       	ga_select_two_bestof2,		/* GAselect_two select_two */
       	ga_mutate_double_singlepoint_drift,	/* GAmutate mutate */
       	ga_crossover_double_doublepoints,	/* GAcrossover crossover */
       	NULL,				/* GAreplace replace */
       	NULL				/* vpointer User data */
    );

    ga_population_set_parameters(
	pop,				/* population *pop */
	GA_SCHEME_DARWIN,		/* const ga_scheme_type scheme */
	GA_ELITISM_PARENTS_SURVIVE,	/* const ga_elitism_type elitism */
	0.8,				/* double crossover */
	0.2,				/* double mutation */
	0.0      		        /* double migration */
    );

    if (TRUE) {
	/* Genetic Algorithm */
    	nevol = ga_evolution(pop, 5000);
    }
    else {
	/* Simulated anealing */
	entity *solution;
	ga_population_set_sa_parameters(
	    pop,			/* population *pop */
	    ga_sa_boltzmann_acceptance,	/* GAsa_accept SA acceptance criterion*/
	    100.0,			/* const double	Initial temperature */
	    0.0,		/* const double	Final temperature */
	    10.0,		/* const double	Temperature step size */
	    50			/* const int Temperature update frequency */
	);
	solution = ga_get_entity_from_rank(pop,0);
	nevol = ga_sa(pop, solution, 2000);
    }

    /*fprintf(stderr, "GA stops after %d evolutions, fitness = %le.\n", nevol,
		    (double)ga_get_entity_from_rank(pop,0)->fitness);*/
    memcpy(D, ga_get_entity_from_rank(pop,0)->chromosome[0],
		nabsc * sizeof(*D));

    ga_extinction(pop);
}

#endif	/* GENETIC */

/*========================== End Genetic Algorithm =========================*/

static FLOAT
init_w(FLOAT D[], FLOAT W[])
/* returns the (l2-norm of) the residual */
{
    FLOAT (*x)[dim], error;
    int *wmap;

    /* compute weights using current abscissas */
    x = malloc(npoints * sizeof(x[0]));
    wmap = malloc(npoints * sizeof(wmap[0]));
    if (dim == 1)
	abscissas_1D(D, x, wmap);
    else if (dim == 2)
	abscissas_2D(D, x, wmap);
    else
	abscissas_3D(D, x, wmap);
    error = compute_weights(x, W, wmap);
    free(wmap);
    free(x);

    return error;
}

#if (NONLINEAR_SOLVER == TENSOLVE)
/* See minpack/toms-768/Src/Dp/src.f for TENSOLVE's documentation */

# warning TENSOLVE interface is unfinished and not working!

typedef void (*FCN_TYPE_F)(double X[/*N*/], double F[/*M*/], int *M, int *N);
typedef void (*FCN_TYPE_JAC)(double X[/*N*/], double J[/*N*/]/*[MAXM]*/,
		int *MAXM, int *M, int *N);

static void
func_f(double X[/*N*/], double F[/*M*/], int *M, int *N)
/* Note: M is number of equations, N is number of variables (M >= N) */
{
    int info;

    cb_func(M, N, X, F, &info);
}

static void
func_jac(double X[/*N*/], double JAC[/*N*/]/*[MAXM]*/,
	 int *MAXM, int *M, int *N)
/* Note: M is number of equations, N is number of variables (M >= N) */
{
    int info;

    cb_func0(M, N, X, NULL, JAC, MAXM, &info);
}

static int
oem_solver(int m, int n, FLOAT X[])
{
    extern void tsdflt_(int *M, int *N, int *ITNLIM, int *JACFLG,
			double *GRADTL, double *STEPTL, double *FTOL,
			int *METHOD, int *GLOBAL, double *STEPMX, double *DLT,
			double TYPX[], double TYPF[], int *IPR, int *MSG);
    extern void tsneci_(int *MAXM, int *MAXN, int *MAXP, double X0[],
			int *M, int *N, double TYPX[], double TYPF[],
			int *ITNLIM, int *JACFLG, double *GRADTL,
			double *STEPTL, double *FTOL, int *METHOD, int *GLOBAL,
			double *STEPMX, double *DLT, int *IPR,
			double WRKUNC[], int *LUNC, double WRKNEM[], int *LNEM,
			double WRKNEN[], int *LNEN, int IWRKN[], int *LIN,
			FCN_TYPE_F FVEC, FCN_TYPE_JAC JAC, int *MSG,
			double XP[], double FP[], double GP[], int *TERMCD);
    /*extern FCN_TYPE_JAC tsdumj_;*/
    int		maxm, maxn, maxp;
    int		i, itnlim, jacflg, method,
		global, ipr, lunc, lnem, lnen, lin = 3, msg, termcd;
    double	gradtl, steptl, ftol, stepmx, dlt;
    int		*iwrkn;
    double	*x0, *xp, *fp, *gp, *typx, *typf, *wrknen, *wrkunc, *wrknem;

    Unused(cb_func_n);

    i = (int)(Sqrt((FLOAT)n) + 0.500000001);
    maxn = n + 2;
    maxm = maxn + m;
    maxp = i   + 1;
    lunc = 2 * i + 4   + 1;
    lnem = n + 2 * i + 11   + 1;
    lnen = 2 * i + 9   + 1;

    iwrkn = malloc(maxn * lin * sizeof(*iwrkn));
    x0 = malloc(maxn * sizeof(*x0));
    xp = malloc(maxn * sizeof(*xp));
    fp = malloc(maxm * sizeof(*fp));
    gp = malloc(maxn * sizeof(*gp));
    typx = malloc(maxn * sizeof(*typx));
    typf = malloc(maxm * sizeof(*typf));
    wrknen = malloc(maxn * lnen * sizeof(*wrknen));
    wrkunc = malloc(maxp * lunc * sizeof(*wrkunc));
    wrknem = malloc(maxm * lnem * sizeof(*wrknem));

    tsdflt_(&m, &n, &itnlim, &jacflg, &gradtl, &steptl, &ftol, &method,
	    &global, &stepmx, &dlt, typx, typf, &ipr, &msg);

    for (i = 0; i < n; i++)
	x0[i] = X[i];

    jacflg = 1;
    global = 1;
    stepmx = 1.0;
    dlt = -1.0;

    gradtl = 1.0e-16;
    ftol   = 1.0e-16;
    steptl = 1.0e-16;

    tsneci_(&maxm, &maxn, &maxp, x0, &m, &n, typx, typf, &itnlim, &jacflg,
	    &gradtl, &steptl, &ftol, &method, &global, &stepmx, &dlt, &ipr,
	    wrkunc, &lunc, wrknem, &lnem, wrknen, &lnen, iwrkn, &lin,
	    func_f, func_jac/*tsdumj_*/, &msg, xp, fp, gp, &termcd);

    for (i = 0; i < n; i++)
	X[i] = xp[i];

    free(iwrkn);
    free(x0);
    free(xp);
    free(fp);
    free(gp);
    free(typx);
    free(typf);
    free(wrknen);
    free(wrkunc);
    free(wrknem);

    return 0/*its*/;
}

#elif (NONLINEAR_SOLVER == CCMNF)

#include "ccmnf/ccmNF.h"

static void
ccmnf_cb_func(INT N, INT M, const DOUBLE *X, DOUBLE *F, DOUBLE *JAC)
{
    int flag;

    Unused(M);
    cb_func0_n(&N, X, F, JAC, &N, &flag);
}

static int
oem_solver(int m, int n, FLOAT x[])
/* calls ccmNF to solve the nonlinear equations. */
{
    double *X, *FVEC, *FJAC, tol;
    int i;
    RetTYPE ret;

    Unused(cb_func);
    Unused(cb_func_n);

    assert(m == neqns);

    if (m <= n) {
	neqns = m = n;
	tol = EPS;
    }
    else {
	tol = EPS *EPS;	/* the functions are squared */
    }
    FVEC = malloc(n * sizeof(*FVEC));
    X = malloc(n * sizeof(*X));
    FJAC = malloc(n * n * sizeof(*FJAC));

    for (i = 0; i < n; i++)
	X[i] = x[i];

    ccmNFlow(ccmnf_cb_func, n, n, X, tol, 500, FVEC, FJAC, &ret);
/*fprintf(stderr, "ret = %d (root=%d, singularity=%d, maxit=%d)\n", ret, ROOT, SINGULARITY, MAXIT);*/

    for (i = 0; i < n; i++)
	x[i] = X[i];

    free(X);
    free(FVEC);
    free(FJAC);

    return 0/*its*/;
}

#elif (NONLINEAR_SOLVER == MINPACK)

void
minpack_parms_(int *maxfev, int *nprint)
/* callback function for setting some parameters for lmdif() */
{
    *nprint = 0;
    Unused(maxfev);
#if 0
#if MINPACK_SOLVER == LMDIF
    *maxfev = MINPACK_MAXFEV * (nabsc + 1);
#endif	/* MINPACK_SOLVER == LMDIF */
#endif
}

static int
oem_solver(int m, int n, FLOAT x[])
/* calls MINPACK functions to solve the nonlinear equations. */
{
    int ldfjac, info, lwa, *IPVT;
    double *X, *FVEC, *FJAC, *WA, tol;
    int i;

    assert(m == neqns);

#if (MINPACK_SOLVER == HYBRD) || (MINPACK_SOLVER == HYBRJ)
    if (m <= n) {
	neqns = m = n;
	tol = EPS;
    }
    else {
	tol = EPS *EPS;	/* the functions are squared */
    }
    ldfjac = n;
    lwa = n * (3 * n + 13) / 2;	/* work array size for hybrj1()/hybrd1() */
    FVEC = malloc(n * sizeof(*FVEC));
#else	/* MINPACK_SOLVER */
    tol = EPS;
    ldfjac = m;
    lwa = 5 * n + m + n * m;	/* work array size for lmder1() and lmdif1() */
    FVEC = malloc(m * sizeof(*FVEC));
#endif	/* MINPACK_SOLVER */
    X = malloc(n * sizeof(*X));
    FJAC = malloc(ldfjac * n * sizeof(*FJAC));
    IPVT = malloc(n * sizeof(*IPVT));
    WA = malloc(lwa * sizeof(*WA));

    for (i = 0; i < n; i++)
	X[i] = x[i];

    Unused(ldfjac);	/* avoid gcc warning when using lmdif1 */
#if MINPACK_SOLVER == LMDIF
    {
	extern void lmdif1_(void *fcn, int *m, int *n, double x[],
			    double fvec[], double *tol, int *info,
			    int iwa[], double wa[], int *lwa);
	Unused(cb_func_n);
	lmdif1_(cb_func, &m, &n, X, FVEC, &tol, &info, IPVT, WA, &lwa);
    }
#elif MINPACK_SOLVER == LMDER
    {
	extern void lmder1_(void *fcn, int *m, int *n, double x[],
			    double fvec[], double fjac[], int *ldfjac,
			    double *tol, int *info, int ipvt[],
			    double wa[], int *lwa);
	Unused(cb_func);
	Unused(cb_func_n);
	lmder1_(cb_func0, &m, &n, X, FVEC, FJAC, &ldfjac, &tol, &info,
		IPVT, WA, &lwa);
    }
#elif MINPACK_SOLVER == HYBRD
    {
	extern void hybrd1_(void *fcn, int *n, double x[],
			    double fvec[], double *tol, int *info,
			    double wa[], int *lwa);
	Unused(cb_func);
	hybrd1_(cb_func_n, &n, X, FVEC, &tol, &info, WA, &lwa);
    }
#elif MINPACK_SOLVER == HYBRJ
    {
	extern void hybrj1_(void *fcn, int *n, double x[],
			    double fvec[], double fjac[], int *ldfjac,
			    double *tol, int *info, double wa[], int *lwa);
	Unused(cb_func);
	Unused(cb_func_n);
	hybrj1_(cb_func0_n, &n, X, FVEC, FJAC, &ldfjac, &tol, &info, WA, &lwa);
    }
#else	/* MINPACK_SOLVER */
# error invalid MINPACK_SOLVER setting
#endif	/* MINPACK_SOLVER */

    for (i = 0; i < n; i++)
	x[i] = X[i];

    free(X);
    free(FVEC);
    free(FJAC);
    free(IPVT);
    free(WA);

    return 0/*its*/;
}

#elif (NONLINEAR_SOLVER == PETSC)

#if (PETSC_VERSION_MAJOR==3 && PETSC_VERSION_MINOR>=3) || PETSC_VERSION_MAJOR>3
# define MatCreateMPIAIJ	MatCreateAIJ
# define MatCreateMPIBAIJ	MatCreateBAIJ
# define MatCreateMPISBAIJ	MatCreateSBAIJ
# define MatCreateMPIDense	MatCreateDense
#endif

#define PETSC_DENSE_MATRIX 1

static struct {
    int n, m;
    double *x, *f, *fjac;
} ctx;

PetscErrorCode
petsc_func(SNES snes, Vec x, Vec f, void *dummy)
{
    int i, info;
    PetscErrorCode ierr;
    PetscScalar *xx, *ff;

    ierr = VecGetArray(x, &xx); CHKERRQ(ierr);
    ierr = VecGetArray(f, &ff); CHKERRQ(ierr);

    for (i = 0; i < ctx.n; i++)
	ctx.x[i] = xx[i];

    cb_func_n(&ctx.n, ctx.x, ctx.f, &info);

    for (i = 0; i < ctx.n; i++)
	ff[i] = ctx.f[i];

    ierr = VecRestoreArray(x, &xx); CHKERRQ(ierr);
    ierr = VecRestoreArray(f, &ff); CHKERRQ(ierr); 

    return 0;
}

PetscErrorCode
petsc_fjac(SNES snes, Vec x, Mat *jac, Mat *B, MatStructure *flag, void *dummy)
/* Computes the Jacobian for PETSc SNES (jac[i][j] = DF_i / Dx_j).
 * Note:
 *   1. The analytic Jacobian may be verified against the finite difference
 *	Jacobian using the options:
 * 		-snes_type test [-snes_test_display]
 *   2. To force PETSc to use finite difference Jacobian:
 *   		-snes_fd
 */
{
    int i, j, info;
    PetscScalar *xx, *a;
    PetscErrorCode ierr;

    ierr = VecGetArray(x, &xx); CHKERRQ(ierr);

#if PETSC_DENSE_MATRIX
    ierr = /*MatGetArray*/MatSeqAIJGetArray(*B, &a); CHKERRQ(ierr);
#else	/* PETSC_DENSE_MATRIX */
    a = malloc(ctx.n * sizeof(*a) * ctx.n );
#endif	/* PETSC_DENSE_MATRIX */

    for (i = 0; i < ctx.n; i++)
	ctx.x[i] = xx[i];

    cb_func0_n(&ctx.n, ctx.x, ctx.f, ctx.fjac, &ctx.m, &info);

    for (i = 0; i < ctx.n; i++) {
	for (j = 0; j < ctx.n; j++) {
#if PETSC_DENSE_MATRIX
	    a[i * ctx.n + j] = ctx.fjac[i * ctx.m + j];
#else	/* PETSC_DENSE_MATRIX */
	    a[i + j * ctx.n] = ctx.fjac[i * ctx.m + j];
#endif	/* PETSC_DENSE_MATRIX */
	}
    }

#if PETSC_DENSE_MATRIX
    ierr = /*MatRestoreArray*/MatSeqAIJRestoreArray(*B, &a); CHKERRQ(ierr);
#else	/* PETSC_DENSE_MATRIX */
    {
	PetscInt *idx;
	idx = malloc(ctx.n * sizeof(*idx));
	for (i = 0; i < ctx.n; i++)
	    idx[i] = i;
	ierr = MatSetValues(*B, ctx.n, idx, ctx.n, idx, a, INSERT_VALUES);
	CHKERRQ(ierr);
	free(idx);
	free(a);
	*flag = SAME_NONZERO_PATTERN;
    }
#endif	/* PETSC_DENSE_MATRIX */

    ierr = VecRestoreArray(x, &xx); CHKERRQ(ierr);

    ierr = MatAssemblyBegin(*B, MAT_FINAL_ASSEMBLY); CHKERRQ(ierr);
    ierr = MatAssemblyEnd(*B, MAT_FINAL_ASSEMBLY); CHKERRQ(ierr);

    if (*jac != NULL && *jac != *B){
	ierr = MatAssemblyBegin(*jac, MAT_FINAL_ASSEMBLY); CHKERRQ(ierr);
	ierr = MatAssemblyEnd(*jac, MAT_FINAL_ASSEMBLY); CHKERRQ(ierr);
    }  

    return 0;
}

#if PETSC_DENSE_MATRIX
static PetscErrorCode
# if PETSC_VERSION_MAJOR<3 || (PETSC_VERSION_MAJOR==3 && PETSC_VERSION_MINOR<1)
shell_pc(void *pmat, Vec vx, Vec vy)
# else	/* PETSc version <= 3.1 */
shell_pc(PC pc, Vec vx, Vec vy)
# endif	/* PETSC_VERSION_MAJOR <= 3.1 */
{
    FLOAT *A;
    PetscScalar *x, *y, *a0, d, r;
    PetscInt i, j, k, p, q, n, code, perm[ctx.n];
# if PETSC_VERSION_MAJOR>3 || (PETSC_VERSION_MAJOR==3 && PETSC_VERSION_MINOR>0)
    void *pmat;
    PCShellGetContext(pc, &pmat);
# endif	/* ! (PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR < 1) */

    n = ctx.n;
    code = VecGetArray(vy, &y); CHKERRQ(code);
    code = VecGetArray(vx, &x); CHKERRQ(code);
    code = MatSeqAIJGetArray(*(Mat *)pmat, &a0); CHKERRQ(code);
    memcpy(y, x, n * sizeof(*x));
    A = malloc(n * sizeof(*A) * n);
    for (i = 0; i < n * n; i++)
	A[i] = a0[i];
    code = MatSeqAIJRestoreArray(*(Mat *)pmat, &a0); CHKERRQ(code);
    code = VecRestoreArray(vx, &x); CHKERRQ(code);

    /*------------------- Solve Ay := y -----------------*/
#define a(i,j)	(A[(i) + (j) * n])
    for (i = 0; i < n; i++) {
	d = Fabs(a(i,i));
	p = q = i;
	for (j = i + 1; j < n; j++) {
	    for (k = i; k < n; k++) {
		if ((r = Fabs(a(j,i))) > d) {
		    d = r;
		    p = j;
		    q = k;
		}
	    }
	}
	if (d == 0.0) {
	    /* zero pivot */
	    /*fprintf(stderr, "Warning: zero pivot in pc_shell!\n");*/
	    for (; i < n; i++) {
		perm[i] = i;
		y[i] = 0.0;
	    }
	    break;
	}
	if (p != i) {
	    /* exchange row i with row p */
	    for (j = i; j < n; j++) {
		d = a(i,j);
		a(i,j) = a(p,j);
		a(p,j) = d;
	    }
	    d = y[i];
	    y[i] = y[p];
	    y[p] = d;
	}
	perm[i] = q;
	if (q != i) {
	    /* exchange column i with column q */
	    for (j = i; j < n; j++) {
		d = a(j, i);
		a(j, i) = a(j,p);
		a(j,p) = d;
	    }
	}
	if ((d = a(i,i)) != 1.0) {
	    d = 1.0 / d;
	    for (j = i + 1; j < n; j++)
		a(i,j) *= d;
	    y[i] *= d;
	}
	for (j = i + 1; j < n; j++) {
	    if ((d = a(j,i)) == 0.0)
		continue;
	    for (k = i + 1; k < n; k++)
		a(j,k) -= d * a(i,k);
	    y[j] -= d * y[i];
	}
    }

    for (i = n - 2; i >= 0; i--)
	for (j = i + 1; j < n; j++)
	    y[i] -= a(i,j) * y[j];

    /* permute the solution */
    for (i = n - 1; i >= 0; i--) {
	if ((q = perm[i]) == i)
	    continue;
	d = y[i];
	y[i] = y[q];
	y[q] = d;
    }
#undef a
    /*-----------------------------------------------------------------------*/

    free(A);
    code = VecRestoreArray(vy, &y); CHKERRQ(code);

    return 0;
}
#endif	/* PETSC_DENSE_MATRIX */

static int
oem_solver(int m, int n, FLOAT X[])
/* use PETSc SNES to solve the nonlinear equations */
{
    int i;

    SNES		snes;	/* nonlinear solver context */
    KSP			ksp;	/* linear solver context */
    PC			pc;	/* preconditioner context */
    Vec			x, r;	/* solution, residual vectors */
    Mat			J;	/* Jacobian matrix */
    PetscScalar		*xx;
    PetscErrorCode	ierr;
    PetscInt		its;

    Unused(cb_func);

    ctx.n = n;		/* # unknowns */
    ctx.m = m;		/* # equations */

    if (ctx.m < ctx.n) {
	/* add equations from [npolys..npolys_max] to make # DOF == # eqns */
	assert(m == neqns);
	neqns = ctx.m = m = ctx.n;
    }

    ctx.x = malloc(n * sizeof(*ctx.x));
    ctx.f = malloc(ctx.m * sizeof(*ctx.f));
    ctx.fjac = malloc(ctx.m * n * sizeof(*ctx.fjac));

    /* Create nonlinear solver context */
    ierr = SNESCreate(PETSC_COMM_SELF, &snes); CHKERRQ(ierr);

    /* Create vectors for solution and nonlinear function */
    ierr = VecCreate(PETSC_COMM_SELF, &x); CHKERRQ(ierr);
    ierr = VecSetSizes(x,PETSC_DECIDE, n); CHKERRQ(ierr);
    ierr = VecSetFromOptions(x); CHKERRQ(ierr);
    ierr = VecDuplicate(x, &r); CHKERRQ(ierr);

    /* Create Jacobian matrix data structure */
#if PETSC_DENSE_MATRIX
    /*ierr = MatCreateSeqDense(PETSC_COMM_SELF, n, n, NULL, &J);*/
    ierr = MatCreateMPIDense(PETSC_COMM_SELF, n, n, n, n, NULL, &J);
    CHKERRQ(ierr);
#else	/* PETSC_DENSE_MATRIX */
    {
	PetscInt *d_nnz, *o_nnz;
	d_nnz = malloc(n * sizeof(*d_nnz));
	o_nnz = malloc(n * sizeof(*o_nnz));
	for (i = 0; i < n; i++) {
	    d_nnz[i] = n;
	    o_nnz[i] = 0;
	}
	ierr = MatCreateMPIAIJ(PETSC_COMM_SELF, n, n, n, n,
		PETSC_DECIDE, d_nnz, PETSC_DECIDE, o_nnz, &J); CHKERRQ(ierr);
	free(o_nnz);
	free(d_nnz);
    }
#endif	/* PETSC_DENSE_MATRIX */
    /*ierr = MatSetFromOptions(J); CHKERRQ(ierr);*/

    /* Set function evaluation routine and vector. */
    ierr = SNESSetFunction(snes, r, petsc_func, PETSC_NULL); CHKERRQ(ierr);

    /* Set Jacobian matrix data structure and Jacobian evaluation routine */
    ierr = SNESSetJacobian(snes, J, J, petsc_fjac, PETSC_NULL); CHKERRQ(ierr);

    /* Set convergence criterioni (atol, rtol, stol) */
    if (ctx.m > ctx.n) {
	/* Note: the equations are squared */
	ierr = SNESSetTolerances(snes, ACCEPT_TOL * ACCEPT_TOL,
				 0., 0., 100, 1000);
    }
    else {
	ierr = SNESSetTolerances(snes, ACCEPT_TOL, 0., 0., 100, 1000);
    }
    CHKERRQ(ierr);

    /* Set linear solver defaults for this problem. */
    ierr = SNESGetKSP(snes, &ksp); CHKERRQ(ierr);
    ierr = KSPSetTolerances(ksp, 0., 0., 0., 1); CHKERRQ(ierr);
    ierr = KSPSetType(ksp, KSPPREONLY); CHKERRQ(ierr);
    ierr = KSPGetPC(ksp, &pc); CHKERRQ(ierr);
#if PETSC_DENSE_MATRIX
    ierr = PCSetType(pc, PCSHELL); CHKERRQ(ierr);
# if PETSC_VERSION_MAJOR < 2 || \
    (PETSC_VERSION_MAJOR == 2 && PETSC_VERSION_MINOR < 2)
	PCShellSetApply(pc, shell_pc, &J);
# else	/* PETSC_VERSION_MAJOR < 2 || ... */
	PCShellSetContext(pc, &J);
	PCShellSetApply(pc, shell_pc);
# endif	/* PETSC_VERSION_MAJOR < 2 || ... */
#else	/* PETSC_DENSE_MATRIX */
    ierr = PCSetType(pc, PCLU); CHKERRQ(ierr);
    ierr = PCFactorSetMatSolverPackage(pc, MATSOLVERMUMPS); CHKERRQ(ierr);
#endif	/* PETSC_DENSE_MATRIX */

    /* Set line search type.
     * Note: seems to be reset by SNESSetFromOptions (PETSc bug?)) */
#if (PETSC_VERSION_MAJOR==3 && PETSC_VERSION_MINOR>=3) || PETSC_VERSION_MAJOR>3
{
    SNESLineSearch linesearch;
    ierr = SNESGetSNESLineSearch(snes, &linesearch); CHKERRQ(ierr);
    ierr = SNESLineSearchSetType(linesearch, "basic"); CHKERRQ(ierr);
}
#else	/* Petsc <= 3.2 */
    ierr = SNESLineSearchSet(snes, SNESLineSearchNo, PETSC_NULL); CHKERRQ(ierr);
#endif	/* Petsc <= 3.2 */

    /* Set SNES/KSP/KSP/PC runtime options */
    ierr = SNESSetFromOptions(snes); CHKERRQ(ierr);

    /* Set initial guess */
    ierr = VecGetArray(x, &xx); CHKERRQ(ierr);
    for (i = 0; i < n; i++)
	xx[i] = X[i];
    ierr = VecRestoreArray(x, &xx); CHKERRQ(ierr);

    /* Solve nonlinear system */
    ierr = SNESSolve(snes, PETSC_NULL, x); CHKERRQ(ierr);
    ierr = SNESGetIterationNumber(snes, &its); CHKERRQ(ierr);

    ierr = VecGetArray(x, &xx); CHKERRQ(ierr);
    for (i = 0; i < n; i++)
	X[i] = xx[i];
    ierr = VecRestoreArray(x, &xx); CHKERRQ(ierr);

#if PETSC_VERSION_MAJOR > 3 || \
    (PETSC_VERSION_MAJOR == 3 && PETSC_VERSION_MINOR >= 2)
    ierr = VecDestroy(&x); CHKERRQ(ierr);
    ierr = VecDestroy(&r); CHKERRQ(ierr);
    ierr = MatDestroy(&J); CHKERRQ(ierr);
    ierr = SNESDestroy(&snes); CHKERRQ(ierr);
#else
    ierr = VecDestroy(x); CHKERRQ(ierr);
    ierr = VecDestroy(r); CHKERRQ(ierr);
    ierr = MatDestroy(J); CHKERRQ(ierr);
    ierr = SNESDestroy(snes); CHKERRQ(ierr);
#endif

    free(ctx.x);
    free(ctx.f);
    free(ctx.fjac);

    return its;
}

#elif (NONLINEAR_SOLVER == GSLSIMAN)

#if INDEPENDENT_W
# error GSL_SIMAN requires INDEPENDENT_W==0
#endif	/* INDEPENDENT_W */

/* Use the simulated annealing function from GSL (GNU Scientific Library) */

#include <gsl/gsl_siman.h>

static int gsl_siman_m;	/* # of equations */ 
static int gsl_siman_n;	/* # of unknowns */ 

static double
gsl_siman_E(void *xp)
/* returns the energy for the configuration xp */
{
    int i;
    double error, d;
    FLOAT *fvec = malloc(gsl_siman_m * sizeof(*fvec));

    func_eval(gsl_siman_m, gsl_siman_n, xp, fvec, NULL, gsl_siman_m);

    error = 0.;
    for (i = 0; i < gsl_siman_m; i++)
	if (error < (d = Fabs(fvec[i])))
	    error = d;

    free(fvec);

    return error;
}

static double
gsl_siman_M(void *xp, void *yp)
/* returns the distance between the configurations xp and yp */
{
    int i;
    FLOAT d, *x = xp, *y = yp;

    d = 0.0;
    for (i = 0; i < gsl_siman_n; i++)
	d += Fabs(x[i] - y[i]);

    return (double)d;
}

static void
gsl_siman_S(const gsl_rng *r, void *xp, double step_size)
/* modifies the configuration xp using a random step taken from the generator r,
 * up to a maximum distance of step_size */
{
    int i;
    FLOAT *D = malloc(nabsc * sizeof(*D)), *x;

    if (nabsc == 0)
	return;

#if 0
    /* regenerate a new set of all stars */
    abscissas_seed(D);
#else
    /* expand the unknowns to abscissas array */
    for (x = xp, i = 0; i < nabsc; i++) {
	if (constraints == NULL || constraints[i].value < 0.0)
	    D[i] = *(x++);
	else
	    D[i] = 0.0;
    }
    if (dim == 1) {
	i = (int)(gsl_rng_uniform(r) * s11);
	/* alter the i-th star */
	if (i < s11)
	    seed11(1, D + i);
    }
    else if (dim == 2) {
	i = (int)(gsl_rng_uniform(r) * (s21 + s111));
	/* alter the i-th star */
	if (i < s21)
	    seed21(1, D + i);
	else if ((i -= s21) < s111)	/* Note: always true */
	    seed111(1, D + s21 + 2 * i);
    }
    else {
	i = (int)(gsl_rng_uniform(r) * (s31 + s22 + s211 + s1111));
	if (i < s31)
	    seed31(1, D + i);
	else if ((i -= s31) < s22)
	    seed22(1, D + s31 + i);
	else if ((i -= s22) < s211)
	    seed211(1, D + s31 + s22 + 2 * i);
	else if ((i -= s211) < s1111)	/* Note: always true */
	    seed1111(1, D + s31 + s22 + 2 * s211 + 3 * i);
    }
#endif

    for (x = xp, i = 0; i < nabsc; i++)
	if (constraints == NULL || constraints[i].value < 0.0)
	   *(x++) = D[i];
    free(D);
}

static void
gsl_siman_P(void *xp)
/* prints the condifuration xp */
{
    Unused(xp);
    Unused(gsl_siman_P);
    /* do nothing */
}

static int
oem_solver(int m, int n, FLOAT x[])
/* calls gsl_siman_solve() to solve the nonlinear equations. */
{
    static int initialized = 0;
    static const gsl_rng_type *T;
    static gsl_rng *r;
    static gsl_siman_params_t params = {
	100,	/* points to try before stepping (NTRIES) */
	2000,	/* iterations for each T (ITERS_FIXED_T) */
	0.0,	/* stepsize */
	0.5,	/* Boltzmann constant K */
	1e-2,	/* initial temperature */
	1.005,	/* damping factor for temperature */
	1e-4	/* T_min */
    };

    Unused(cb_func);
    Unused(cb_func_n);

    if (!initialized) {
	initialized = 1;
	T = gsl_rng_default;
	r = gsl_rng_alloc(T);
    }

    gsl_siman_m = m;
    gsl_siman_n = n;
    gsl_siman_solve(r, x, gsl_siman_E, gsl_siman_S, gsl_siman_M, gsl_siman_P,
			NULL, NULL, NULL, n * sizeof(*x), params);

    return 0/*its*/;
}

#elif (NONLINEAR_SOLVER != NEWTON)
# error invalid value of the NONLINEAR_SOLVER macro!
#endif	/* (NONLINEAR_SOLVER == ...) */

static int
setup_constraints(int n, int count_only)
/* sets up the constrained unknowns.
 * returns the number of constrained unknowns, or -1 if the constraints can't
 * be satisfied by the current orbits setting. */
{
    int i, count = 0;
    CONSTRAINTS *p, *q;

/* check that total # orbits >= # constrained orbits */
#define check(cond, orbit) \
    if (!count_only && !(cond)) { \
	if (myrank == 0) \
	    fprintf(stderr, "Constraint %s can't be met, skipped\n", orbit); \
	return -1; \
    }

/* add predefined orbits to constraints[] */
#define predefined_orbits(u) \
    for (i = 0; q != NULL && i < stars[u].cnt * stars[u].nargs; i++, q++) { \
	(*q).value = stars[u].args[i].farg; \
	(*q).expr = stars[u].args[i].sarg; \
    } \
    count += stars[u].cnt * stars[u].nargs;

    if (constraints != NULL) {
	free(constraints);
	constraints = NULL;
    }

    if (!have_predefined_orbits &&
	((dim == 1 && r11 == 0) ||
	 (dim == 2 && r21 + r111 == 0) ||
	 (dim == 3 && r31 + r22 + r211f + r211e + r1111 == 0))) {
	return 0;
    }

    if (!count_only && n > 0) {
	constraints = malloc(n * sizeof(*constraints));
	for (i = 0; i < n; i++) {
	    constraints[i].value = -1.0;
	    constraints[i].expr = NULL;
	}
    }
    p = constraints;

    /*---------------------------------- 1D ------------------------------*/
    if (dim == 1) {
	/* perm11 */
	q = p;
	check(stars[u11].cnt <= s11, "u11");
	predefined_orbits(u11);
	/* r11 */
	if (r11 == 1) {
	    /* one orbit (1,0) */
	    check(s11 - stars[u11].cnt >= 1, "r11");
	    if (q != NULL)
		(*(q++)).value = 0.;
	    count++;
	}
	if (p != NULL)
	    p += s11;

	return count;
    }

    /*---------------------------------- 2D ------------------------------*/
    if (dim == 2) {
	/* perm21 */
	q = p;
	check(stars[u21].cnt <= s21, "u21");
	predefined_orbits(u21);
	/* r21 */
	switch (r21) {
	    case 0:	/* do nothing */
		break;
	    case 1:	/* one orbit (1,0,0) */
		check(s21 - stars[u21].cnt >= 1, "r21");
		if (q != NULL)
		    (*(q++)).value = 0.;
		count++;
		break;
	    case 2:	/* one orbit (1/2,1/2,0) */
		check(s21 - stars[u21].cnt >= 1, "r21");
		if (q != NULL)
		    (*(q++)).value = .5;
		count++;
		break;
	    case 3:	/* two orbits: (1/2,1/2,0) and (1,0,0) */
		check(s21 - stars[u21].cnt >= 2, "r21");
		if (q != NULL) {
		    (*(q++)).value = .5;
		    (*(q++)).value = 0.;
		}
		count += 2;
		break;
	    default:
		if (myrank == 0)
		    fprintf(stderr, "invalid value of r21: %d\n", r21);
#if USE_MPI
		sync_file(REMOVE_SYNC_FILE);
		MPI_Abort(MPI_COMM_WORLD, 1);
#endif	/* USE_MPI */
		exit(1);
	}
	if (p != NULL)
	    p += s21;

	/* perm111 */
	q = p;
	check(stars[u111].cnt <= s111, "u111");
	predefined_orbits(u111);
	/* r111 is the number of orbits (a,1-a,0) */
	check(s111 - stars[u111].cnt >= r111, "r111");
	if (p != NULL) {
	    for (i = 0; i < r111; i++) {
		(*q).value = 0.; /* set one of the two abscissas to zero */
		q += 2;
	    }
	    p += 2 * s111;
	    assert(p == constraints + nabsc);
	}
	count += r111;

	return count;
    }

    /*---------------------------------- 3D ------------------------------*/

    /* perm31 */
    q = p;
    check(stars[u31].cnt <= s31, "u31");
    predefined_orbits(u31);
    /* r31 */
    switch (r31) {
	case 0:		/* do nothing */
	    break;
	case 1:		/* one orbit (1,0,0,0) */
	    check(s31 - stars[s31].cnt >= 1, "r31");
	    if (q != NULL)
		(*(q++)).value = 0.;
	    count++;
	    break;
	case 2:		/* one orbit (1/3,1/3,1/3,0) */
	    check(s31 - stars[s31].cnt >= 1, "r31");
	    if (q != NULL)
		(*(q++)).value = 1. / (FLOAT)3.;
	    count++;
	    break;
	case 3:		/* two orbits (1/3,1/3,1/3,0) and (1,0,0,0) */
	    check(s31 - stars[s21].cnt >= 2, "r31");
	    if (q != NULL) {
		(*(q++)).value = 1. / (FLOAT)3.;
		(*(q++)).value = 0.;
	    }
	    count += 2;
	    break;
	default:
	    if (myrank == 0)
		fprintf(stderr, "invalid value of r31: %d\n", r31);
#if USE_MPI
	    sync_file(REMOVE_SYNC_FILE);
	    MPI_Abort(MPI_COMM_WORLD, 1);
#endif	/* USE_MPI */
	    exit(1);
    }
    if (p != NULL)
	p += s31;

    /* perm22 */
    q = p;
    check(stars[u22].cnt <= s22, "u22");
    predefined_orbits(u22);
    /* r22 */
    switch (r22) {
	case 0:		/* do nothing */
	    break;
	case 1:		/* one orbit (1/2,1/2,0,0) */
	    check(s22 - stars[u22].cnt >= 1, "r22");
	    if (q != NULL)
		(*(q++)).value = .5;
	    count++;
	    break;
	default:
	    if (myrank == 0)
		fprintf(stderr, "invalid value of r22: %d\n", r22);
#if USE_MPI
	    sync_file(REMOVE_SYNC_FILE);
	    MPI_Abort(MPI_COMM_WORLD, 1);
#endif	/* USE_MPI */
	    exit(1);
    }
    if (p != NULL)
	p += s22;

    /* perm211 */
    q = p;
    check(stars[u211].cnt <= s211, "u211");
    predefined_orbits(u211);
    /* r211e is the number of orbits (a,1-a,0,0) and
     * r211f  is the number of orbits (a,a,1-2a,0) */
    check(s211 - stars[u211].cnt >= r211f + r211e, "r211f and r211e");
    if (p != NULL) {
	for (i = 0; i < r211e; i++) {
	    (*q).value = 0.;	/* set the 1st of the two abscissas to zero */
	    q += 2;
	}
	for (; i < r211e + r211f; i++) {
	    q[1].value = 0.;	/* set the 2nd of the two abscissas to zero */
	    q += 2;
	}
	p += 2 * s211;
    }
    count += r211f + r211e;

    /* perm1111 */
    q = p;
    check(stars[u1111].cnt <= s1111, "u1111");
    predefined_orbits(u1111);
    /* r1111 is the number of orbits (a,b,1-a-b,0) */
    check(s1111 - stars[u1111].cnt >= r1111, "r1111");
    if (p != NULL) {
	for (i = 0; i < r1111; i++) {
	    (*q).value = 0.;	/* set the 1st of the three abscissas to zero */
	    q += 3;
	}
	p += 3 * s1111;
	assert(p == constraints + nabsc);
    }
    count += r1111;

#undef check
    return count;
}

static int
newton_solver(int m, int n, FLOAT X[])
{
    int i, its, *pivot_ptr = NULL;
    FLOAT *F, *FJAC, *DX, d;
#if LINEAR_LS
    int j, k;
    FLOAT *A = malloc(n * n * sizeof(*FJAC));
#endif	/* LINEAR_LS */

    F = malloc(m * sizeof(*F));
    FJAC = malloc(n * m * sizeof(*FJAC));
    DX = malloc(n * sizeof(*F));

    for (its = 0; its <= 20; its++) {
	func_eval(m, n, X, F, FJAC, m);
	d = 0.;
	for (i = 0; i < m; i++)
	    d += F[i] * F[i];
	d = Sqrt(d);
	/*fprintf(stderr, "\tNewton step %d: error = %g\n", its, (double)d);*/
	if (d < ACCEPT_TOL)
	    break;
#if LINEAR_LS
	/* solve FJAC^t FJAC DX = FJAC F */
	for (i = 0; i < n; i++) {
	    for (j = i; j < n; j++) {
		d = 0.;
		for (k = 0; k < m; k++)
		    d += FJAC[i * m + k] * FJAC[j * m + k];
		A[i * n + j] = A[j * n + i] = d;
	    }
	    d = 0.;
	    for (k = 0; k < m; k++)
		d += FJAC[i * m + k] * F[k];
	    DX[i] = d;
	}
	ls_factor(n, n, 0, n, A, &pivot_ptr);
	ls_solve(n, n, 0, n, A, pivot_ptr, DX, DX);
#else	/* LINEAR_LS */
	ls_factor(m, n, 1, m, FJAC, &pivot_ptr);
	ls_solve(m, n, 1, m, FJAC, pivot_ptr, F, DX);
#endif	/* LINEAR_LS */
	d = 0.;
	for (i = 0; i < n; i++) {
	    d += DX[i] * DX[i];
	    X[i] -= DX[i];
	}
	d = Sqrt(d);
	/*fprintf(stderr, "\tNewton step %d: dx = %g\n", its, (double)d);*/
	if (d < ACCEPT_TOL) {
	    its++;
	    break;
	}
    }

    if (pivot_ptr != NULL)
	free(pivot_ptr);
    free(F);
    free(FJAC);
    free(DX);
#if LINEAR_LS
    free(A);
#endif

    return its;
}

static jmp_buf fpe_jmp;

#if TRAP_FPE
static void
fpe_catcher(int signum)
{
    longjmp(fpe_jmp, 1);;
}
#endif	/* TRAP_FPE */

static char *
get_absc(char *v, FLOAT c, char *expr)
{
    if (Fabs(c - 0.0) <= ACCEPT_TOL)
	strcpy(v, "0");
    else if (Fabs(c - 1.0/(FLOAT)2.0) <= ACCEPT_TOL)
	strcpy(v, "1/2");
    else if (Fabs(c - 1.0/(FLOAT)3.0) <= ACCEPT_TOL)
	strcpy(v, "1/3");
    else if (Fabs(c - 1.0/(FLOAT)4.0) <= ACCEPT_TOL)
	strcpy(v, "1/4");
    else if (Fabs(c - 1.0) <= ACCEPT_TOL)
	strcpy(v, "1");
    else {
	if (expr == NULL) {
	    static int warned = 0;
	    if (!warned) {
		fprintf(stderr, "*** Warning: floating point number used!\n");
		warned = 1;
	    }
	}
	sprintf(v, "%0.20lg", (double)c);
    }

    return expr != NULL ? expr : v;
}

static void
dump_varlist(FILE *f, int nx, const char *sep)
{
    int i;

    for (i = 0; i < nwgts; i++)
	fprintf(dump_file, "%sw%d", i == 0 ? "" : sep, i);
    if (nx > 0) {
	for (i = 0; i < nx; i++)
	    fprintf(dump_file, "%sx%d", sep, i);
    }
}

static void
dump_eqnlist(FILE *f, const char *append, const char *sep)
{
    int i;
    for (i = 0; i < neqns; i++)
	fprintf(dump_file, "%sf%d%s", i == 0 ? "" : sep, i, append);
}

static void
dump_eqns(int nx)
/* This function dumps the moment equations to f_dump.
 * 'nx' is the number of unknowns 'x#'
 *
 * Note on the global variables:
      .	'neqns' equations, stored in pbasis[].
      .	'nwgts' weights.
      .	'nabsc' abscissas (unkowns).
      .	If constraints[i].value >= 0.0 then the value of unknown i is given.
*/
{
    int i, j, iw, ix, ia;
    char x0[128], y0[128], z0[128], *u = NULL;
    size_t usize = 0;
    char *x, *y, *z;
    FLOAT c;
    /* 'orbits[i][]' stores orbit type and 'x*' index for the i-th orbit as:
     *		[type, x_0, ..., x_{dim-1}]',
     * where 'x_j' is the 'x*' index of the j-th free abscissa for the orbit.
     *
     * If for some j x_j < -1, then the value of corresponding abscissa is
     * known (predefined) and is given by constraints[-x_j-2].
     */
    int (*orbits)[dim + 1] = NULL;

#define CHECK_USIZE(size) \
    { \
	size_t s = size; \
	if (usize < s) { \
	    if (u != NULL) \
		free(u); \
	    u = malloc(usize = (s + 128)); \
	} \
    }

    assert(nwgts > 0);

    if (dump_fname == NULL)
	fprintf(stderr, "Moment equations dumped to stdout");
    else
	fprintf(stderr, "Moment equations dumped to \"%s\"", dump_fname);
    fprintf(stderr, " (format: %s).\n", dump_formats[dump_type]);
    fprintf(stderr, "*** %d equation%s; %d unknown%s: ",
		neqns, neqns > 1 ? "s" : "",
		nwgts + nx, nwgts + nx > 1 ? "s" : "");
    if (nwgts == 1)
	fprintf(stderr, "w0");
    else if (nwgts > 1)
	fprintf(stderr, "w0%sw%d", nwgts == 2 ? ", " : "..", nwgts - 1);
    if (nx == 1)
	fprintf(stderr, ", x0");
    else if (nx > 1)
	fprintf(stderr, ", x0%sx%d", nx == 2 ? ", " : "..", nx - 1);
    if (nabsc > nx)
	fprintf(stderr, "; %d constrained abscissas", nabsc - nx);
    fprintf(stderr, "\n");

    orbits = malloc(nwgts * sizeof(*orbits));
    for (i = 0; i < nwgts; i++)
	for (j = 0; j <= dim; j++)
	    orbits[i][j] = -1;

    switch (dump_type) {
	case SageMath:
	    fprintf(dump_file, "var('");
	    dump_varlist(dump_file, nx, " ");
	    fprintf(dump_file, "');\n");
	    break;
	case Mathematica:
	    break;
	case MATLAB:
	    fprintf(dump_file, "%% pkg load symbolic\t%% for Octave "
			       "(needs the octave-symbolic package)\n");
	    fprintf(dump_file, "syms ");
	    dump_varlist(dump_file, nx, " ");
	    fprintf(dump_file, ";\n");
	    break;
	case Bertini:
	    if (nwgts + nx < neqns)
		fprintf(dump_file, "CONFIG\nTRACKTYPE: 1;\nEND;\nINPUT\n");
	    /*fprintf(dump_file, "\n");*/
	    fprintf(dump_file, "variable_group ");
	    dump_varlist(dump_file, nx, ", ");
	    fprintf(dump_file, ";\n");

	    if (neqns > 0) {
		fprintf(dump_file, "function ");
		dump_eqnlist(dump_file, "", ", ");
		fprintf(dump_file, ";\n");
	    }
	    break;
    }

    for (i = 0; i < neqns; i++) {
	fprintf(dump_file, "f%d = -1", i);
	iw = ix = ia = 0;
	if (dim == 1) {
	    /* S2 */
	    if (s2 == 1) {
		if (i == 0) {
		    orbits[iw][0] = 2;
		    fprintf(stderr, "*** weight: w%d, orbit: "
				    "perm2(1/2)\n", iw);
		}
		fprintf(dump_file, "+w%d*(", iw++);
		poly_dump0(pbasis[i], dump_file, "1/2", "1/2", NULL, NULL);
		fprintf(dump_file, ")");
	    }
	    /* S11 */
	    for (j = 0; j < s11; j++, ia++) {
		if (constraints != NULL && (c = constraints[ia].value) >= 0.0) {
		    if (i == 0)
			orbits[iw][1] = -(ia + 2);
		    x = get_absc(x0, c, constraints[ia].expr);
		}
		else {
		    if (i == 0)
			orbits[iw][1] = ix;
		    sprintf(x = x0, "x%d", ix++);
		}
		if (i == 0) {
		    orbits[iw][0] = 11;
		    fprintf(stderr, "*** weight: w%d, orbit: "
				    "perm11(%s)\n", iw, x0);
		}
		CHECK_USIZE(strlen(x) + 5)
		sprintf(u, "1-(%s)", x);
		fprintf(dump_file, "+w%d*(", iw++);
		poly_dump0(pbasis[i], dump_file, x, u, NULL, NULL);
		fprintf(dump_file, "+");
		poly_dump0(pbasis[i], dump_file, u, x, NULL, NULL);
		fprintf(dump_file, ")");
	    }
	}
	else if (dim == 2) {
	    /* S3 */
	    if (s3 == 1) {
		if (i == 0) {
		    orbits[iw][0] = 3;
		    fprintf(stderr, "*** weight: w%d, orbit: "
				    "perm3(1/3)\n", iw);
		}
		fprintf(dump_file, "+w%d*(", iw++);
		poly_dump0(pbasis[i], dump_file, "1/3", "1/3", "1/3", NULL);
		fprintf(dump_file, ")");
	    }
	    /* S21 */
	    for (j = 0; j < s21; j++, ia++) {
		if (constraints != NULL && (c = constraints[ia].value) >= 0.0) {
		    if (i == 0)
			orbits[iw][1] = -(ia + 2);
		    x = get_absc(x0, c, constraints[ia].expr);
		}
		else {
		    if (i == 0)
			orbits[iw][1] = ix;
		    sprintf(x = x0, "x%d", ix++);
		}
		CHECK_USIZE(strlen(x) + 7)
		sprintf(u, "1-2*(%s)", x);
		if (i == 0) {
		    orbits[iw][0] = 21;
		    fprintf(stderr, "*** weight: w%d, orbit: "
				    "perm21(%s)\n", iw, x0);
		}
		fprintf(dump_file, "+w%d*(", iw++);
#define DUMP21(x,u, v) \
		poly_dump0(pbasis[i], dump_file, x, x, u, v); \
		fprintf(dump_file, "+"); \
		poly_dump0(pbasis[i], dump_file, x, u, x, v); \
		fprintf(dump_file, "+"); \
		poly_dump0(pbasis[i], dump_file, u, x, x, v);
		DUMP21(x, u, NULL)
		fprintf(dump_file, ")");
	    }
	    /* S111 */
	    for (j = 0; j < s111; j++) {
		if (constraints != NULL && (c = constraints[ia].value) >= 0.0) {
		    if (i == 0)
			orbits[iw][1] = -(ia + 2);
		    x = get_absc(x0, c, constraints[ia].expr);
		}
		else {
		    if (i == 0)
			orbits[iw][1] = ix;
		    sprintf(x = x0, "x%d", ix++);
		}
		ia++;
		if (constraints != NULL && (c = constraints[ia].value) >= 0.0) {
		    if (i == 0)
			orbits[iw][2] = -(ia + 2);
		    y = get_absc(y0, c, constraints[ia].expr);
		}
		else {
		    if (i == 0)
			orbits[iw][2] = ix;
		    sprintf(y = y0, "x%d", ix++);
		}
		ia++;
		CHECK_USIZE(strlen(x) + strlen(y) + 8)
		sprintf(u, "1-(%s)-(%s)", x, y);
		if (i == 0) {
		    orbits[iw][0] = 111;
		    fprintf(stderr, "*** weight: w%d, orbit: "
				    "perm111(%s,%s)\n", iw, x0, y0);
		}
		fprintf(dump_file, "+w%d*(", iw++);
#define DUMP111(x,y,u,v) \
		poly_dump0(pbasis[i], dump_file, x, y, u, v); \
		fprintf(dump_file, "+"); \
		poly_dump0(pbasis[i], dump_file, x, u, y, v); \
		fprintf(dump_file, "+"); \
		poly_dump0(pbasis[i], dump_file, y, x, u, v); \
		fprintf(dump_file, "+"); \
		poly_dump0(pbasis[i], dump_file, y, u, x, v); \
		fprintf(dump_file, "+"); \
		poly_dump0(pbasis[i], dump_file, u, x, y, v); \
		fprintf(dump_file, "+"); \
		poly_dump0(pbasis[i], dump_file, u, y, x, v);
		DUMP111(x, y, u, NULL)
		fprintf(dump_file, ")");
	    }
	}
	else {
	    /* S4 */
	    if (s4 == 1) {
		if (i == 0) {
		    orbits[iw][0] = 4;
		    fprintf(stderr, "*** weight: w%d, orbit: "
				    "perm4(1/4)\n", iw);
		}
		fprintf(dump_file, "+w%d*(", iw++);
		poly_dump0(pbasis[i], dump_file, "1/4", "1/4", "1/4", "1/4");
		fprintf(dump_file, ")");
	    }
	    /* S31 */
	    for (j = 0; j < s31; j++, ia++) {
		if (constraints != NULL && (c = constraints[ia].value) >= 0.0) {
		    if (i == 0)
			orbits[iw][1] = -(ia + 2);
		    x = get_absc(x0, c, constraints[ia].expr);
		}
		else {
		    if (i == 0)
			orbits[iw][1] = ix;
		    sprintf(x = x0, "x%d", ix++);
		}
		CHECK_USIZE(strlen(x) + 7)
		sprintf(u, "1-3*(%s)", x);
		if (i == 0) {
		    orbits[iw][0] = 31;
		    fprintf(stderr, "*** weight: w%d, orbit: "
				    "perm31(%s)\n", iw, x0);
		}
		fprintf(dump_file, "+w%d*(", iw++);
		poly_dump0(pbasis[i], dump_file, x, x, x, u);
		fprintf(dump_file, "+"); \
		poly_dump0(pbasis[i], dump_file, x, x, u, x);
		fprintf(dump_file, "+"); \
		poly_dump0(pbasis[i], dump_file, x, u, x, x);
		fprintf(dump_file, "+"); \
		poly_dump0(pbasis[i], dump_file, u, x, x, x);
		fprintf(dump_file, ")");
	    }
	    /* S22 */
	    for (j = 0; j < s22; j++, ia++) {
		if (constraints != NULL && (c = constraints[ia].value) >= 0.0) {
		    if (i == 0)
			orbits[iw][1] = -(ia + 2);
		    x = get_absc(x0, c, constraints[ia].expr);
		}
		else {
		    if (i == 0)
			orbits[iw][1] = ix;
		    sprintf(x = x0, "x%d", ix++);
		}
		CHECK_USIZE(strlen(x) + 7)
		sprintf(u, "1/2-(%s)", x);
		if (i == 0) {
		    orbits[iw][0] = 22;
		    fprintf(stderr, "*** weight: w%d, orbit: "
				    "perm22(%s)\n", iw, x0);
		}
		fprintf(dump_file, "+w%d*(", iw++);
		DUMP21(x, u, u)
		fprintf(dump_file, "+");
		DUMP21(u, x, x)
		fprintf(dump_file, ")");
	    }
	    /* S211 */
	    for (j = 0; j < s211; j++) {
		if (constraints != NULL && (c = constraints[ia].value) >= 0.0) {
		    if (i == 0)
			orbits[iw][1] = -(ia + 2);
		    x = get_absc(x0, c, constraints[ia].expr);
		}
		else {
		    if (i == 0)
			orbits[iw][1] = ix;
		    sprintf(x = x0, "x%d", ix++);
		}
		ia++;
		if (constraints != NULL && (c = constraints[ia].value) >= 0.0) {
		    if (i == 0)
			orbits[iw][2] = -(ia + 2);
		    y = get_absc(y0, c, constraints[ia].expr);
		}
		else {
		    if (i == 0)
			orbits[iw][2] = ix;
		    sprintf(y = y0, "x%d", ix++);
		}
		ia++;
		CHECK_USIZE(strlen(x) + strlen(y) + 10)
		sprintf(u, "1-2*(%s)-(%s)", x, y);
		if (i == 0) {
		    orbits[iw][0] = 211;
		    fprintf(stderr, "*** weight: w%d, orbit: "
				    "perm211(%s,%s)\n", iw, x0, y0);
		}
		fprintf(dump_file, "+w%d*(", iw++);
		DUMP21(x, y, u)
		fprintf(dump_file, "+");
		DUMP21(x, u, y)
		fprintf(dump_file, "+");
		DUMP111(x, y, u, x)
		fprintf(dump_file, ")");
	    }
	    /* S1111 */
	    for (j = 0; j < s1111; j++) {
		if (constraints != NULL && (c = constraints[ia].value) >= 0.0) {
		    if (i == 0)
			orbits[iw][1] = -(ia + 2);
		    x = get_absc(x0, c, constraints[ia].expr);
		}
		else {
		    if (i == 0)
			orbits[iw][1] = ix;
		    sprintf(x = x0, "x%d", ix++);
		}
		ia++;
		if (constraints != NULL && (c = constraints[ia].value) >= 0.0) {
		    if (i == 0)
			orbits[iw][2] = -(ia + 2);
		    y = get_absc(y0, c, constraints[ia].expr);
		}
		else {
		    if (i == 0)
			orbits[iw][2] = ix;
		    sprintf(y = y0, "x%d", ix++);
		}
		ia++;
		if (constraints != NULL && (c = constraints[ia].value) >= 0.0) {
		    if (i == 0)
			orbits[iw][3] = -(ia + 2);
		    z = get_absc(z0, c, constraints[ia].expr);
		}
		else {
		    if (i == 0)
			orbits[iw][3] = ix;
		    sprintf(z = z0, "x%d", ix++);
		}
		ia++;
		CHECK_USIZE(strlen(x) + strlen(y) + strlen(z) + 11)
		sprintf(u, "1-(%s)-(%s)-(%s)", x, y, z);
		if (i == 0) {
		    orbits[iw][0] = 1111;
		    fprintf(stderr, "*** weight: w%d, orbit: "
				    "perm1111(%s,%s,%s)\n", iw, x0, y0, z0);
		}
		fprintf(dump_file, "+w%d*(", iw++);
		DUMP111(x, y, z, u)
		fprintf(dump_file, "+");
		DUMP111(y, z, u, x)
		fprintf(dump_file, "+");
		DUMP111(z, u, x, y)
		fprintf(dump_file, "+");
		DUMP111(u, x, y, z)
		fprintf(dump_file, ")");
	    }
	}
	fprintf(dump_file, ";\n");
    }

    switch (dump_type) {
	case SageMath:
	    fprintf(dump_file, "print(solve((");
	    dump_eqnlist(dump_file, "", ", ");
	    fprintf(dump_file, "), (");
	    dump_varlist(dump_file, nx, ", ");
	    fprintf(dump_file, ")));\n");
	    break;
	case Mathematica:
	    /* Note: use "NSolve[" for finding numerical solutions */
	    fprintf(dump_file, "InputForm[Solve[");
	    dump_eqnlist(dump_file, "==0", " && ");
	    fprintf(dump_file, ", {");
	    dump_varlist(dump_file, nx, ", ");
	    fprintf(dump_file, "}]]\n");
	    break;
	case MATLAB:
	    fprintf(dump_file, "%% vpasolve([");
	    dump_eqnlist(dump_file, "", ", ");
	    fprintf(dump_file, "], [");
	    dump_varlist(dump_file, nx, ", ");
	    fprintf(dump_file, "])\n");

	    /* print orbits[][] array */
	    fprintf(dump_file, "\norbits = [");
	    for (i = 0; i < nwgts; i++)
		for (j = 0; j <= dim; j++)
		    fprintf(dump_file, "%d%s",
			    orbits[i][j] < -2 ? -2 : orbits[i][j],
			    j < dim ? "," : (i == nwgts-1 ? "];\n" : "; "));
	    fprintf(dump_file, "values = [");
	    for (i = 0; i < nwgts; i++)
		for (j = 0; j < dim; j++)
		    fprintf(dump_file, "%0.16lg%s",
			    orbits[i][j + 1] >= -1 ?  -1.0 :
				(double)constraints[-(orbits[i][j+1]+2)].value,
			    j < dim-1 ? "," : (i == nwgts-1 ? "];\n" : "; "));
	    fprintf(dump_file, "\n%% Notes:\n%%\n"
"%% 1. orbits[nwgts][d+1] (d == dim) contains information about the orbits:\n"
"%% 		orbits(i,1:d+1) = [type, ind_0, ind_1, ..., ind_{d-1}]\n"
"%%    where 'type' is the orbit type of the i-th orbit, and 'ind_k' is the\n"
"%%    index of the 'x*' variable for the k-th abscissa of the i-th orbit.\n"
"%%\n"
"%%    If orbits(i,j)==-1, then the corresponding variable doesn't exist.\n"
"%%\n"
"%%    If orbits(i,j)==-2, then the corresponding variable has a predefined\n"
"%%    value given by values(i,j-1), this case can only occur if constrained\n"
"%%    or predefined orbits exist.\n"
"%%\n"
"%% 2. List of orbit types (all variables x, y and z must be non negative).\n"
"%%\n"
"%%    ----------------------------------------------------------------------\n"
"%%    Orbit	Vars	Equivalent solutions			Constraints  \n"
"%%    ----------------------------------------------------------------------\n"
"%%    S2:	none	none					none	     \n"
"%%    S11:	x	x <-> 1-x				x<=1	     \n"
"%%    ----------------------------------------------------------------------\n"
"%%    S3:	none	none					none	     \n"
"%%    S21:	x	none					2*x<=1	     \n"
"%%    S111:	x,y	{x,y} \\subset {x,y,1-x-y}		x+y<=1	     \n"
"%%    ----------------------------------------------------------------------\n"
"%%    S4:	none	none					none	     \n"
"%%    S31:	x	none					3*x<=1	     \n"
"%%    S22:	x	x <-> 1/2-x				2*x<=1	     \n"
"%%    S211:	x,y	y <-> 1-2*x-y				2*x+y<=1     \n"
"%%    S1111:	x,y,z	{x,y,z} \\subset {x,y,z,1-x-y-z} 	x+y+z<=1     \n"
"%%    ----------------------------------------------------------------------\n"
	    );
	    break;
	case Bertini:
	    fprintf(dump_file, "END;\n");
	    break;
    }

    if (orbits != NULL)
	free(orbits);

    if (u != NULL)
	free(u);
}

static FLOAT
nonlinear_solver(FLOAT D[], FLOAT W[])
/* calls an external solver to solve the nonlinear equations or
 * the nonlinear least square problem. */
{
    int i, j, n, m;
    FLOAT *X, *F, error;

#if INDEPENDENT_W
    n = nabsc + nwgts;
#else	/* INDEPENDENT_W */
    n = nabsc;
#endif	/* INDEPENDENT_W */
    m = neqns;

    if ((i = setup_constraints(n, /*count_only=*/0)) < 0)
	return -1.0;	/* constraints can't be satisfied. */

    if (dump_file != NULL) {
	if (myrank != 0)
	    return -1.0;
	dump_eqns(nabsc - i);
	return -1.0;
    }

    X = malloc(n * sizeof(*X));
    F = malloc(m * sizeof(*F));

    for (i = 0; i < nabsc; i++)
	if (constraints != NULL && constraints[i].value >= 0.)
	    D[i] = constraints[i].value;

    n -= ncons;

    if (nabsc == ncons) {
	/* no free abscissa, directly evaluate weights then return */
	error = init_w(D, W);
	if (dim > 1)
	    for (i = 0; i < nwgts; i++)
		W[i] *= (dim == 2 ? 2. : 6.);
	if (X != NULL)
	    free(X);
	if (F != NULL)
	    free(F);

	return error;
    }

    /* Copy initial abscissas to X[] */
    memcpy(X, D, nabsc * sizeof(*D));

#if INDEPENDENT_W
    /* Compute initial weights */
    init_w(D, X + nabsc);
#endif	/* INDEPENDENT_W */

#if USE_MAPPING
    mapping_x2y(n + ncons, X, X);
#endif	/* USE_MAPPING */

    /* remove constrained abscissas from X[] */
    if (ncons > 0) {
	for (i = j = 0; i < nabsc; i++)
	    if (constraints == NULL || constraints[i].value < 0.)
		X[j++] = X[i];
	assert(nabsc - j == ncons);
#if INDEPENDENT_W
	memmove(X + j, X + nabsc, nwgts * sizeof(*X));
#endif	/* INDEPENDENT_W */
    }

#if (NONLINEAR_SOLVER == NEWTON)
    Unused(cb_func);
    Unused(cb_func_n);
    newton_solver(m, n, X);
#else	/* (NONLINEAR_SOLVER == NEWTON) */
    oem_solver(m, n, X);
    neqns = m;		/* OEM solver may alter neqns */
    /* performs some Newton steps */
    newton_solver(m, n, X);
#endif	/* (NONLINEAR_SOLVER == NEWTON) */

#if TRAP_FPE
    fedisableexcept(FE_ALL_EXCEPT);
    feclearexcept(FE_ALL_EXCEPT);
    feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);
    signal(SIGFPE, fpe_catcher);
#endif	/* TRAP_FPE */

    /* compute residuals */
    if (setjmp(fpe_jmp) != 0) {
	/* FPE exception */
	fprintf(stderr, "*************************** FPE detected.\n");
	error = 1e10;
    }
    else {
	func_eval(npolys, n, X, F, NULL, 0);
	error = 0.;
	for (i = 0; i < m; i++)
	    error += F[i] * F[i];
	error = Sqrt(error);
    }

#if TRAP_FPE
    fedisableexcept(FE_ALL_EXCEPT);
    feclearexcept(FE_ALL_EXCEPT);
    signal(SIGFPE, SIG_IGN);
#endif	/* TRAP_FPE */

    /* insert constrained abscissas back into X[] */
    if (ncons > 0) {
#if INDEPENDENT_W
	memmove(X + nabsc, X + nabsc - ncons, nwgts * sizeof(*X));
#endif	/* INDEPENDENT_W */
	for (i = nabsc - 1, j = i - ncons; i >= 0; i--)
	    if (constraints == NULL || constraints[i].value < 0.)
		X[i] = X[j--];
	    else
		X[i] = constraints[i].value;
	assert(j == -1);
    }

#if USE_MAPPING
    mapping_y2x(n + ncons, X, X);
#endif

    memcpy(D, X, nabsc * sizeof(*X));

    /* copy and normalize weights */
#if INDEPENDENT_W
    for (i = 0; i < nwgts; i++)
	W[i] = X[i + nabsc] * (dim == 1 ? 1.0 : (dim == 2 ? 2. : 6.));
#else	/* INDEPENDENT_W */
    init_w(D, W);
    if (dim > 1)
	for (i = 0; i < nwgts; i++)
	    W[i] *= (dim == 2 ? 2. : 6.);
#endif	/* INDEPENDENT_W */

    free(X);
    free(F);

#if !TRAP_FPE
    /* When TRAP_FPE is disabled we use the following workaround */
    if (error < ACCEPT_TOL) {
	char s[128];
	sprintf(s, "%0.16lg", (double)error);
	if (!strcmp(s, "0") || /* check for "nan" or "inf" */
	    strchr(s, 'n') != NULL || strchr(s, 'N') != NULL) {
	    for (i = 0; i < nwgts; i++) {
		sprintf(s, "%0.16lg", (double)W[i]);
		if (!strcmp(s, "0") || /* check for "nan" or "inf" */
		    strchr(s, 'n') != NULL || strchr(s, 'N') != NULL)
		    break;
	    }
	    if (i < nwgts) {
		/*printf("=== Skipping corrupted rule (FPE problem?)\n");*/
		error = 1e10;
	    }
	}
    }
#endif	/* !TRAP_FPE */

    return error;
}

static int tmp_size;

static int
absc_comp(const void *p0, const void *p1)
{
    int i;
    const FLOAT *a0 = p0, *a1 = p1;

    for (i = 0; i < tmp_size; i++) {
	if (*a0 > *a1)
	    return 1;
	if (*a0 < *a1)
	    return -1;
    }

    return 0;
}

static void
sort_abscissas(int nlen, const int len[], const int size[], FLOAT *D)
{
    int i;

    for (i = 0; i < nlen; i++) {
	tmp_size = size[i];
	qsort(D, len[i], tmp_size * sizeof(*D), absc_comp);
	D += len[i] * size[i];
    }
}

static int
check_last_found(const FLOAT D[])
/* checks the current solution against the one found in the last try.
 * returns the number of identical solutions found for the current case */
{
    static int count = 0;
    static int t2 = -1, t11 = -1;
    static int n1[] = {1, 1};
    static int t3 = -1, t21 = -1, t111 = -1;
    static int n2[] = {1, 1, 2};
    static int t4 = -1, t31 = -1, t22 = -1, t211 = -1, t1111 = -1;
    static int n3[] = {1, 1, 1, 2, 3};
    static FLOAT *D0 = NULL;
    FLOAT *D1;
    int i, flag, n, nlen, *n0, len[4];

    if (dim == 1) {
	nlen = 1;
	n = s11;
	len[0] = s11;
	n0 = n1;
	if (t2 != s2 || t11 != s11) {
	    flag = 0;
	    t2 = s2; t11 = s11;
	}
	else {
	    flag = 1;
	}
    }
    else if (dim == 2) {
	nlen = 2;
	n = s21 + 2 * s111;
	len[0] = s21; len[1] = s111;
	n0 = n2;
	if (t3 != s3 || t21 != s21 || t111 != s111) {
	    flag = 0;
	    t3 = s3; t21 = s21; t111 = s111;
	}
	else {
	    flag = 1;
	}
    }
    else {
	nlen = 4;
	n = s31 + s22 + 2 * s211 + 3 * s1111;
	len[0] = s31; len[1] = s22; len[2] = s211; len[3] = s1111;
	n0 = n3;
	if (t4 != s4 || t31 != s31 || t22 != s22 || t211 != s211 ||
	    t1111 != s1111) {
	    flag = 0;
	    t4 = s4; t31 = s31; t22 = s22; t211 = s211; t1111 = s1111;
	}
	else {
	    flag = 1;
	}
    }

    if (n > 0) {
	D1 = malloc(n * sizeof(*D1));
	memcpy(D1, D, n * sizeof(*D0));
	sort_abscissas(nlen, len, n0, D1);
    }
    else {
	D1 = NULL;
    }

    if (flag) {
	FLOAT diff = 0;
	assert(D0 != NULL);
	for (i = 0; i < n; i++)
	    if (diff > Fabs(D0[i] - D1[i]))
		diff = Fabs(D0[i] - D1[i]);
	/*fprintf(stderr, "\tdiff = %g, count = %d\n", (double)diff, count);*/
	if (diff <= ACCEPT_TOL)
	    return ++count;
    }

    /* save the new solution */
    if (D0 != NULL)
	free(D0);
    D0 = D1;

    return (count = 0);
}

static int
check_found(int abort)
{
#if USE_MPI
    int n[2], m[2], ret;
    n[0] = nsols;
    n[1] = abs(abort);
    ret = MPI_Allreduce(n, m, 2, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
    Unused(ret);
    nsols = m[0];
    abort = m[1];
#endif

    return (nsols != 0 && stop_flag) || abort != 0;
}

static int
check_solution_1d(int prtflag, int tries, FLOAT error, FLOAT tol,
			FLOAT D[], FLOAT W[])
{
    int inbound = 1, i, j, k, weight0 = 0;

#if !SYMMETRY
# error unimplemented!
#endif

    if (prtflag) {
	time_t t = time(NULL);
	printf("** %s", ctime(&t));
	printf("1D %d point order %d rule "
		"(%d:%d, %d tries, %d evals), error = %0.4lg\n", npoints, 
		degree, s2, s11, tries / nprocs + 1,
		eval_count, (double)error);
    }

    i = j = 0;
    if (s2 > 0) {
	if (prtflag)
	    printf("    Perm2(%0.16lg)\n", (double)(1./2.));
	if (W[j] < -tol || W[j] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	else if (ncons && W[j] <= 0.0) {
	    if (prtflag)
		printf("0");
	    weight0 = 1;
	}
	if (prtflag)
	    printf("    Dup2(%0.16lg)\n", (double)W[j]);
	j++;
    }
    for (k = 0; k < s11; k++) {
	if (D[i] < -tol || D[i] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	if (prtflag) {
	    if (constraints == NULL || constraints[i].value < 0.) {
		printf("    Perm11(%0.16lg)\n", (double)D[i]);
	    }
	    else {
		assert(D[i] == constraints[i].value);
		printf("    Cons11(%0.16lg)\n", (double)D[i]);
	    }
	}
	if (W[j] < -tol || W[j] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	else if (ncons && W[j] <= 0.0) {
	    if (prtflag)
		printf("0");
	    weight0 = 1;
	}
	if (prtflag)
	    printf("    Dup11(%0.16lg)\n", (double)W[j]);
	i++;
	j++;
    }

    if (ncons && weight0) {
	if (prtflag)
	    fprintf(stderr, " solution has zero weight(s), skipped.\n");
	inbound = 0;
    }

    if (prtflag) {
	if (inbound) {
	    printf("Range check ok.\n");
	    fprintf(stderr, " :-:) got a good candidate (proc %d, %d tries, "
		    "%d evals, err = %0.1le)\n", myrank, tries / nprocs + 1,
			eval_count, (double)error);
	}
	else {
	    printf(" *** abscissas out of range or weights negative!\n");
	    fprintf(stderr, " :-:( got a bad solution (%d:%d:%d, proc %d, "
		    "%d tries, %d evals, err = %0.1le)\n", s3, s21, s111,
			myrank, tries / nprocs + 1,
			eval_count, (double)error);
	}
	fflush(stdout);
	fflush(stderr);
    }

    return inbound;
}

static void
search_1D(void)
{
    FLOAT error, *D, *W;
    int i, tries, printed = 0;

#if SYMMETRY
    nabsc = s11;	/* number of independent unknowns */
    nwgts = s2 + s11;	/* number of independent weights */
#else	/* SYMMETRY */
    nabsc = 2 * npoints;	/* number of independent unknowns */
    nwgts = npoints;		/* number of independent weights */
#endif	/* SYMMETRY */

    if (myrank == 0) {
	if (s2 > 0) fprintf(stderr, "%d*S2 ", s2);
	if (s11 > 0) fprintf(stderr, "%d*S11 ", s11);
	fprintf(stderr, "=> %d point(s), %d eqns, free absc+wgts: %d+%d=%d\n",
			npoints, neqns, nabsc, nwgts, nabsc + nwgts);
    }

    if (monos_n == 0 && nabsc + nwgts < neqns) {
	if (myrank == 0)
	    fprintf(stderr, "    case skipped because # DOF < # equations.\n");
	return;
    }

    D = malloc(nabsc * sizeof(*D));
    W = malloc(nwgts * sizeof(*W));

#if ASYNCHRONOUS
    sync_file(REMOVE_SYNC_FILE);
    if (setjmp(jmp)) {
	check_found(0);
	goto end;
    }
#endif

    for (tries = 0; tries < (GENETIC ? 1:guess_max) + nprocs; tries += nprocs) {
#if !ASYNCHRONOUS
	if ((tries / nprocs + 1) % 5 == 0) {
	    if (check_found(0))
		goto end;
	}
#endif	/* !ASYNCHRONOUS */
	eval_count = 0;
#if GENETIC
	genetic(D);
#else
	abscissas_seed(D);
#endif
	if (plot) {
#if SYMMETRY
	    if (s11 > 0)
		plot_gen(s11, 0, (FLOAT)(1. / _F(2.)), D);
#else	/* SYMMETRY */
	    plot_gen(0, (FLOAT)1., D);
#endif	/* SYMMETRY */
	    break;;
	}

#if SYMMETRY
	error = nonlinear_solver(D, W);
	if (error < 0.) {
	    /* abort the case */
	    error = 1.0e10;
	    break;
	}
	if (myrank == 0 && (tries / nprocs) % 1 == 0) {
	    fprintf(stderr, "    tries = %d, error = %lg, evals = %d\n",
			    tries, (double)error, eval_count);
	    fflush(stderr);
	}
	if (error < REPORT_TOL) {
	    i = check_last_found(D);
	    if (i == 1) {
		/* the solution has been found in last loop */
		continue;
	    }
	    else if (0 && i >= 9) {
		/* the solution has been found in last two or more loops */
		fprintf(stderr, " *** got the same bad solution for the last "
				"10 times, switch to next case.\n");
#if ASYNCHRONOUS
		sync_file(CREATE_SYNC_FILE);
#endif	/* ASYNCHRONOUS */
		check_found(1);
		goto end;
	    }
	    if (check_solution_1d(0, tries, error,
					ncons ? ACCEPT_TOL : 0.5, D, W)) {
		if (check_solution_1d(1, tries, error, OUTBOUND_TOL, D, W)
			&& error < ACCEPT_TOL) {
		    if (!stop_flag) {
			printf("Seems to be a good solution.\n");
			fflush(stdout);
			nsols++;
		    }
		    else {
			printf("Seems to be a good solution, stop.\n");
			fflush(stdout);
			nsols++;
#if ASYNCHRONOUS
			sync_file(CREATE_SYNC_FILE);
#endif	/* ASYNCHRONOUS */
			check_found(0);
			goto end;
		    }
		}
	    }
	    else if (!printed) {
		printed = 1;
		fprintf(stderr, " :-:( got a bad solution (%d:%d:%d, "
			"proc %d, %d tries, %d evals, err = %0.1le)\n", 
			s3, s21, s111, myrank,
			tries / nprocs + 1, eval_count, (double)error);
	    }
	}
    }
#endif	/* SYMMETRY */

#if !ASYNCHROMOUS
    check_found(0);
#endif	/* !ASYNCHRONOUS */

end:
    free(W);
    free(D);
}


static int
check_solution_2d(int prtflag, int tries, FLOAT error, FLOAT tol,
			FLOAT D[], FLOAT W[])
{
    int inbound = 1, i, j, k, weight0 = 0;

#if !SYMMETRY
# error unimplemented!
#endif

    if (prtflag) {
	time_t t = time(NULL);
	printf("** %s", ctime(&t));
	printf("2D %d point order %d rule "
		"(%d:%d:%d, %d tries, %d evals), error = %0.4lg\n", npoints, 
		degree, s3, s21, s111, tries / nprocs + 1,
		eval_count, (double)error);
    }

    i = j = 0;
    if (s3 > 0) {
	if (prtflag)
	    printf("    Perm3(%0.16lg)\n", (double)(1./3.));
	if (W[j] < -tol || W[j] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	else if (ncons && W[j] <= 0.0) {
	    if (prtflag)
		printf("0");
	    weight0 = 1;
	}
	if (prtflag)
	    printf("    Dup3(%0.16lg)\n", (double)W[j]);
	j++;
    }
    for (k = 0; k < s21; k++) {
	if (D[i] < -tol || D[i] > .5 + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	if (prtflag) {
	    if (constraints == NULL || constraints[i].value < 0.) {
		printf("    Perm21(%0.16lg)\n", (double)D[i]);
	    }
	    else {
		assert(D[i] == constraints[i].value);
		printf("    Cons21(%0.16lg)\n", (double)D[i]);
	    }
	}
	if (W[j] < -tol || W[j] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	else if (ncons && W[j] <= 0.0) {
	    if (prtflag)
		printf("0");
	    weight0 = 1;
	}
	if (prtflag)
	    printf("    Dup21(%0.16lg)\n", (double)W[j]);
	i++;
	j++;
    }
    for (k = 0; k < s111; k++) {
	if (D[i] < -tol || D[i+1] < -tol || D[i] + D[i+1] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	if (prtflag) {
	    if (constraints == NULL || constraints[i].value < 0.) {
		printf("    Perm111(%0.16lg, %0.16lg)\n",
			    (double)D[i], (double)D[i + 1]);
	    }
	    else {
		assert(D[i] == constraints[i].value);
		printf("    Cons111(%0.16lg, %0.16lg)\n",
			    (double)D[i], (double)D[i + 1]);
	    }
	}
	if (W[j] < -tol || W[j] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	else if (ncons && W[j] <= 0.0) {
	    if (prtflag)
		printf("0");
	    weight0 = 1;
	}
	if (prtflag)
	    printf("    Dup111(%0.16lg)\n", (double)W[j]);
	i += 2;
	j++;
    }

    if (ncons && weight0) {
	if (prtflag)
	    fprintf(stderr, " solution has zero weight(s), skipped.\n");
	inbound = 0;
    }

    if (prtflag) {
	if (inbound) {
	    printf("Range check ok.\n");
	    fprintf(stderr, " :-:) got a good candidate (proc %d, %d tries, "
		    "%d evals, err = %0.1le)\n", myrank, tries / nprocs + 1,
			eval_count, (double)error);
	}
	else {
	    printf(" *** abscissas out of range or weights negative!\n");
	    fprintf(stderr, " :-:( got a bad solution (%d:%d:%d, proc %d, "
		    "%d tries, %d evals, err = %0.1le)\n", s3, s21, s111,
			myrank, tries / nprocs + 1,
			eval_count, (double)error);
	}
	fflush(stdout);
	fflush(stderr);
    }

    return inbound;
}

static void
search_2D(void)
{
    FLOAT error, *D, *W;
    int i, tries, printed = 0;

#if SYMMETRY
    nabsc = s21 + 2 * s111;	/* number of independent unknowns */
    nwgts = s3 + s21 + s111;	/* number of independent weights */
#else	/* SYMMETRY */
    nabsc = 2 * npoints;	/* number of independent unknowns */
    nwgts = npoints;		/* number of independent weights */
#endif	/* SYMMETRY */

    if (myrank == 0) {
	if (s3 > 0) fprintf(stderr, "%d*S3 ", s3);
	if (s21 > 0) fprintf(stderr, "%d*S21 ", s21);
	if (s111 > 0) fprintf(stderr, "%d*S111 ", s111);
	fprintf(stderr, "=> %d point(s), %d eqns, free absc+wgts: %d+%d=%d\n",
			npoints, neqns, nabsc, nwgts, nabsc + nwgts);
    }

    if (monos_n == 0 && nabsc + nwgts < neqns) {
	if (myrank == 0)
	    fprintf(stderr, "    case skipped because # DOF < # equations.\n");
	return;
    }

    D = malloc(nabsc * sizeof(*D));
    W = malloc(nwgts * sizeof(*W));

#if ASYNCHRONOUS
    sync_file(REMOVE_SYNC_FILE);
    if (setjmp(jmp)) {
	check_found(0);
	goto end;
    }
#endif

    for (tries = 0; tries < (GENETIC ? 1:guess_max) + nprocs; tries += nprocs) {
#if !ASYNCHRONOUS
	if ((tries / nprocs + 1) % 5 == 0) {
	    if (check_found(0))
		goto end;
	}
#endif	/* !ASYNCHRONOUS */
	eval_count = 0;
#if GENETIC
	genetic(D);
#else
	abscissas_seed(D);
#endif
	if (plot) {
#if SYMMETRY
	    if (s21 > 0)
		plot_gen(s21, 0, (FLOAT)(1. / _F(3.)), D);
	    else
		plot_gen(2 * s111, s21, (FLOAT)1., D);
#else	/* SYMMETRY */
	    plot_gen(0, (FLOAT)1., D);
#endif	/* SYMMETRY */
	    break;;
	}

#if SYMMETRY
	error = nonlinear_solver(D, W);
	if (error < 0.) {
	    /* abort the case */
	    error = 1.0e10;
	    break;
	}
	if (myrank == 0 && (tries / nprocs) % 1 == 0) {
	    fprintf(stderr, "    tries = %d, error = %lg, evals = %d\n",
			    tries, (double)error, eval_count);
	    fflush(stderr);
	}
	if (error < REPORT_TOL) {
	    i = check_last_found(D);
	    if (i == 1) {
		/* the solution has been found in last loop */
		continue;
	    }
	    else if (0 && i >= 9) {
		/* the solution has been found in last two or more loops */
		fprintf(stderr, " *** got the same bad solution for the last "
				"10 times, switch to next case.\n");
#if ASYNCHRONOUS
		sync_file(CREATE_SYNC_FILE);
#endif	/* ASYNCHRONOUS */
		check_found(1);
		goto end;
	    }
	    if (check_solution_2d(0, tries, error,
					ncons ? ACCEPT_TOL : 0.5, D, W)) {
		if (check_solution_2d(1, tries, error, OUTBOUND_TOL, D, W)
			&& error < ACCEPT_TOL) {
		    if (!stop_flag) {
			printf("Seems to be a good solution.\n");
			fflush(stdout);
			nsols++;
		    }
		    else {
			printf("Seems to be a good solution, stop.\n");
			fflush(stdout);
			nsols++;
#if ASYNCHRONOUS
			sync_file(CREATE_SYNC_FILE);
#endif	/* ASYNCHRONOUS */
			check_found(0);
			goto end;
		    }
		}
	    }
	    else if (!printed) {
		printed = 1;
		fprintf(stderr, " :-:( got a bad solution (%d:%d:%d, "
			"proc %d, %d tries, %d evals, err = %0.1le)\n", 
			s3, s21, s111, myrank,
			tries / nprocs + 1, eval_count, (double)error);
	    }
	}
    }
#endif	/* SYMMETRY */

#if !ASYNCHROMOUS
    check_found(0);
#endif	/* !ASYNCHRONOUS */

end:
    free(W);
    free(D);
}

static int
check_solution_3d(int prtflag, int tries, FLOAT error, FLOAT tol,
			FLOAT D[], FLOAT W[])
{
    int inbound = 1, i, j, k, weight0 = 0;

#if !SYMMETRY
# error unimplemented!
#endif

    if (prtflag) {
	time_t t = time(NULL);
	printf("** %s", ctime(&t));
	printf("3D %d point order %d rule "
		"(%d:%d:%d:%d:%d, %d tries, %d evals), error = %0.4lg\n", 
		npoints, degree, s4, s31, s22, s211, s1111, tries / nprocs + 1,
		eval_count, (double)error);
    }

    i = j = 0;
    if (s4 > 0) {
	if (prtflag)
	    printf("    Perm4(0.25)\n");
	if (W[j] < -tol || W[j] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
 	}
	else if (ncons && W[j] <= 0.0) {
	    if (prtflag)
		printf("0");
	    weight0 = 1;
	}
	if (prtflag)
	    printf("    Dup4(%0.16lg)\n", (double)W[j]);
	j++;
    }

    for (k = 0; k < s31; k++) {
	if (D[i] < -tol || D[i] > 1. / _F(3.) + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	if (prtflag) {
	    if (constraints == NULL || constraints[i].value < 0.) {
		printf("    Perm31(%0.16lg)\n", (double)D[i]);
	    }
	    else {
		assert(D[i] == constraints[i].value);
		printf("    Cons31(%0.16lg)\n", (double)D[i]);
	    }
	}
	if (W[j] < -tol || W[j] > 1. + tol) {
	    if (prtflag)
	        printf("*");
	    inbound = 0;
	}
	else if (ncons && W[j] <= 0.0) {
	    if (prtflag)
		printf("0");
	    weight0 = 1;
	}
	if (prtflag)
	    printf("    Dup31(%0.16lg)\n", (double)W[j]);
	i++;
	j++;
    }

    for (k = 0; k < s22; k++) {
	if (D[i] < -tol || D[i] > .5 + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	if (prtflag) {
	    if (constraints == NULL || constraints[i].value < 0.) {
		printf("    Perm22(%0.16lg)\n", (double)D[i]);
	    }
	    else {
		assert(D[i] == constraints[i].value);
		printf("    Cons22(%0.16lg)\n", (double)D[i]);
	    }
	}
	if (W[j] < -tol || W[j] > 1. + tol) {
	    if (prtflag)
	        printf("*");
	    inbound = 0;
	}
	else if (ncons && W[j] <= 0.0) {
	    if (prtflag)
		printf("0");
	    weight0 = 1;
	}
	if (prtflag)
	    printf("    Dup22(%0.16lg)\n", (double)W[j]);
	i++;
	j++;
    }

    for (k = 0; k < s211; k++) {
	if (D[i] < -tol || D[i+1] < -tol || 2. * D[i] + D[i+1] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	if (prtflag) {
	    if (constraints == NULL ||
		(constraints[i].value < 0. && constraints[i + 1].value < 0.)) {
		printf("    Perm211(%0.16lg, %0.16lg)\n",
			    (double)D[i], (double)D[i + 1]);
	    }
	    else {
		assert(D[i] == constraints[i].value || D[i+1] == constraints[i+1].value);
		printf("    Cons211(%0.16lg, %0.16lg)\n",
			    (double)D[i], (double)D[i + 1]);
	    }
	}
	if (W[j] < -tol || W[j] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	else if (ncons && W[j] <= 0.0) {
	    if (prtflag)
		printf("0");
	    weight0 = 1;
	}
	if (prtflag)
	    printf("    Dup211(%0.16lg)\n", (double)W[j]);
	i += 2;
	j++;
    }

    for (k = 0; k < s1111; k++) {
	if (D[i] < -tol || D[i+1] < -tol || D[i+2] < -tol ||
	    D[i] + D[i+1] + D[i+2] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	if (prtflag) {
	    if (constraints == NULL || constraints[i].value < 0.) {
		printf("    Perm1111(%0.16lg, %0.16lg, %0.16lg)\n",
			    (double)D[i], (double)D[i + 1], (double)D[i + 2]);
	    }
	    else {
		assert(D[i] == constraints[i].value);
		printf("    Cons1111(%0.16lg, %0.16lg, %0.16lg)\n",
			    (double)D[i], (double)D[i + 1], (double)D[i + 2]);
	    }
	}
	if (W[j] < -tol || W[j] > 1. + tol) {
	    if (prtflag)
		printf("*");
	    inbound = 0;
	}
	else if (ncons && W[j] <= 0.0) {
	    if (prtflag)
		printf("0");
	    weight0 = 1;
	}
	if (prtflag)
	    printf("    Dup1111(%0.16lg)\n", (double)W[j]);
	i += 3;
	j++;
    }

    if (ncons && weight0) {
	if (prtflag)
	    fprintf(stderr, " solution has zero weight(s), skipped.\n");
	inbound = 0;
    }

    if (prtflag) {
	if (inbound) {
	    printf("Range check ok.\n");
	    fprintf(stderr, " :-:) got a good candidate (proc %d, %d tries, "
		    "%d evals, err = %0.1le)\n", myrank, tries / nprocs + 1,
			eval_count, (double)error);
	}
	else {
	    printf(" *** abscissas out of range or weights negative!\n");
	    fprintf(stderr, " :-:( got a bad solution (%d:%d:%d:%d:%d, "
		    "proc %d, %d tries, %d evals, err = %0.1le)\n", 
			s4, s31, s22, s211, s1111, myrank, tries / nprocs + 1,
			eval_count, (double)error);
	}
    }

    return inbound;
}

static void
search_3D(void)
/* evaluates 2D rule for the given symmetry pattern */
{
    FLOAT error, *D, *W;
    int i, tries, printed = 0;

#if SYMMETRY
    nabsc = s31 + s22 + 2 * s211 + 3 * s1111;
    nwgts = s4 + s31 + s22 + s211 + s1111;
#else	/* SYMMETRY */
    nabsc = 3 * npoints;	/* number of independent unknowns */
    nwgts = npoints;		/* number of independent weights */
#endif	/* SYMMETRY */

    if (myrank == 0) {
	if (s4 > 0) fprintf(stderr, "%d*S4 ", s4);
	if (s31 > 0) fprintf(stderr, "%d*S31 ", s31);
	if (s22 > 0) fprintf(stderr, "%d*S22 ", s22);
	if (s211 > 0) fprintf(stderr, "%d*S211 ", s211);
	if (s1111 > 0) fprintf(stderr, "%d*S1111 ", s1111);
	fprintf(stderr, "=> %d point(s), %d eqns, free absc+wgts: %d+%d=%d\n",
			npoints, neqns, nabsc, nwgts, nabsc + nwgts);
    }

    if (monos_n == 0 && nabsc + nwgts < neqns) {
	if (myrank == 0)
	    fprintf(stderr, "    case skipped because # DOF < # equations.\n");
	return;
    }

    D = malloc(nabsc * sizeof(*D));
    W = malloc(nwgts * sizeof(*W));

#if ASYNCHRONOUS
    sync_file(REMOVE_SYNC_FILE);
    if (setjmp(jmp)) {
	check_found(0);
	goto end;
    }
#endif

    for (tries = 0; tries < (GENETIC ? 1:guess_max) + nprocs; tries += nprocs) {
#if !ASYNCHRONOUS
	if ((tries / nprocs + 1) % 5 == 0) {
	    if (check_found(0))
		goto end;
	}
#endif	/* !ASYNCHRONOUS */
	eval_count = 0;
#if GENETIC
	genetic(D);
#else
	abscissas_seed(D);
#endif
	if (plot) {
#if SYMMETRY
	    if (s31 > 0)
		plot_gen(s31, 0, (FLOAT)0.25, D);
	    else if (s22 > 0)
		plot_gen(s22, s31, (FLOAT)0.5, D);
	    else if (s211 > 0)
		plot_gen(2 * s211, s31 + s22, (FLOAT)1.0, D);
	    else
		plot_gen(3 * s1111, s31 + s22 + 2 * s211, (FLOAT)1.0, D);
#else	/* SYMMETRY */
	    plot_gen(0, (FLOAT)1.0, D);
#endif	/* SYMMETRY */
	    break;
	}

#if SYMMETRY
	error = nonlinear_solver(D, W);
	if (error < 0.) {
	    /* abort the case */
	    error = 1.0e10;
	    break;
	}
	if (myrank == 0 && (tries / nprocs) % 1 == 0) {
	    fprintf(stderr, "    tries = %d, error = %lg, evals = %d\n",
			    tries, (double)error, eval_count);
	    fflush(stderr);
	}
	if (error < REPORT_TOL) {
	    i = check_last_found(D);
	    if (i == 1) {
		/* the solution has been found in last loop */
		continue;
	    }
	    else if (0 && i >= 9) {
		/* the solution has been found in last two or more loops */
		fprintf(stderr, " *** got the same bad solution for the last "
				"10 times, switch to next case.\n");
#if ASYNCHRONOUS
		sync_file(CREATE_SYNC_FILE);
#endif	/* ASYNCHRONOUS */
		check_found(1);
		goto end;
	    }
	    if (check_solution_3d(0, tries, error,
					ncons ? ACCEPT_TOL : 0.5, D, W)) {
		if (check_solution_3d(1, tries, error, OUTBOUND_TOL, D, W)
			&& error < ACCEPT_TOL) {
		    if (!stop_flag) {
			printf("Seems to be a good solution.\n");
			fflush(stdout);
			nsols++;
		    }
		    else {
			printf("Seems to be a good solution, stop.\n");
			fflush(stdout);
			nsols++;
#if ASYNCHRONOUS
			sync_file(CREATE_SYNC_FILE);
#endif	/* ASYNCHRONOUS */
			check_found(0);
			goto end;
		    }
		}
	    }
	    else if (!printed) {
		printed = 1;
		fprintf(stderr, " :-:( got a bad solution (%d:%d:%d:%d:%d, "
			"proc %d, %d tries, %d evals, err = %0.1le)\n",
			s4, s31, s22, s211, s1111, myrank,
			tries / nprocs + 1, eval_count, (double)error);
	    }
	}
    }
#endif	/* SYMMETRY */

#if !ASYNCHROMOUS
    check_found(0);
#endif	/* !ASYNCHRONOUS */

end:
    free(W);
    free(D);
}

static void
search(int flag)
/* 'flag' is only used in process 0 (to tell slaves to stop if 'flag == 0') */
{
    do {
#if USE_MPI
	int n, data[6];
	n = 0;
	if (myrank == 0) {
	    data[n++] = flag;
	    if (dim == 1) {
		data[n++] = s2;
		data[n++] = s11;
	    }
	    else if (dim == 2) {
		data[n++] = s3;
		data[n++] = s21;
		data[n++] = s111;
	    }
	    else {
		data[n++] = s4;
		data[n++] = s31;
		data[n++] = s22;
		data[n++] = s211;
		data[n++] = s1111;
	    }
	}
	MPI_Bcast(data, dim == 2 ? 4 : 6, MPI_INT, 0, MPI_COMM_WORLD);
	if (myrank > 0) {
	    flag = data[n++];
	    if (dim == 1) {
		s2 = data[n++];
		s11 = data[n++];
	    }
	    else if (dim == 2) {
		s3 = data[n++];
		s21 = data[n++];
		s111 = data[n++];
	    }
	    else {
		s4 = data[n++];
		s31 = data[n++];
		s22 = data[n++];
		s211 = data[n++];
		s1111 = data[n++];
	    }
	}
#endif

	if (!flag)
	    break;

	if (dim == 1) {
	    if ((s2_user >= 0 && s2_user != s2) ||
		(s11_user >= 0 && s11_user != s11))
		continue;
	    search_1D();
	}
	else if (dim == 2) {
	    if ((s3_user >= 0 && s3_user != s3) ||
		(s21_user >= 0 && s21_user != s21) ||
		(s111_user >= 0 && s111_user != s111))
		continue;
	    search_2D();
	}
	else {
	    if ((s4_user >= 0 && s4_user != s4) ||
		(s31_user >= 0 && s31_user != s31) ||
		(s22_user >= 0 && s22_user != s22) ||
		(s211_user >= 0 && s211_user != s211) ||
		(s1111_user >= 0 && s1111_user != s1111))
		continue;
	    search_3D();
	}
    } while (myrank > 0);
}

static void
permutations_1d(void)
/* decompose npoints into S2 + 2 S11 */
{
    if (s2_user >= 0 && s11_user >= 0) {
	/* Using user specified orbits */
	s2 = s2_user;
	s11 = s11_user;
    }
    else {
	s2 = npoints % 2;
	s11 = npoints / 2;
    }

    search(1);
    return;
}

static void
permutations_2d(void)
/* decompose npoints into S3 + 3 S21 + 6 S111 */
{
    int i, j, n = npoints;

    if (s3_user >= 0 && s21_user >= 0 && s111_user >= 0) {
	/* Using user specified orbits */
	s3 = s3_user;
	s21 = s21_user;
	s111 = s111_user;
	search(1);
	return;
    }

    s3 = n % 3;
    if (s3 == 2)
	return;
    n = (n - s3) / 3;
    j = n % 2;
    n /= 2;
#if 0
    for (i = n; i >= 0; i--)
#else
    for (i = 0; i <= n; i++)
#endif
    {
	s21 = j + 2 * i;
	s111 = n - i;
	search(1);
	if (nsols > 0 && stop_flag)
	    return;
    }
}

static void
permutations_3d(void)
/* decompose npoints into S4 + 4 S31 + 6 S22 + 12 S211 + 24 S1111 */
{
    int i, j, n = npoints;

    if (s4_user >= 0 && s31_user >= 0 && s22_user >= 0 && s211_user >= 0
	&& s1111_user >= 0) {
	/* Using user specified orbits */
	s4 = s4_user;
	s31 = s31_user;
	s22 = s22_user;
	s211 = s211_user;
	s1111 = s1111_user;
	search(1);
	return;
    }

    s4 = n % 2;
    n /= 2;
    /* decompose n into (2 S31 + 3 S22) + 6 (S211 + 2 S1111) = i + 6 * j */
    for (j = n / 6; j >= 0; j--) {
	i = n - 6 * j;
	/* decompose i into 2 * S31 + 3 * S22 */
	for (s22 = i / 3; s22 >= 0; s22--) {
	    s31 = i - 3 * s22;
	    if (s31 % 2 != 0)
		continue;
	    s31 /= 2;
	    /* and decompose j into S211 + 2 S1111 */
	    for (s1111 = j / 2; s1111 >= 0; s1111--) {
		s211 = j - 2 * s1111;
		search(1);
		if (nsols > 0 && stop_flag)
		    return;
	    }
	}
    }
}

static void
permutations(void)
{
    if (dim == 1)
	permutations_1d();
    else if (dim == 2)
	permutations_2d();
    else
	permutations_3d();

    search(0);		/* tells slaves to leave */
}

/*---------- functions for reading predefined orbits ----------*/

#include <ctype.h>
#include <sys/select.h>

static int
comp_FLOAT(const void *p, const void *q)
{
    if (*(const FLOAT *)p > *(const FLOAT *)q)
	return 1;
    else if (*(const FLOAT *)p < *(const FLOAT *)q)
	return -1;
    else
	return 0;
}

#if USE_MPFR

#include <mpfr.h>	/* Note: needs -lmpfr -lgmp */

/* this is to avoid conflicts with declarations in stdlib.h */
#define strtoflt128	str2flt128
#define strtold		str2ld

#if MPFR_VERSION_MAJOR < 3
#define MPFR_RNDN GMP_RNDN
#endif

#if FT_PHG == FT___FLOAT128
static __float128
mpfr_get_float128(const mpfr_t in, const mpfr_rnd_t rnd)
{
    __float128 a, b;
    long double d;
    mpfr_t m, m1, m2;

    mpfr_inits2(mpfr_get_prec(in), m, m1, m2, NULL);
    mpfr_set(m, in, rnd);
    a = 0.;
    while (1) {
	d = mpfr_get_ld(m, rnd);
	b = a;
	a += (__float128)d;
	if (a == b)
	    break;
	mpfr_set(m1, m, rnd);
	mpfr_set_ld(m2, d, rnd);
	mpfr_sub(m, m1, m2, rnd);
    }

    mpfr_clears(m, m1, m2, NULL);

    return a;
}

static __float128
strtoflt128(const char *ptr, char **endptr)
/* Note: this function is included in newer versions of libquadmath */
{
    __float128 a;
    mpfr_t am;

    mpfr_init2(am, (sizeof(a) + 4) * 8);
    mpfr_strtofr(am, ptr, endptr, 10, GMP_RNDN);
    a = mpfr_get_float128(am, GMP_RNDN);
    mpfr_clear (am);

    return a;
}
#endif	/* FT_PHG == FT___FLOAT128 */

#if FT_PHG == FT_LONG_DOUBLE
static long double
strtold(const char *ptr, char **endptr)
{
    long double a;
    mpfr_t am;

    mpfr_init2(am, (sizeof(a) + 4) * 8);
    mpfr_strtofr(am, ptr, endptr, 10, MPFR_RNDN);
    a = mpfr_get_ld(am, MPFR_RNDN);
    mpfr_clear(am);

    return a;
}
#endif	/* FT_PHG == FT_LONG_DOUBLE */

#endif	/* USE_MPFR */

static char *
match_parenthesis(char *p, char open, char close)
{
    int level = 0;

    assert(*p == open);

    while (*(++p) != '\0') {
	if (*p == open) {
	    level++;
	    continue;
	}
	if (*p != close)
	    continue;
	if (level-- == 0)
	    break;
    }

    return *p == close ? p : NULL;
}

static int
read_args(char **buffer, FLOAT fargs[], char *sargs[], int iargs[])
/* reads a list of (at most 3) abscissas in the form "arg1,...,argn)",
 * returns # of abscissas read (-1: invalid arguments, -2: many arguments)
 * Note: one and only one of fargs and iargs must be NULL */
{
    int i = 0, nargs = 0, divide_flag = 0, max_args = (fargs != NULL ? 3 : 4);
    char *expr;
    char *p = *buffer, *q, *r;
    FLOAT d = 0.;
    char temp[1024];	/* for symbolic->FLOAT conversion */

    assert((fargs == NULL) != (iargs == NULL));

    while (1) {
	if (nargs >= max_args)
	    return -2;
	/* remove leading spaces */
	while (isspace(*p))
	    p++;
	/* check for symbolic expression */
	if (*p == '{') {
	    if ((q = match_parenthesis(p, '{', '}')) == NULL)
		return -1;	/* error */
	    *q = '\0';
	    /* remove spaces in the expression */
	    for (expr = r = q = ++p; *q != '\0'; q++)
		if (!isspace(*q))
		    *(r++) = *q;
	    *r = '\0';
	    while (isspace(*(++q)));
	    if (*q != ',' && *q != ')')
		return -1;	/* error */
	}
	else {
	    expr = NULL;
	    for (q = p; *q != '/' && *q != ',' && *q != ')' && *q != '\0'; q++);
	    if (*q == '\0')
		return -1;		/* error */
	}
	if (fargs != NULL) {
	    if (expr != NULL) {
#ifndef SYM2FLOAT
/*-------------------- use SageMath */
# if 0
#  define SYM2FLOAT	"echo 'print \"ans=\", n(%s, digits=35)'" \
	"| sage | grep 'ans=' | sed -e 's/.*ans= *//'"
# endif
/*-------------------- bc */
# if 1
#  define SYM2FLOAT	"echo 'scale=45; %s'" \
	"| sed -e 's/\\([+-]\\?[0-9]*[0-9.]\\)[Ee]\\([+-]\\?[0-9]\\+\\)" \
	"/(\\1*10^(\\2))/g' | bc -l"
# endif
/*-------------------- use octave (warning: only long format) */
# if 0
#  define SYM2FLOAT	"echo 'format long; %s'" \
			"| octave --no-gui | awk '{print $3}'"*/
# endif
#endif
		static const char *sym2float = NULL;
		FILE *pipe;

		if (sym2float == NULL)
		    if ((sym2float = getenv("SYM2FLOAT")) == NULL)
			sym2float = SYM2FLOAT;
		fprintf(stderr, "Symbolic conversion: %s -> ", p);
		assert(strlen(sym2float) + strlen(p) + 16 < sizeof(temp));
		sprintf(temp, sym2float, p);
		strcpy(temp + strlen(temp), " 2>/dev/null");
		pipe = popen(temp, "r");
		if (pipe == NULL) {
	conv_err:
		    fprintf(stderr, "failed.\n");
		    fprintf(stderr, "(SYM2FLOAT=\"%s\")\n", sym2float);
		    return -1;
		}
		i = (int)fread(temp, 1, sizeof(temp) - 1, pipe);
		pclose(pipe);
		while (i > 0 && isspace(temp[i - 1]))
		    i--;
		if (i == 0)
		    goto conv_err;
		temp[i] = '\0';
		fprintf(stderr, "%0.16lg\n", atof(temp));
		if (dump_type == Mathematica) {
		    /* convert functions (currently only sqrt) '' */
		    p = expr;
		    while ((r = strstr(p, "sqrt(")) != NULL) {
			p = r + 4;
			*r = 'S';
			if ((r = match_parenthesis(p, '(', ')')) == NULL) {
			    fprintf(stderr, "invalid expression: %s\n", expr);
			    return -1;
			}
			*p = '[';
			*r = ']';
			p++;
		    }
		}
		p = temp;
	    }
#if 1
	    d = STR2FLOAT(p, &p);
	    if (expr != NULL)
		p = q;
#else
	    /* Workaround for LSSC3 (strtold() is broken) */
	    long double tmp;
            if (sscanf(p, "%llg", &tmp) != 1)
        	return -1;
            d = (FLOAT)tmp;
            p = q;
#endif
	}
	else {
	    assert(expr == NULL);
	    i = strtol(p, &p, 10);
	}
	if (p != q)
	    return -1;
	p++;
	if (fargs != NULL) {
	    /* 'permu#': FLOAT */
	    if (divide_flag) {
		divide_flag = 0;
		fargs[nargs] /= d;
	    }
	    else {
		fargs[nargs] = d;
		if (sargs != NULL)
		    sargs[nargs] = (expr == NULL ? NULL : strdup(expr));
	    }
	    if (*q == '/') {
		divide_flag = 1;
		continue;
	    }
	}
	else {
	    /* 'mono#': char */
	    iargs[nargs] = i;
	}
	nargs++;
	if (*q == ')')
	    break;
    }
    *buffer = p;

    return nargs;
}

static int
read_orbits(const char *argv0)
/* Reads predefined orbits (recorded in stars[]) and monomials (recorded in
 * monos[][dim+1]).
 *
 * Returns 0 if successful and !0 if error.
 *
 * Predefined orbits and monomials are read from one of the following files:
 * 	0. stdin if not empty when it's read.
 *	1. the file specified by the environment variable `ORBITS_FILE',
 *	   if the variable is not empty and the file is readable.
 *	2. the file argv0.orbits, if it's readable.
 */
{
#define BUFFERSIZE	(1024*1024 - 1)	/* 1 MB max */
    size_t size;
    char *buffer, *p, *q;
    FILE *f = NULL;

    /* First, check stdin for predefined orbits and monomials */
    if (f == NULL) {
	fd_set selectset;
	struct timeval timeout = {0 /* sec */, 0 /* usec */ };

	FD_ZERO(&selectset);
	FD_SET(0, &selectset);
	if (select(1, &selectset, NULL, NULL, &timeout) > 0) {
	    f = stdin;
	    fprintf(stderr, "Reading predefined orbits/monomials "
			    "from stdin.\n");
	}
    }

retry:
    /* Next, check the environment variable ORBITS_FILE */
    if (f == NULL && (p = getenv("ORBITS_FILE")) != NULL && *p != '\0') {
	if ((f = fopen(p, "r")) != NULL)
	    fprintf(stderr, "Reading predefined orbits/monomials "
			    "from \"%s\".\n", p);
    }

    /* Finally, check the file "argv0.orbits" */
    if (f == NULL) {
	char fn[PATH_MAX + 16];
	sprintf(fn, "%s.orbits", argv0);
	if ((f = fopen(fn, "r")) != NULL)
	    fprintf(stderr, "Reading predefined orbits/monomials "
			    "from \"%s\".\n", fn);
    }

    if (f == NULL)
	return 0;

    /* Read and process predefined orbits and monomials from f */

    buffer = malloc(BUFFERSIZE + 1);
    if ((size = fread(buffer, 1, BUFFERSIZE, f)) < 0)
	size = 0;
    buffer[size] = '\0';
    if (f == stdin) {
	/* check whether the stdin is empty and if yes then try other files
	 *
	 * Note: this is a workaround for the job system of LSSC3 which does
	 * not forward stdin properly to the user program. */
	char *p = buffer;
	while (*p != '\0' && isspace(*p))
	    p++;
	if (*p == '\0') {
	    /* empty stdin */
	    f = NULL;
	    free(buffer);
	    goto retry;
	}
    }
    else {
	fclose(f);
	f = NULL;
    }

    /* remove leading spaces */
    for (p = q = buffer; *q != '\0'; q++) {
	if (isspace(*q))
	    continue;
	*(p++) = tolower(*q);
    }
    *p = '\0';
    /*fprintf(stderr, "buffer: |%s|\n", buffer);*/

    for (p = buffer; *p != '\0';) {
	const char *key;
	STAR_INFO *found, *found1;
	int i, nargs, iargs[4];
	FLOAT fargs[3];
	char *sargs0[3], **sargs;

	sargs = (dump_file == NULL ? NULL : sargs0);

	while (isspace(*p) || *p == ',')
	    p++;

	if (!strncmp(p, "cons", 4))
	    memcpy(p, "perm", 4);
	key = p;
	while (*p != '(' && *p != '\0')
	    p++;
	if (*p == '\0') {
	    fprintf(stderr, "\tinvalid input: %s\n", key);
	    free(buffer);
	    return 1;
	}
	*(p++) = '\0';

	/* check for 'mono####' */
	if (!strncmp(key, "mono", 4)) {
	    nargs = read_args(&p, NULL, NULL, iargs);
	    fprintf(stderr, "\t%s(", key);
	    for (i = 0; i < nargs; i++)
		fprintf(stderr, "%s%d", i == 0 ? "" : ",", iargs[i]);
	    fprintf(stderr, ")\n");
	    if (nargs != strlen(key) - 4) {
		fprintf(stderr, "\tinvalid arguments for %s\n", key);
		free(buffer);
		return 1;
	    }
	    if (monos_n >= monos_alloc)
		monos = realloc(monos, (monos_alloc += 8)
					* sizeof(*monos) * (dim + 1));
	    if (dim == 1) {
		/* 1D */
		char (*pm)[2] = (void *)monos;
		if (!strcmp(key, "mono2")) {
		    pm[monos_n][0] = iargs[0];
		    pm[monos_n][1] = iargs[0];
		}
		else if (!strcmp(key, "mono11")) {
		    pm[monos_n][0] = iargs[0];
		    pm[monos_n][1] = iargs[1];
		}
		else {
		    fprintf(stderr, "\tinvalid arguments for %s.\n", key);
		    free(buffer);
		    return 1;
		}
	    }
	    else if (dim == 2) {
		/* 2D */
		char (*pm)[3] = (void *)monos;
		if (!strcmp(key, "mono3")) {
		    pm[monos_n][0] = iargs[0];
		    pm[monos_n][1] = iargs[0];
		    pm[monos_n][2] = iargs[0];
		}
		else if (!strcmp(key, "mono21")) {
		    pm[monos_n][0] = iargs[0];
		    pm[monos_n][1] = iargs[0];
		    pm[monos_n][2] = iargs[1];
		}
		else if (!strcmp(key, "mono111")) {
		    pm[monos_n][0] = iargs[0];
		    pm[monos_n][1] = iargs[1];
		    pm[monos_n][2] = iargs[2];
		}
		else {
		    fprintf(stderr, "\tinvalid arguments for %s.\n", key);
		    free(buffer);
		    return 1;
		}
	    }
	    else {
		/* 3D */
		char (*pm)[4] = (void *)monos;
		if (!strcmp(key, "mono4")) {
		    pm[monos_n][0] = iargs[0];
		    pm[monos_n][1] = iargs[0];
		    pm[monos_n][2] = iargs[0];
		    pm[monos_n][3] = iargs[0];
		}
		else if (!strcmp(key, "mono31")) {
		    pm[monos_n][0] = iargs[0];
		    pm[monos_n][1] = iargs[0];
		    pm[monos_n][2] = iargs[0];
		    pm[monos_n][3] = iargs[1];
		}
		else if (!strcmp(key, "mono22")) {
		    pm[monos_n][0] = iargs[0];
		    pm[monos_n][1] = iargs[0];
		    pm[monos_n][2] = iargs[1];
		    pm[monos_n][3] = iargs[1];
		}
		else if (!strcmp(key, "mono211")) {
		    pm[monos_n][0] = iargs[0];
		    pm[monos_n][1] = iargs[0];
		    pm[monos_n][2] = iargs[1];
		    pm[monos_n][3] = iargs[2];
		}
		else if (!strcmp(key, "mono1111")) {
		    pm[monos_n][0] = iargs[0];
		    pm[monos_n][1] = iargs[1];
		    pm[monos_n][2] = iargs[2];
		    pm[monos_n][3] = iargs[3];
		}
		else {
		    fprintf(stderr, "\tinvalid arguments for %s.\n", key);
		    free(buffer);
		    return 1;
		}
	    }
	    monos_n++;
	    continue;
	}

	/* check for 'perm####' */ 	
	for (found = stars; found < stars + nstars; found++)
	    if (!strcmp(found->star, key))
		break;
	if (found >= stars + nstars ) {
	    fprintf(stderr, "\tinvalid star '%s', abort.\n", key);
	    free(buffer);
	    return 1;
	}
	q = p;
	nargs = read_args(&p, fargs, sargs, NULL);
	if (nargs < 0) {
	    fprintf(stderr, "\t%s: %s arguments: \"%s\", abort.\n",
				found->star,
				nargs == -1 ? "invalid" : "too many",
				q);
	    free(buffer);
	    return 1;
	}
	have_predefined_orbits = 1;
	fprintf(stderr, "\t%s(", found->star);
	for (i = 0; i < nargs; i++)
	    fprintf(stderr, "%s%lg", i == 0 ? "" : ",", (double)fargs[i]);
	fprintf(stderr, ")");
	assert(found->dim <= dim);
	assert(nargs == found->nargs);
	if (found->inv_arg0 > 0 &&
		Fabs(fargs[0] - 1. / (FLOAT)found->inv_arg0) > ACCEPT_TOL) {
	    fprintf(stderr, " incorrect argument (%lg), abort.\n",
			(double)fargs[0]);
	    free(buffer);
	    return 1;
	}
	/* raise lower dimensional orbits */
	found1 = NULL;
	i = (int)(found - stars);
	if (dim >= 2 && i == u2) {
	    /* edge center */
	    assert(Fabs(fargs[0] - 0.5) < ACCEPT_TOL);
	    found1 = stars + (dim == 2 ? u21 : u22);
	    nargs = 1;
	    fargs[0] = 0.5;
	    if (sargs != NULL) {
		if (sargs[0] != NULL)
		    free(sargs[0]);
		sargs[0] = NULL;
	    }
	}
	else if (dim >= 2 && i == u11) {
	    assert(Fabs(fargs[0] - 0.5) >= ACCEPT_TOL);
	    if (Fabs(fargs[0]) < ACCEPT_TOL || Fabs(fargs[0]-1.) < ACCEPT_TOL) {
		/* vertex */
		found1 = stars + (dim == 2 ? u21 : u31);
		nargs = 1;
		fargs[0] = 0.0;
		if (sargs != NULL) {
		    if (sargs[0] != NULL)
			free(sargs[0]);
		    sargs[0] = NULL;
		}
	    }
	    else {
		/* edge */
		found1 = stars + (dim == 2 ? u111 : u211);
		nargs = 2;
		fargs[1] = fargs[0];
		fargs[0] = 0.0;
		if (sargs != NULL) {
		    sargs[1] = sargs[0];
		    sargs[0] = NULL;
		}
	    }
	}
	else if (dim == 3 && i == u3) {
	    /* face center */
	    assert(Fabs(fargs[0] - (FLOAT)1. / (FLOAT)3.) < ACCEPT_TOL);
	    found1 = stars + u31;
	    nargs = 1;
	    fargs[0] = (FLOAT)1. / (FLOAT)3.;
	    if (sargs != NULL) {
		if (sargs[0] != NULL)
		    free(sargs[0]);
		sargs[0] = NULL;
	    }
	}
	else if (dim == 3 && i == u21) {
	    assert(Fabs(fargs[0] - (FLOAT)1. / (FLOAT)3.) >= ACCEPT_TOL);
	    if (Fabs(fargs[0] - 0.0) < ACCEPT_TOL) {
		/* vertex */
		found1 = stars + u31;
		nargs = 1;
		fargs[0] = 0.0;
		if (sargs != NULL) {
		    if (sargs[0] != NULL)
			free(sargs[0]);
		    sargs[0] = NULL;
		}
	    }
	    else if (Fabs(fargs[0]-0.5) < ACCEPT_TOL) {
		/* edge center */
		found1 = stars + u22;
		nargs = 1;
		fargs[0] = 0.5;
		if (sargs != NULL) {
		    if (sargs[0] != NULL)
			free(sargs[0]);
		    sargs[0] = NULL;
		}
	    }
	    else {
		/* face */
		found1 = stars + u211;
		nargs = 2;
		fargs[1] = 0.;
		if (sargs != NULL)
		    sargs[1] = NULL;
	    }
	}
	else if (dim == 3 && i == u111) {
	    /* face */
	    fargs[2] = 1.0 - (fargs[0] + fargs[1]);
	    qsort(fargs, 3, sizeof(*fargs), comp_FLOAT);
	    assert(Fabs(fargs[0] - fargs[1]) >= ACCEPT_TOL &&
		   Fabs(fargs[1] - fargs[2]) >= ACCEPT_TOL);
	    if (Fabs(fargs[0]) < ACCEPT_TOL) {
		/* edge */
		found1 = stars + u211;
		nargs = 2;
		fargs[0] = 0.;
		fargs[1] = fargs[1];
		if (sargs != NULL) {
		    if (sargs[0] != NULL)
			free(sargs[0]);
		    sargs[0] = NULL;
		}
	    }
	    else {
		found1 = stars + u1111;
		nargs = 3;
		fargs[2] = 0.;
		if (sargs != NULL)
		    sargs[2] = NULL;
	    }
	}
	if (found1 != NULL) {
	    found = found1;
	    assert(nargs == found->nargs);
	    fprintf(stderr, " => %s(", found->star);
	    for (i = 0; i < nargs; i++)
		fprintf(stderr, "%s%lg", i == 0 ? "" : ",", (double)fargs[i]);
	    fprintf(stderr, ")");
	}
	fprintf(stderr, "\n");
	found->args = realloc(found->args,
			      nargs * (found->cnt + 1) * sizeof(*found->args));
	for (i = 0; i < nargs; i++) {
	    found->args[found->cnt * nargs + i].farg = fargs[i];
	    found->args[found->cnt * nargs + i].sarg =
		(sargs == NULL ? NULL : sargs[i]);
	}
	++found->cnt;
    }

    free(buffer);

    return 0;
}

int
main(int argc, char *argv[])
{
    int m, flag;

    Unused(poly_dump0);
    Unused(poly_axpy);
    Unused(poly_dup);

#if USE_MPI
    MPI_Init(&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
    MPI_Comm_rank(MPI_COMM_WORLD, &myrank);
#endif	/* USE_MPI */

#if NONLINEAR_SOLVER == PETSC
    PetscInitialize(&argc, &argv, NULL, NULL);
#endif	/* NONLINEAR_SOLVER == PETSC */

    /* adjust argc to stop at '--' */
    for (m = 1; m < argc; m++)
	if (!strcmp(argv[m], "--"))
	    break;
    argc = m;

    if (argc > 1) {
	if (!strcmp(argv[1], "print")) {
	    print = 1;
	    argc--;
	    argv++;
	}
	else if (!strcmp(argv[1], "plot")) {
	    plot = 1;
	    argc--;
	    argv++;
	}
	else if (!strncmp(argv[1], "dump", 4)) {
	    char *s = NULL;
	    if (argv[1][4] != '\0' && argv[1][4] != '=') {
		fprintf(stderr, "invalid keyword \"%s\".\n", argv[1]);
		exit(1);
	    }
	    if (argv[1][4] == '=') {
		s = strdup(argv[1] + 5);
		if (s[0] == '\0') {
		    free(s);
		    s = NULL;
		}
	    }
	    if (myrank == 0 && s != NULL) {
		if ((dump_fname = strchr(s, ':')) == NULL) {
		    dump_fname = s;
		}
		else {
		    (dump_fname++)[0] = '\0';
		    if (dump_fname[0] == '\0')
			dump_fname = NULL;
		    for (m = 0; m < NFORMATS; m++) {
			int i;
			for (i = 0;
			     s[i] != '\0' && dump_formats[m][i] != '0' &&
				toupper(s[i]) == toupper(dump_formats[m][i]);
			     i++);
			if (s[i] == '\0')
			    break;	/* keyword matched */
		    }
		    if (m >= NFORMATS) {
			fprintf(stderr, "Invalid dump format \"%s\".\n", s);
#if USE_MPI
			MPI_Abort(MPI_COMM_WORLD, 1);
#endif	/* USE_MPI */
			exit(1);
		    }
		    dump_type = m;
		}
		if (dump_fname != NULL) {
			dump_file = fopen(dump_fname, "wt");
			if (dump_file == NULL) {
			    fprintf(stderr, "Error opening dump file \"%s\".\n",
					dump_fname);
#if USE_MPI
			MPI_Abort(MPI_COMM_WORLD, 1);
#endif	/* USE_MPI */
			exit(1);
		    }
		}
		else {
		    dump_file = stdout;
		}
	    }
	    else {
		dump_file = stdout;
	    }
	    argc--;
	    argv++;
	}
    }

    if (argc < 3) {
usage:
	if (myrank == 0) {
	    fprintf(stderr, "Usage:\n");
	    fprintf(stderr, "  Search 1D rules ('#' specifies "
			"partially constrained orbits):\n");
	    fprintf(stderr, "    quadrule "
			"[reserved keywords] \\\n\t     "
			"1 order [[+]npoints [s2 s11[:#]] [[+]ntries]]"
			" [-- ...]\n");
	    fprintf(stderr, "  Search 2D rules (the '#'s specify "
			"partially constrained orbits):\n");
	    fprintf(stderr, "    quadrule "
			"[reserved keywords] \\\n\t     "
			"2 order [[+]npoints [s3 s21[:#] "
			"s111[:#]] [[+]ntries]]"
			" [-- ...]\n");
	    fprintf(stderr, "  Search 3D rules (the '#'s specify "
			"partially constrained orbits):\n");
	    fprintf(stderr, "    quadrule "
			"[reserved keywords] \\\n\t     "
			"3 order [[+]npoints "
			"[s4 s31[:#] s22[:#] s211[:#[:#]] s1111[:#]] \\\n"
			"\t     [[+]ntries]] [-- ...]\n");
	    fprintf(stderr, "Examples:\n");
	    fprintf(stderr, "  - 1D 4th order Gauss-Legendre rule:\n");
	    fprintf(stderr, "\tquadrule 1 5\n");
	    fprintf(stderr, "  - 1D 4th order Gauss-Lobatto rule:\n");
	    fprintf(stderr, "\tquadrule 1 5 4 : :1\n");
	    fprintf(stderr, "    or:\n");
	    fprintf(stderr, "\techo 'perm11(0)' | quadrule 1 5 4\n");
	    fprintf(stderr, "  - 3D 14 point 5th order rule:\n");
	    fprintf(stderr, "\tquadrule 3 5 14\n");
	    fprintf(stderr, "  - 3D 14 point 5th order rule "
			"with s22=1:\n");
	    fprintf(stderr, "\tquadrule 3 5 14 : : 1 : :\n");
	    fprintf(stderr, "  - 2D 7 point 3rd order rule containing "
			"the vertices and edge centers:\n");
	    fprintf(stderr, "\tquadrule 2 3 7 1 2:3 0\n");
	    fprintf(stderr, "    or:\n");
	    fprintf(stderr, "\tquadrule 2 3 7 : :3 :\n");
	    fprintf(stderr, "Notes:\n");
	    fprintf(stderr, "  0. Optional reserved keywords are for internal "
			"use only, valid keywords are:\n"
			"     'print', 'plot', 'dump[=[{");
	    for (m = 0; m < NFORMATS; m++) {
		fprintf(stderr, "%s", m==0 ? "" : "|");
		for (flag = 0; dump_formats[m][flag] != '\0'; flag++)
		    fprintf(stderr, "%c", tolower(dump_formats[m][flag]));
	    }
	    fprintf(stderr, "}:]filename]'\n");
	    fprintf(stderr, "  1. Individual number of orbits may be omitted "
			"by using ':' in its place.\n");
	    fprintf(stderr, "  2. If 'ntries' is prefixed by '+' then the "
			"program won't stop when good rules\n"
			"     are found, and results on non root processes "
			"are written to files\n"
			"     (they can be sorted with the script "
			"'quadrule-minwgt.sh').\n");
	    fprintf(stderr, "  3. Predefined (fully constrained) orbits and "
			"monomials may be given through\n     one of the "
			"following files (the 1st available is used):\n");
	    fprintf(stderr, "\t a) stdin (if it has data at startup),\n");
	    fprintf(stderr, "\t b) the file specified by the environment "
			    "variable 'ORBITS_FILE',\n");
	    fprintf(stderr, "\t c) the file '%s.orbits'.\n", argv[0]);
	    fprintf(stderr, "  4. Cmdline arguments after '--' are preserved "
			    "and used by, e.g., PETSc.\n");
	    fprintf(stderr, "See README.quadrule for more details.\n");
	}
#if NONLINEAR_SOLVER == PETSC
	PetscFinalize();
#endif	/* NONLINEAR_SOLVER == PETSC */

#if USE_MPI
	MPI_Finalize();
#endif
	exit(1);
    }

    atexit(clean_up);

    dim = atoi(argv[1]);
    degree = atoi(argv[2]);
    if (argc >= 4) {
	npoints = argv[3][0] == '+' ? -atoi(argv[3] + 1) : atoi(argv[3]);
    }
    if ((dim != 1 && dim != 2 && dim != 3) || degree < 0) {
usage1:
	if (myrank == 0)
	    fprintf(stderr, "\nError: invalid arguments\n");
	goto usage;
    }

#if TRAP_FPE
    if (fedisableexcept(FE_UNDERFLOW) == -1)
	perror("FE_UNDERFLOW");
    if (fedisableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW) == -1)
	perror("FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW");
#endif  /* TRAP_FPE */

    if (argc > 4) {
	char *p;
	if (argc == 5) {
	    if (argv[4][0] == '+')
		stop_flag = 0;
	    guess_max = atoi(argv[4]);
	}
	else if (dim == 1) {
	    if (argc != 6 && argc != 7)
		goto usage1;
	    /* process s2 */
	    if (argv[4][0] != ':')
		s2_user = atoi(argv[4]);
	    /* process s11 */
	    p = argv[5];
	    if (*p != ':') {
		s11_user = strtol(p, &p, 10);
		if (*p != '\0' && *p != ':')
		    goto usage1;
	    }
	    if (*p == ':')
		r11 = atoi(++p);
	    if (r11 < 0 || r11 > 1) {
		if (myrank == 0)
		    fprintf(stderr, "invalid value for r11: %d\n", r11);
		goto usage1;
	    }
	    /* process ntries */
	    if (argc == 7) {
		if (argv[6][0] == '+')
		    stop_flag = 0;
		guess_max = atoi(argv[6]);
	    }
	    /* check consistency of the arguments */
	    if (s2_user >= 0 && s2_user != 0 && s2_user != 1) {
		if (myrank == 0)
		    fprintf(stderr, "\nError: s2 can only be 0 or 1.\n");
		goto usage;
	    }
	    if ((s2_user >= 0 && s2_user != npoints % 2) ||
		(s2_user >= 0 && s11_user >= 0 &&
			npoints != s2_user + 2 * s11_user)) {
		if (myrank == 0)
		    fprintf(stderr, "\nError: npoints and s2/s11 mismatch.\n");
		goto usage;
	    }
	}
	else if (dim == 2) {
	    if (argc != 7 && argc != 8)
		goto usage1;
	    /* process s3 */
	    if (argv[4][0] != ':')
		s3_user = atoi(argv[4]);
	    /* process s21 */
	    p = argv[5];
	    if (*p != ':') {
		s21_user = strtol(p, &p, 10);
		if (*p != '\0' && *p != ':')
		    goto usage1;
	    }
	    if (*p == ':')
		r21 = atoi(++p);
	    if (r21 < 0 || r21 > 3) {
		if (myrank == 0)
		    fprintf(stderr, "invalid value for r21: %d\n", r21);
		goto usage1;
	    }
	    /* process s111 */
	    p = argv[6];
	    if (*p != ':') {
		s111_user = strtol(p, &p, 10);
		if (*p != '\0' && *p != ':')
		    goto usage1;
	    }
	    if (*p == ':')
		r111 = atoi(++p);
	    if (r111 < 0) {
		if (myrank == 0)
		    fprintf(stderr, "invalid value for r111: %d\n", r111);
		goto usage1;
	    }
	    /* process ntries */
	    if (argc == 8) {
		if (argv[7][0] == '+')
		    stop_flag = 0;
		guess_max = atoi(argv[7]);
	    }
	    /* check consistency of the arguments */
	    if (s3_user >= 0 && s3_user != 0 && s3_user != 1) {
		if (myrank == 0)
		    fprintf(stderr, "\nError: s3 can only be 0 or 1.\n");
		goto usage;
	    }
	    if (s3_user >= 0 && s21_user >= 0 && s111_user >= 0 &&
		npoints != s3_user + 3 * s21_user + 6 * s111_user) {
		if (myrank == 0)
		    fprintf(stderr, "\nError: npoints and s3/s21/s111 "
				    "mismatch.\n");
		goto usage;
	    }
	}
	else {
	    if (argc != 9 && argc != 10)
		goto usage1;
	    /* process s4 */
	    if (argv[4][0] != ':')
		s4_user = atoi(argv[4]);
	    /* process s31 */
	    p = argv[5];
	    if (*p != ':') {
		s31_user = strtol(p, &p, 10);
		if (*p != '\0' && *p != ':')
		    goto usage1;
	    }
	    if (*p == ':')
		r31 = atoi(++p);
	    if (r31 < 0 || r31 > 3) {
		if (myrank == 0)
		    fprintf(stderr, "invalid value for r31: %d\n", r31);
		goto usage1;
	    }
	    /* process s22 */
	    p = argv[6];
	    if (*p != ':') {
		s22_user = strtol(p, &p, 10);
		if (*p != '\0' && *p != ':')
		    goto usage1;
	    }
	    if (*p == ':')
		r22 = atoi(++p);
	    if (r22 < 0 || r22 > 1) {
		if (myrank == 0)
		    fprintf(stderr, "invalid value for r22: %d\n", r22);
		goto usage1;
	    }
	    /* process s211 */
	    p = argv[7];
	    if (*p != ':') {
		s211_user = strtol(p, &p, 10);
		if (*p != '\0' && *p != ':')
		    goto usage1;
	    }
	    if (*p == ':') {
		p++;
		r211e = strtol(p, &p, 10);
		if (*p != '\0' && *p != ':')
		    goto usage1;
		if (*p == ':')
		    r211f = atoi(++p);
	    }
	    if (r211e < 0) {
		if (myrank == 0)
		    fprintf(stderr, "invalid value for r211e: %d\n", r211e);
		goto usage1;
	    }
	    if (r211f < 0) {
		if (myrank == 0)
		    fprintf(stderr, "invalid value for r211f: %d\n", r211f);
		goto usage1;
	    }
	    /* process s1111 */
	    p = argv[8];
	    if (*p != ':') {
		s1111_user = strtol(p, &p, 10);
		if (*p != '\0' && *p != ':')
		    goto usage1;
	    }
	    if (*p == ':')
		r1111 = atoi(++p);
	    if (r1111 < 0) {
		if (myrank == 0)
		    fprintf(stderr, "invalid value for r1111: %d\n", r1111);
		goto usage1;
	    }
	    /* ntries */
	    if (argc == 10) {
		if (argv[9][0] == '+')
		    stop_flag = 0;
		guess_max = atoi(argv[9]);
	    }
	    /* check consistency of the arguments */
	    if (s4_user >= 0 && s4_user != 0 && s4_user != 1) {
		if (myrank == 0)
		    fprintf(stderr, "\nError: s4 can only be 0 or 1.\n");
		goto usage;
	    }
	    if (s4_user >= 0 && s31_user >= 0 && s22_user >= 0 &&
		s211_user >= 0 && s1111_user >= 0 &&
		npoints != s4_user + 4 * s31_user + 6 * s22_user +
					    12 * s211_user + 24 * s1111_user) {
		if (myrank == 0)
		    fprintf(stderr, "\nError: npoints and "
				    "s4/s31/s22/s211/s1111 mismatch.\n");
		goto usage;
	    }
	}
    }

    /* Read predefined orbits */
    if (myrank == 0)
	flag = read_orbits(argv[0]);
#if USE_MPI
    MPI_Bcast(&flag, 1, MPI_INT, 0, MPI_COMM_WORLD);
    if (flag != 0) {
	MPI_Finalize();
	exit(1);
    }
    if (nprocs > 1) {
	/* broadcast stars[] */
	int i, j, n;
	FLOAT *fbuffer, *fp;
	MPI_Bcast(stars, sizeof(stars), MPI_BYTE, 0, MPI_COMM_WORLD);
	for (n = i = 0; i < nstars; i++)
	    n += stars[i].cnt * stars[i].nargs;
	if (n > 0) {
	    fp = fbuffer = malloc(n * sizeof(FLOAT));
	    for (i = 0; i < nstars; i++) {
		if (myrank > 0)
		    break;
		for (j = 0; j < stars[i].cnt * stars[i].nargs; j++)
		    *(fp++) = stars[i].args[j].farg;
	    }
	    MPI_Bcast(fbuffer, n * sizeof(FLOAT), MPI_BYTE, 0, MPI_COMM_WORLD);
	    for (i = 0; i < nstars; i++) {
		if (myrank == 0)
		    break;
		if ((j = stars[i].cnt * stars[i].nargs) == 0)
		    continue;
		stars[i].args = malloc(j * sizeof(*stars[i].args));
		for (j = 0; j < stars[i].cnt * stars[i].nargs; j++, fp++)
		    stars[i].args[j].farg = *fp;
	    }
	    free(fbuffer);
	    have_predefined_orbits = 1;
	}

	/* broadcast monos[] */
	MPI_Bcast(&monos_n, 1, MPI_INT, 0, MPI_COMM_WORLD);
	if (myrank > 0 && monos_n > 0) {
	    monos_alloc = monos_n;
	    monos = malloc(monos_n * sizeof(*monos) * (dim + 1));
	}
	MPI_Bcast(monos, monos_n * sizeof(*monos) * (dim + 1), MPI_BYTE, 0,
		  MPI_COMM_WORLD);
    }
#else	/* USE_MPI */
    if (flag != 0)
	exit(1);
#endif	/* USE_MPI */

    /* TODO: use a parallel random number generator */
#if 0
    m = time(NULL);
#else
    {
	struct timeval tv;
	gettimeofday(&tv, NULL);
	m = tv.tv_sec * 10000 + (tv.tv_usec + 50) / 100;
    }
#endif
#if USE_MPI
    MPI_Bcast(&m, 1, MPI_INT, 0, MPI_COMM_WORLD);
#endif
    srand(m + myrank);

    /* estimate the dimension of the space of polynomials */
    /* m := max degree of predefined monomials */
    m = 0;
    if (monos_n > 0) {
	int i;
	if (dim == 1) {
	    char (*pm)[2] = (void *)monos;
	    for (i = 0; i < monos_n; i++)
		if (m < pm[i][0] + pm[i][1])
		    m = pm[i][0] + pm[i][1];
	}
	else if (dim == 2) {
	    char (*pm)[3] = (void *)monos;
	    for (i = 0; i < monos_n; i++)
		if (m < pm[i][0] + pm[i][1] + pm[i][2])
		    m = pm[i][0] + pm[i][1] + pm[i][2];
	}
	else {
	    char (*pm)[4] = (void *)monos;
	    for (i = 0; i < monos_n; i++)
		if (m < pm[i][0] + pm[i][1] + pm[i][2] + pm[i][3])
		    m = pm[i][0] + pm[i][1] + pm[i][2] + pm[i][3];
	}
    }

    if (dim == 1)
	npolys_max = degree + 1;
    else if (dim == 2)
	npolys_max = (degree + 1) * (degree + 2) / (1 * 2);
    else
	npolys_max = (degree + 1) * (degree + 2) * (degree + 3) / (1 * 2 * 3);

    if (m > 0)
	npolys_max *= m;

    /* estimate minimum number of points */
    if (npoints <= 0) {
	npoints = (npolys_max + dim) / (dim + 1) - npoints;
#if 0
	if (dim == 2) {
	    if (m & 1)
		npoints = (m+1)*(m+3)/8 + (m+1)/4 - npoints;
	    else
		npoints = (m+2)*(m+4)/8 - npoints;
	}
	else {
	    /* TODO */
	}
#endif
    }

    /* generate list of test polynomials */
    poly_gen();

    ncons = setup_constraints(0, 1);

    if (myrank == 0) {
	int v = 0, e = 0, f = 0; /* counters for the constrained points */
	fprintf(stderr, "---------------------------------------"
			"---------------------------------------\n");

#if INDEPENDENT_W
	fprintf(stderr, "Using weights as independent variables\n");
#else	/* INDEPENDENT_W */
	fprintf(stderr, "Using weights as dependent variables\n");
#endif	/* INDEPENDENT_W */

	fprintf(stderr, "Tolerances: report = %0.2le, accept = %0.2le\n",
			(double)REPORT_TOL, (double)ACCEPT_TOL);

	Unused(minpack_solvers);
#if (NONLINEAR_SOLVER == TENSOLVE)
	fprintf(stderr, "Using TENSOLVE to solve nonlinear LS problems.\n");
#elif (NONLINEAR_SOLVER == CCMNF)
	fprintf(stderr, "Using CCMNF to solve nonlinear equations.\n");
#elif (NONLINEAR_SOLVER == MINPACK)
	fprintf(stderr, "Using MINPACK %s to solve nonlinear LS problems.\n",
			minpack_solvers[MINPACK_SOLVER]);
#elif (NONLINEAR_SOLVER == PETSC)
	fprintf(stderr, "Using PETSc snes to solve nonlinear equations.\n");
#endif	/* NONLINEAR_SOLVER == ... */

	fprintf(stderr, "Dim=%d, deg=%d, npoints=%d, npolys=%d (max %d)\n",
			dim, degree, npoints, npolys, npolys_max);

	fprintf(stderr, "Requested orbit types:");
	flag = 0;
#define PRT_ORBIT(s, sname) \
    if (s >= 0) {fprintf(stderr, " %d*%s", s, sname); flag = 1;}
	if (dim == 1) {
	    PRT_ORBIT(s2_user, "s2");
	    PRT_ORBIT(s11_user, "s11");
	}
	else if (dim == 2) {
	    PRT_ORBIT(s3_user, "s3");
	    PRT_ORBIT(s21_user, "s21");
	    PRT_ORBIT(s111_user, "s111");
	}
	else {
	    PRT_ORBIT(s4_user, "s4");
	    PRT_ORBIT(s31_user, "s31");
	    PRT_ORBIT(s22_user, "s22");
	    PRT_ORBIT(s211_user, "s211");
	    PRT_ORBIT(s1111_user, "s1111");
	}
#undef PRT_ORBIT
	fprintf(stderr, "%s", flag ? "\n" : " none\n");

	fprintf(stderr, "Constraints:");
	flag = 0;
#define PRT_RESTRAINT0(cond, fmt, which, value) \
    if (cond) {fprintf(stderr, fmt); flag = 1; which += value;}
#define PRT_RESTRAINT1(cond, fmt, arg, which, value) \
    if (cond) {fprintf(stderr, fmt, arg); flag = 1; which += value;}
	if (dim == 1) {
	    PRT_RESTRAINT0(r11&1,  "\n    vertex\t\t<== r11 & 1", v, 1);
	}
	else if (dim == 2) {
	    PRT_RESTRAINT0(r21&1,  "\n    vertex\t\t<== r21 & 1", v, 1);
	    PRT_RESTRAINT0(r21&2,  "\n    edge center\t\t<== r21 & 2", e, 1);
	    PRT_RESTRAINT1(r111>0, "\n    %d s11 on edge\t<== r111",
				   r111, e, 2 * r111);
	}
	else {
	    PRT_RESTRAINT0(r31&1,   "\n    vertex\t\t<== r31 & 1", v, 1);
	    PRT_RESTRAINT0(r22&1,   "\n    edge center\t\t<== r22 & 1", e, 1);
	    PRT_RESTRAINT1(r211e>0, "\n    %d s11 on edge\t<== r211e",
				    r211e, e, 2 * r211e);
	    PRT_RESTRAINT0(r31&2, "\n    face center\t\t<== r31 & 2", f, 1);
	    PRT_RESTRAINT1(r211f>0, "\n    %d s21 on face\t<== r211f",
				    r211f, f, 3 * r211f);
	    PRT_RESTRAINT1(r1111>0, "\n    %d s111 on face\t<== r1111",
				    r1111, f, 6 * r1111);
	}
#undef PRT_RESTRAINT0
#undef PRT_RESTRAINT1
	if (flag) {
	    char *s = " ";
	    fprintf(stderr, "\n    number of constrained abscissas: %d\n",
				ncons);
	    fprintf(stderr, "    number of constrained points:");
	    if (v != 0) {fprintf(stderr, "%s%d/vertex", s, v); s = ", ";}
	    if (e != 0) {fprintf(stderr, "%s%d/edge", s, e); s = ", ";}
	    if (f != 0) {fprintf(stderr, "%s%d/face", s, f); s = ", ";}
	    fprintf(stderr, "\n");
	}
	else {
	    fprintf(stderr, " none\n");
	}

	fprintf(stderr, "Predefined orbits:%s",
				have_predefined_orbits ? "" : " none");
	for (v = 0; v < nstars; v++) {
	    for (e = 0; e < stars[v].cnt; e++) {
		fprintf(stderr, "\n    %s", stars[v].star);
		for (f = 0; f < stars[v].nargs; f++)
		    fprintf(stderr, "%c%g", f == 0 ? '(' : ',',
			(double)stars[v].args[e * stars[v].nargs + f].farg);
		fprintf(stderr, ")");
	    }
	}
	fprintf(stderr, "\n");

	fprintf(stderr, "---------------------------------------"
			"---------------------------------------\n");
    }

#if 0
    for (m = 0; m < npolys; m++) {
	if (dim == 2)
	    printf("========== poly %d, order = %d+%d = %d\n", m,
		(pbasis[m]->o + dim * pbasis[m]->n)[0],
		(pbasis[m]->o + dim * pbasis[m]->n)[1],
		(pbasis[m]->o + dim * pbasis[m]->n)[0] +
		(pbasis[m]->o + dim * pbasis[m]->n)[1]);
	else
	    printf("========== poly %d, order = %d+%d+%d = %d\n", m,
		(pbasis[m]->o + dim * pbasis[m]->n)[0],
		(pbasis[m]->o + dim * pbasis[m]->n)[1],
		(pbasis[m]->o + dim * pbasis[m]->n)[2],
		(pbasis[m]->o + dim * pbasis[m]->n)[0] +
		(pbasis[m]->o + dim * pbasis[m]->n)[1] +
		(pbasis[m]->o + dim * pbasis[m]->n)[2]);
#if 0
	poly_dump(pbasis[m], stdout);
	printf(";\n");
#endif
    }
#endif

#if SYMMETRY
    /* determine the number of equations, which ensures exactness of the
     * quadrature rules for all polynomials <= some degree */
    neqns = npolys;
#else	/* SYMMETRY */
    neqns = /*npoints*/npolys;
#endif	/* SYMMETRY */

    assert(neqns <= npolys_max);

#if USE_INTERVALS
    if (dim == 1)
	density_1D();
    else if (dim == 2)
	density_2D();
    else
	density_3D();
#endif	/* USE_INTERVALS */

    if (myrank == 0)
	permutations();
    else {
	search(1);
    }

    if (constraints != NULL) {
	free(constraints);
	constraints = NULL;
    }

    if (pbasis != NULL) {
	for (m = 0; m < npolys_max; m++)
	    poly_free(pbasis[m]);
	free(pbasis);
    }
    if (porders != NULL)
	free(porders);

    if (myrank == 0)
	fprintf(stderr, "%d good solution(s) found.\n", nsols);

#if NONLINEAR_SOLVER == PETSC
    PetscFinalize();
#endif	/* NONLINEAR_SOLVER == PETSC */
#if USE_MPI
    MPI_Finalize();
    sync_file(REMOVE_SYNC_FILE);
#endif

    return nsols > 0 ? 0 : 1;
}
