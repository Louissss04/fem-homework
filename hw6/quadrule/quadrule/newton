#!/bin/bash
#
# Bash script which calls the bc scripts to check a quadrature rule and
# improve its precision by doing a few Newton iterations.
#
# The input rule is read from stdin. An input rule is described by a sequence
# of permutation stars of the form 'perm###(...)' or 'cons###(...)' (abscissas)
# and 'dup###(...)' (weights). The input form 'cons###' is used for the so
# called 'constrained orbits' (see README.quadrule).
#
# When running this script user can supply an optional first argument as either
# 'nocons' or 'fullcons':
#     - If 'nocons' is specified then the constraints are ignored, i.e., the
#	constrained orbits are treated just as ordinary orbits.
#     - If 'fullcons' is specified then the constrained orbits are considered
#	'fully constrained'.
# Without this optional argument the constrained orbits are considered
# 'partially constrained'.
#
# The values of the following environment variables are passed to corresponding
# bc variables:
#
#	----------------------------------------
#	Environment		bc
#	----------------------------------------
#	QUADRULE_SCALE		scale
#	QUADRULE_TOL		tol
#	QUADRULE_DIGITS		digits
#	QUADRULE_LEAST_SQUARE	least_square
#	----------------------------------------
#
# Notes:
#
# 1) Running this script without arguments will show a help message and
#    a sample input rule.
#
# 2) '3Dpermu.bc' is generated by running 'sh 3Dpermu.sh'.
#
# 3) Some parameters, such as the precision (scale), the tolerance (tol), etc.,
#    may be changed in the file 'common.bc' near the top.
#
# 4) The bc scripts use multiple letter names and thus require GNU bc.
#
# 5) The abscissas are in barycentric coordinates, the weights are scaled
#    such that they sum to one.
#
# 6) (added on 20180413) The input (stdin) can optionally contain macros of the
#    form `mono###', e.g., `mono4(1)', `mono31(2,1)', `mono22(1,2)', etc.,
#    which defines a set of symmetric mononials in the barycentric coordinates
#    to use as test functions. If the input contains 'mono###' macros, then
#    the set of test functions is set to P(order)\otimes \{set of monomials\}
#    (subject to symmetry w.r.t. permutations of berycentric coordinates).
#
#    This allows to process the new mass-lumping finite elements containing
#    'Mono###' macros (see ../src/mass-lumping.c).
#
# Description of the permutation stars:
#
#    1D stars:
#	perm20(a) = {(a,1-a)}	(special case of an asymmetric point)
#	dup0(w) = {w}
#
#	perm2(a) = permutation(a,a) = {(a,a)}		(a = 1/2)
#	dup2(w) = {w}
#
#	perm11(a) = permutation(a,1-a) = {(a,1-a), (1-a,a)}
#	dup11(w) = {w,w}
#
#    2D stars:
#	perm30(a,b) = {(a,b,1-a-b)}	(special case of an asymmetric point)
#	dup0(w) = {w}
#
#	perm3(a) = permutation(a,a,a) = {(a,a,a)}	(a = 1/3)
#	dup3(w) = {w}
#
#	perm21(a) = permutation(a,a,1-2a) = {(a,a,1-2a), (a,1-2a,a), (1-2a,a,a)}
#	dup21(w) = {w,w,w}
#
#	perm111(a,b) = permutation(a,b,1-a-b) =
#		{(a,b,1-a-b), (b,a,1-a-b), (a,1-a-b,b), (b,1-a-b,a), ...}
#	dup111(w) = {w,w,w,w,w,w}
#
#    3D stars:
#	perm40(a,b,c) = {(a,b,c,1-a-b-c)}
#	dup0(w) = {w}
#
#	perm4(a) = permutation(a,a,a,a) = {(a,a,a,a}}	(a = 1/4)
#	dup4(w) = {w}
#
#	perm31(a) = permutation(a,a,a,1-3a) =
#		{(a,a,a,1-3a), (a,a,1-3a,a), (a,1-3a,a,a), (1-3a,a,a,a)}
#	dup31(w) = {w,w,w,w}
#	
#	perm22(a) = permutation(a,a,0.5-a,0.5-a) = ...
#	dup22(w) = {w,w,w,w,w,w}
#
#	perm211(a,b) = permutation(a,a,b,1-2a-b) = ...
#	dup211(w) = {w,w,w,w,w,w,w,w,w,w,w,w}
#
#	perm1111(a,b,c) = permutation(a,b,c,1-a-b-c) = ...
#	dup1111(w) = {w,w,w,w,w,w,w,w,w,w,w,w,w,w,w,w,w,w,w,w,w,w,w,w}
#
# By Lin-bo Zhang (zlb@lsec.cc.ac.cn), all rights reserved.
#
# $Id: newton,v 1.56 2020/03/19 08:25:00 zlb Exp $
#

for dir in `dirname $0` . $HOME/phg*/utils; do
    test -r $dir/newton.bc && break
done
if ! test -r $dir/newton.bc; then
    echo 1>&2 "Cannot locate newton.bc, abort."
    exit 1
fi
###echo 1>&2 "dir=$dir"

nocons=false
fullcons=false
if test $# -eq 3; then
    if test "$1" = "nocons"; then
	nocons=true
	shift
    elif test "$1" = "fullcons"; then
	fullcons=true
	shift
    fi
fi

if test $# -ne 2; then
    cat 1>&2 <<EEND
Usage: `basename $0` [nocons|fullcons] dim order [<rule_data]

Note:
  1. If 'nocons' is specified then the constraints are ignored.
  2. If 'fullcons' is specified then full constraints are applied.
  3. See comments in the file for more information on its usage.

The following environment variables can be used to change values of the
corresponding variables in common.bc:
	QUADRULE_SCALE, QUADRULE_TOL, QUADRULE_DIGITS, QUADRULE_LEAST_SQUARE

Example usage with a 3D order 5 rule:
% newton 3 5 <<END
dup31(0.1126879257180159)
perm31(0.3108859192633007)
dup31(0.07349304311636196)
perm31(0.09273525031089125)
dup22(0.04254602077708142)
perm22(0.04550370412564964)
END
EEND
    exit 1
fi

if [ "$1" -lt 1 -o "$1" -gt 3 ]; then
    echo 1>&2 "Invalid dimension!"
    exit 1
fi

if [ "$2" -lt 0 ]; then
    echo 1>&2 "Invalid order!"
    exit 1
fi

. `dirname $0`/read_rule.func

dim=$1
order=$2
tmp=/tmp/newton-$$.bc
echo 1>&2 "Reading quadrature rule from stdin ..."
trap "rm -f $tmp" 0 1 2 3 15
(
    echo "#-------------- common.bc"
    # process "QUADRULE_*" environment variables
    SED_CMDS="-e ''"
    for v in scale tol digits least_square; do
	V=`echo $v | awk '{printf toupper($0)}'`	# V=uppercase(v)
	eval "value=\${QUADRULE_$V}"			# value
	test -n "$value" || continue
	if test "$v" = "tol"; then
	    # convert, e.g., 1e20 to 1*10^20
	    value=`echo $value | sed -e 's/[eEdD]/*10^/g'`
	fi
	SED_CMDS="$SED_CMDS -e 's/^\\($v[	 ]*=\\).*\$/\\1 $value/g'"
    done
    ####echo 1>&2 "SED_CMDS=$SED_CMDS"
    cat $dir/common.bc | eval "sed $SED_CMDS"
    echo "#-------------- $dir/${dim}Dpermu.bc"
    cat $dir/${dim}Dpermu.bc
    echo "#-------------- $dir/${dim}Dfuncs.bc"
    cat $dir/${dim}Dfuncs.bc
    echo "#-------------- rule data"
    echo "order=$order"
    if $fullcons; then
	echo "fullcons=1"
    else
	echo "fullcons=0"
    fi
    if $nocons; then
	read_rule | sed -e 's/cons/perm/g'
    else
	read_rule
    fi 
) >$tmp
echo 1>&2 "Done."
	###cat $tmp
	###exit

#--------------------------------------------- Refine the rule (Newton its)
bc -ql $tmp $dir/newton.bc | awk 'BEGIN {stderr_flag = 0} {
    if (stderr_flag || match($0, /^ERROR|^WARNING|^\*\*\*|^$/)) {
	n = length($0)
	if (substr($0, n) == "\\") {
	    printf "%s", substr($0, 1, n - 1) >"/dev/stderr"
	    stderr_flag = 1
	} else {
	    printf "%s\n", $0 >"/dev/stderr"
	    stderr_flag = 0
	}
	next
    }
    # replace "%"s with double quotes
    gsub("%", "\"")
    sep="=========================== the output ==========================="
    if (match($0, /static FLOAT QUAD_[0-9]*D_P[0-9]*_wts/))
	printf("\n%s\n\n", sep) >"/dev/stderr";
    # concatenate continuation lines
    n = length($0)
    if (substr($0, n) == "\\")
	printf "%s", substr($0, 1, n - 1)
    else
	printf "%s\n", $0
    fflush()
}'
